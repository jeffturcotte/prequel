#!/usr/bin/php
<?php
/**
 * Phew. A FlourishSQL Database CLI
 *
 * @copyright  Copyright (c) 2011 Jeff Turcotte
 * @author     Jeff Turcotte [jt] <jeffturcotte.com>
 * @license    MIT
 * @version    1.0.0b1
 */
class Prequel {
	public static $connections = array();
	public static $active_connection = 0;
	public static $truncate = 40;
	public static $expert   = FALSE;
	public static $db;
	
	public static function getSchema() 
	{
		return new fSchema(self::$db);
	}

	public static function query() 
	{
		$args = func_get_args();
		return call_user_func_array(
			array(self::$db, 'query'),
			$args
		);
	}
	
	public static function getDatabase() {
		return self::$db->getDatabase();
	}

	public static function connect($uri)
	{
		$uri  = parse_url($uri);
		
		$type = isset($uri['scheme']) ? $uri['scheme'] : NULL;
		$user = isset($uri['user'])   ? $uri['user'] : NULL;
		$pass = isset($uri['pass'])   ? $uri['pass'] : '';
		$name = isset($uri['path'])   ? trim($uri['path'], '/') : NULL;
		$host = isset($uri['host'])   ? $uri['host'] : NULL;
		$port = isset($uri['port'])   ? $uri['port'] : NULL;

		if (!$name) {
			$name = $host;
			$host = 'localhost';
		}

		if ($type == 'pgsql') {
			$type = 'postgresql';
		}
		
		//$serial = $type ':'

		$db = new fDatabase($type, $name, $user, $pass, $host, $port);
		$db->getConnection();
		self::$db = $db;
	}	
}

function normal($string) {
	return "\033[0;0m{$string}\033[0m";
}

function red($string) {
	return "\033[0;31m{$string}\033[0m";
}
function green($string) {
	return "\033[1;32m{$string}\033[0m";
}
function cyan($string) {
	return "\033[1;36m{$string}\033[0m";
}
function under($string) {
	return "\033[4m{$string}\033[0m";
}
function purple($string) {
	return "\033[1;35m{$string}\033[0m";
}
function yellow($string) {
	return "\033[1;33m{$string}\033[0m";
}
function grey($string) {
	return "\033[1;30m{$string}\033[0m";
}
function bold($string) {
	return "\033[1;1m{$string}\033[0m";
}
function blue($string) {
	return "\033[34m{$string}\033[0m";
}
function bluebg($string) {
	return "\033[1;44m{$string}\033[0m";
}
function ask() {
	$line = readline('' . blue(Prequel::getDatabase()) . ': ');
	readline_add_history($line);
	return $line;
}
function describe($arg) {
	if ($arg) {
		$current_table = $arg;
		
		try {
			$table = Prequel::getSchema()->getColumnInfo($arg);
			$keys  = Prequel::getSchema()->getKeys($arg);
			$relations = Prequel::getSchema()->getRelationships($arg);
		} catch (Exception $e) {
			echo red($e->getMessage()) . "\n";
			return;
		}
		
		$primary_key_columns = $keys['primary'];
		$unique_key_columns = array();
		$compound_unique_keys = array();
		foreach($keys['unique'] as $info) {
			if (count($info) == 1) {
				array_push($unique_key_columns, $info[0]);
			} else {
				array_push($compound_unique_keys, $info);
			}
		}
		$foreign_key_columns = array();
		foreach($keys['foreign'] as $info) {
			array_push($foreign_key_columns, $info['column']);
		}
		
		$rows = array();
		$formats = array();
		
		foreach($table as $column => $info) {
			$format = array();
			$name = $column;
			$type = $info['type'];
			
			if ($info['max_length'] && $info['max_length'] <= 100000000) {
				$type .= ' (' . $info['max_length'] . ')';
			}
			
			if ($info['auto_increment']) {
				$type .= ' autoinc';
			}
			
			//print_r($foreign_key_columns);
			$key = '';

			if (in_array($column, $foreign_key_columns)) {
				$type .= ' foreign';
				$format['column'] = purple('%s');
				$format['type'] = purple('%s');
			}
			if (in_array($column, $keys['primary'])) {
				$type .= ' primary';
				$format['column'] = yellow('%s');
				$format['type'] = yellow('%s');
			} 
			if (in_array($column, $unique_key_columns)) {
				$type .= ' unique';
				$format['column'] = yellow('%s');
				$format['type'] = yellow('%s');
			}

			$modifiers = '';

			if ($info['not_null']) {
				$modifiers .= ' not null';
			}
			if ($info['valid_values']) {
				$modifiers .= ' valid(' . join(', ', $info['valid_values']) . ')';
			}
			if ($info['default']) {
				$modifiers .= ' default('.$info['default'] . ")";
			}

			array_push($rows, array(
				'column' => $name,
				'type' => $type,
				'modifiers' => $modifiers
			));
			array_push($formats, $format);
			
		}
		
		print_columns($rows, FALSE, $formats, FALSE);
		
		$rows = array();
		$formats = array();
		
		echo "\n";
		foreach($relations as $type => $relation) {
			foreach($relation as $info) {
				$table = $info['table'];
				$column = $info['column'];
				$related_column = $info['related_column'];
				$related_table = $info['related_table'];
				$join_table = (isset($info['join_table'])) ? $info['join_table'] : '';
				$join_column = (isset($info['join_column'])) ? $info['join_column'] : '';
				
				if ($type == 'one-to-one') {
					echo "ONE TO ONE\n";
					continue;
				}
				if ($type == 'many-to-one') {
					echo sprintf(
						'has one of %s through %s.%s -> %s.%s', 
						cyan($related_table), 
						cyan($table),
						purple($column),
						cyan($related_table),
						yellow($related_column)
					);
					echo "\n";
					continue;
				}
				if ($type == 'one-to-many') {
					echo sprintf(
						'has many %s through %s.%s -> %s.%s', 
						cyan($related_table), 
						cyan($related_table), 
						purple($related_column),
						cyan($table),
						yellow($column)
					);
					//echo ($info['on_delete'] != "no_action") ? ", on delete: " . strtolower(fGrammar::humanize($info['on_delete'])) : '';
					//echo ($info['on_update'] != "no_action") ? ", on update: " . strtolower(fGrammar::humanize($info['on_update'])) : '';
					echo "\n";
					continue;
				}
				if ($type == 'many-to-many') {
					echo sprintf(
						'has and belongs to many %s through %s',
						cyan($related_table),
						cyan($join_table)
					);
					echo "\n";
					continue;
				}
			}
		}
		
		echo "\n";
		
		$count = Prequel::query("SELECT count(*) FROM {$current_table}")->fetchScalar();
		echo (green("{$count} records") . "\n");
		
		return;
	}

	$tables = Prequel::getSchema()->getTables();

	$rows = array();
	foreach($tables as $table) {
		$count = Prequel::query("SELECT count(*) FROM {$table}")->fetchScalar();
		
		array_push($rows, array(
			'table' => $table,
			'# of records' => $count
		));
	}
	print_columns($rows, FALSE, array(), FALSE);
	return;
}

function truncate($args) {
	$length = (int) $args;
	if ($length == -1) {
		$length = null;
	}
	Prequel::$truncate = $length;
	
	if ($length) {
		echo green('Column truncate set to ' . $length) . "\n";
		return;
	}
	
	echo green('Column truncate disabled') . "\n";
}

function parse_opt($line) {
	preg_match('/^\\\\([a-z]+)(\s+([^\s]*))?/i', $line, $matches);
	
	$action = isset($matches[1]) ? $matches[1] : 'h';
	$args   = isset($matches[3]) ? $matches[3] : '';
	
	switch ($action) {
		case 'd':
			describe($args);
			break;
		case 't':
			truncate($args);
			break;
		case 'q':
			exit();
			break;
		case 'x':
			toggle_expert();
			break;
		case 'h':
		default:
			help();
			break;
	}
}

function toggle_expert() {
	if (Prequel::$expert == TRUE) {
		Prequel::$expert = FALSE;
		echo green('Expert mode disabled') . "\n";
		return;
	}
	
	Prequel::$expert = TRUE;
	echo green('Expert mode enabled. Be careful!') . "\n";
}

function help() {
	print_columns(array(
		array('option' => '\d <table>', 'description' => 'Describe a specific table or list all tables.'),
		array('option' => '\t [#]',     'description' => 'Set the max column length for query results display. -1 for unlimited. default: 40'),
		array('option' => '\q',         'description' => 'Quit'),
		array('option' => '\x',         'description' => 'Toggle expert mode. Will prompt before UPDATE or DELETE without WHERE clause. default: enabled')
	));
	
}

function print_columns($rows, $truncate=NULL, $formats=array(), $zebra=TRUE) {
	// find max lengths
	$max_lengths = array();
	
	if ($rows instanceof fResult) {
		$first_row = $rows->fetchRow();
		$rows->rewind();
	} else {
		$first_row = current($rows);
	}
	
	foreach($first_row as $column => $value) {
		$max_lengths[$column] = strlen($column) + 2;
	}
	foreach($rows as $row) {
		foreach($row as $column => $value) {
			$len = strlen($value);
			if ($truncate && $len > $truncate) {
				$len = $truncate + 1;
			}
			if (!isset($max_lengths[$column]) || $len > $max_lengths[$column]) {
				$max_lengths[$column] = $len;
			}
		}
	}

	reset($rows);
	
	foreach($first_row as $column => $value) {
		echo sprintf(grey("%-{$max_lengths[$column]}s  "), $column);
	}

	echo "\n";
	
	$i = 0;
	foreach($rows as $index => $row) {
		$string = '';
		foreach($row as $column => $value) {
			$format = '%s';
			
			if (isset($formats[$index][$column])) {
				$format = $formats[$index][$column];
			}
			
			if ($zebra) {
				$format = ($i % 2) ? bold($format) : normal($format); 
			}
			
			$format = sprintf(
				$format, 
				"%-{$max_lengths[$column]}s  "
			);
			
			if ($truncate && strlen($value) > $truncate) {
				$value = substr($value, 0, $truncate) . red('â€¦');
			}
			$string .= sprintf($format, preg_replace('/[\n\t\r]/', '', trim($value)));
		}
		
		echo $string . "\n";
		$i++;
	}
}

function main() {
	global $argv;

	try {
		Prequel::connect($argv[1]);
	} catch (Exception $e) {
		echo $e->getMessage() . "\n";
		exit();
	}
	
	while(TRUE) {
		$line = ask();
		
		if (strpos($line, '\\') === 0) {
			parse_opt($line);
			continue;
		} 
		
		// EXPERT MODE
		if (!Prequel::$expert) {
			if (preg_match('/DELETE|UPDATE/i', $line) && !preg_match('/WHERE/i', $line)) {
				while(!isset($confirm) || !in_array($confirm, array('y', 'n'))) {
					$confirm = readline(red('No WHERE clause found. Are you sure? (y/n): '));
				} 
				if ($confirm == 'n') {
					unset($confirm);
					continue;
				}
				unset($confirm);
			}
		}
		
		try {
			$result = Prequel::query($line);
			$affected_rows = $result->countAffectedRows();
			$returned_rows = $result->countReturnedRows();
			
			$result->tossIfNoRows();
			
			if ($returned_rows) {
				print_columns($result, Prequel::$truncate);
				echo sprintf(green("%d row(s)"), $returned_rows) . "\n";
			} else {
				echo sprintf(green("%d row(s)"), $affected_rows);
			}
			
		} catch (fNoRowsException $e) {
			echo green("0 row(s)") . "\n";
		} catch (Exception $e) {
			echo $e->getMessage() . "\n";
		}
	}
}

// =============
// = Libraries =
// =============

/**
 * Provides low-level debugging, error and exception functionality
 * 
 * @copyright  Copyright (c) 2007-2011 Will Bond, others
 * @author     Will Bond [wb] <will@flourishlib.com>
 * @author     Will Bond, iMarc LLC [wb-imarc] <will@imarc.net>
 * @author     Nick Trew [nt]
 * @license    http://flourishlib.com/license
 * 
 * @package    Flourish
 * @link       http://flourishlib.com/fCore
 * 
 * @version    1.0.0b20
 * @changes    1.0.0b20  Backwards Compatibility Break - Updated ::expose() to not wrap the data in HTML when running via CLI, and instead just append a newline [wb, 2011-02-24]
 * @changes    1.0.0b19  Added detection of AIX to ::checkOS() [wb, 2011-01-19]
 * @changes    1.0.0b18  Updated ::expose() to be able to accept multiple parameters [wb, 2011-01-10]
 * @changes    1.0.0b17  Fixed a bug with ::backtrace() triggering notices when an argument is not UTF-8 [wb, 2010-08-17]
 * @changes    1.0.0b16  Added the `$types` and `$regex` parameters to ::startErrorCapture() and the `$regex` parameter to ::stopErrorCapture() [wb, 2010-08-09]
 * @changes    1.0.0b15  Added ::startErrorCapture() and ::stopErrorCapture() [wb, 2010-07-05]
 * @changes    1.0.0b14  Changed ::enableExceptionHandling() to only call fException::printMessage() when the destination is not `html` and no callback has been defined, added ::configureSMTP() to allow using fSMTP for error and exception emails [wb, 2010-06-04]
 * @changes    1.0.0b13  Added the `$backtrace` parameter to ::backtrace() [wb, 2010-03-05]
 * @changes    1.0.0b12  Added ::getDebug() to check for the global debugging flag, added more specific BSD checks to ::checkOS() [wb, 2010-03-02]
 * @changes    1.0.0b11  Added ::detectOpcodeCache() [nt+wb, 2009-10-06]
 * @changes    1.0.0b10  Fixed ::expose() to properly display when output includes non-UTF-8 binary data [wb, 2009-06-29]
 * @changes    1.0.0b9   Added ::disableContext() to remove context info for exception/error handling, tweaked output for exceptions/errors [wb, 2009-06-28]
 * @changes    1.0.0b8   ::enableErrorHandling() and ::enableExceptionHandling() now accept multiple email addresses, and a much wider range of emails [wb-imarc, 2009-06-01]
 * @changes    1.0.0b7   ::backtrace() now properly replaces document root with {doc_root} on Windows [wb, 2009-05-02]
 * @changes    1.0.0b6   Fixed a bug with getting the server name for error messages when running on the command line [wb, 2009-03-11]
 * @changes    1.0.0b5   Fixed a bug with checking the error/exception destination when a log file is specified [wb, 2009-03-07]
 * @changes    1.0.0b4   Backwards compatibility break - ::getOS() and ::getPHPVersion() removed, replaced with ::checkOS() and ::checkVersion() [wb, 2009-02-16]
 * @changes    1.0.0b3   ::handleError() now displays what kind of error occured as the heading [wb, 2009-02-15]
 * @changes    1.0.0b2   Added ::registerDebugCallback() [wb, 2009-02-07]
 * @changes    1.0.0b    The initial implementation [wb, 2007-09-25]
 */
class fCore
{
	// The following constants allow for nice looking callbacks to static methods
	const backtrace               = 'fCore::backtrace';
	const call                    = 'fCore::call';
	const callback                = 'fCore::callback';
	const checkOS                 = 'fCore::checkOS';
	const checkVersion            = 'fCore::checkVersion';
	const configureSMTP           = 'fCore::configureSMTP';
	const debug                   = 'fCore::debug';
	const detectOpcodeCache       = 'fCore::detectOpcodeCache';
	const disableContext          = 'fCore::disableContext';
	const dump                    = 'fCore::dump';
	const enableDebugging         = 'fCore::enableDebugging';
	const enableDynamicConstants  = 'fCore::enableDynamicConstants';
	const enableErrorHandling     = 'fCore::enableErrorHandling';
	const enableExceptionHandling = 'fCore::enableExceptionHandling';
	const expose                  = 'fCore::expose';
	const getDebug                = 'fCore::getDebug';
	const handleError             = 'fCore::handleError';
	const handleException         = 'fCore::handleException';
	const registerDebugCallback   = 'fCore::registerDebugCallback';
	const reset                   = 'fCore::reset';
	const sendMessagesOnShutdown  = 'fCore::sendMessagesOnShutdown';
	const startErrorCapture       = 'fCore::startErrorCapture';
	const stopErrorCapture        = 'fCore::stopErrorCapture';
	
	
	/**
	 * A regex to match errors to capture
	 * 
	 * @var string
	 */
	static private $captured_error_regex = NULL;
	
	/**
	 * The previous error handler
	 * 
	 * @var callback
	 */
	static private $captured_errors_previous_handler = NULL;
	
	/**
	 * The types of errors to capture
	 * 
	 * @var integer
	 */
	static private $captured_error_types = NULL;
	
	/**
	 * An array of errors that have been captured
	 * 
	 * @var array
	 */
	static private $captured_errors = NULL;
	
	/**
	 * If the context info has been shown
	 * 
	 * @var boolean
	 */
	static private $context_shown = FALSE;
	
	/**
	 * If global debugging is enabled
	 * 
	 * @var boolean
	 */
	static private $debug = NULL;
	
	/**
	 * A callback to pass debug messages to
	 * 
	 * @var callback
	 */
	static private $debug_callback = NULL;
	
	/**
	 * If dynamic constants should be created
	 * 
	 * @var boolean
	 */
	static private $dynamic_constants = FALSE;
	
	/**
	 * Error destination
	 * 
	 * @var string
	 */
	static private $error_destination = 'html';
	
	/**
	 * An array of errors to be send to the destination upon page completion
	 * 
	 * @var array
	 */
	static private $error_message_queue = array();
	
	/**
	 * Exception destination
	 * 
	 * @var string
	 */
	static private $exception_destination = 'html';
	
	/**
	 * Exception handler callback
	 * 
	 * @var mixed
	 */
	static private $exception_handler_callback = NULL;
	
	/**
	 * Exception handler callback parameters
	 * 
	 * @var array
	 */
	static private $exception_handler_parameters = array();
	
	/**
	 * The message generated by the uncaught exception
	 * 
	 * @var string
	 */
	static private $exception_message = NULL;
	
	/**
	 * If this class is handling errors
	 * 
	 * @var boolean
	 */
	static private $handles_errors = FALSE;
	
	/**
	 * If this class is handling exceptions
	 * 
	 * @var boolean
	 */
	static private $handles_exceptions = FALSE;
	
	/**
	 * If the context info should be shown with errors/exceptions
	 * 
	 * @var boolean
	 */
	static private $show_context = TRUE;
	
	/**
	 * An SMTP connection for sending error and exception emails
	 * 
	 * @var fSMTP
	 */
	static private $smtp_connection = NULL;
	
	/**
	 * The email address to send error emails from
	 * 
	 * @var string
	 */
	static private $smtp_from_email = NULL;
	
	
	/**
	 * Creates a nicely formatted backtrace to the the point where this method is called
	 * 
	 * @param  integer $remove_lines  The number of trailing lines to remove from the backtrace
	 * @param  array   $backtrace     A backtrace from [http://php.net/backtrace `debug_backtrace()`] to format - this is not usually required or desired
	 * @return string  The formatted backtrace
	 */
	static public function backtrace($remove_lines=0, $backtrace=NULL)
	{
		if ($remove_lines !== NULL && !is_numeric($remove_lines)) {
			$remove_lines = 0;
		}
		
		settype($remove_lines, 'integer');
		
		$doc_root  = realpath($_SERVER['DOCUMENT_ROOT']);
		$doc_root .= (substr($doc_root, -1) != DIRECTORY_SEPARATOR) ? DIRECTORY_SEPARATOR : '';
		
		if ($backtrace === NULL) {
			$backtrace = debug_backtrace();
		}
		
		while ($remove_lines > 0) {
			array_shift($backtrace);
			$remove_lines--;
		}
		
		$backtrace = array_reverse($backtrace);
		
		$bt_string = '';
		$i = 0;
		foreach ($backtrace as $call) {
			if ($i) {
				$bt_string .= "\n";
			}
			if (isset($call['file'])) {
				$bt_string .= str_replace($doc_root, '{doc_root}' . DIRECTORY_SEPARATOR, $call['file']) . '(' . $call['line'] . '): ';
			} else {
				$bt_string .= '[internal function]: ';
			}
			if (isset($call['class'])) {
				$bt_string .= $call['class'] . $call['type'];
			}
			if (isset($call['class']) || isset($call['function'])) {
				$bt_string .= $call['function'] . '(';
					$j = 0;
					if (!isset($call['args'])) {
						$call['args'] = array();
					}
					foreach ($call['args'] as $arg) {
						if ($j) {
							$bt_string .= ', ';
						}
						if (is_bool($arg)) {
							$bt_string .= ($arg) ? 'true' : 'false';
						} elseif (is_null($arg)) {
							$bt_string .= 'NULL';
						} elseif (is_array($arg)) {
							$bt_string .= 'Array';
						} elseif (is_object($arg)) {
							$bt_string .= 'Object(' . get_class($arg) . ')';
						} elseif (is_string($arg)) {
							// Shorten the UTF-8 string if it is too long
							if (strlen(utf8_decode($arg)) > 18) {
								// If we can't match as unicode, try single byte
								if (!preg_match('#^(.{0,15})#us', $arg, $short_arg)) {
									preg_match('#^(.{0,15})#s', $arg, $short_arg);
								}
								$arg  = $short_arg[0] . '...';
							}
							$bt_string .= "'" . $arg . "'";
						} else {
							$bt_string .= (string) $arg;
						}
						$j++;
					}
				$bt_string .= ')';
			}
			$i++;
		}
		
		return $bt_string;
	}
	
	
	/**
	 * Performs a [http://php.net/call_user_func call_user_func()], while translating PHP 5.2 static callback syntax for PHP 5.1 and 5.0
	 * 
	 * Parameters can be passed either as a single array of parameters or as
	 * multiple parameters.
	 * 
	 * {{{
	 * #!php
	 * // Passing multiple parameters in a normal fashion
	 * fCore::call('Class::method', TRUE, 0, 'test');
	 * 
	 * // Passing multiple parameters in a parameters array
	 * fCore::call('Class::method', array(TRUE, 0, 'test'));
	 * }}}
	 * 
	 * To pass parameters by reference they must be assigned to an
	 * array by reference and the function/method being called must accept those
	 * parameters by reference. If either condition is not met, the parameter
	 * will be passed by value.
	 * 
	 * {{{
	 * #!php
	 * // Passing parameters by reference
	 * fCore::call('Class::method', array(&$var1, &$var2));
	 * }}}
	 * 
	 * @param  callback $callback    The function or method to call
	 * @param  array    $parameters  The parameters to pass to the function/method
	 * @return mixed  The return value of the called function/method
	 */
	static public function call($callback, $parameters=array())
	{
		// Fix PHP 5.0 and 5.1 static callback syntax
		if (is_string($callback) && strpos($callback, '::') !== FALSE) {
			$callback = explode('::', $callback);
		}
		
		$parameters = array_slice(func_get_args(), 1);
		if (sizeof($parameters) == 1 && is_array($parameters[0])) {
			$parameters = $parameters[0];
		}
		
		return call_user_func_array($callback, $parameters);
	}
	
	
	/**
	 * Translates a Class::method style static method callback to array style for compatibility with PHP 5.0 and 5.1 and built-in PHP functions
	 * 
	 * @param  callback $callback  The callback to translate
	 * @return array  The translated callback
	 */
	static public function callback($callback)
	{
		if (is_string($callback) && strpos($callback, '::') !== FALSE) {
			return explode('::', $callback);
		}
		
		return $callback;
	}
	
	
	/**
	 * Checks an error/exception destination to make sure it is valid
	 * 
	 * @param  string $destination  The destination for the exception. An email, file or the string `'html'`.
	 * @return string|boolean  `'email'`, `'file'`, `'html'` or `FALSE`
	 */
	static private function checkDestination($destination)
	{
		if ($destination == 'html') {
			return 'html';
		}
		
		if (preg_match('~^(?:                                                                         # Allow leading whitespace
						   (?:[^\x00-\x20\(\)<>@,;:\\\\"\.\[\]]+|"[^"\\\\\n\r]+")                     # An "atom" or a quoted string
						   (?:\.[ \t]*(?:[^\x00-\x20\(\)<>@,;:\\\\"\.\[\]]+|"[^"\\\\\n\r]+"[ \t]*))*  # A . plus another "atom" or a quoted string, any number of times
						  )@(?:                                                                       # The @ symbol
						   (?:[a-z0-9\\-]+\.)+[a-z]{2,}|                                              # Domain name
						   (?:(?:[01]?\d?\d|2[0-4]\d|25[0-5])\.){3}(?:[01]?\d?\d|2[0-4]\d|25[0-5])    # (or) IP addresses
						  )
						  (?:\s*,\s*                                                                  # Any number of other emails separated by a comma with surrounding spaces
						   (?:
							(?:[^\x00-\x20\(\)<>@,;:\\\\"\.\[\]]+|"[^"\\\\\n\r]+")
							(?:\.[ \t]*(?:[^\x00-\x20\(\)<>@,;:\\\\"\.\[\]]+|"[^"\\\\\n\r]+"[ \t]*))*
						   )@(?:
							(?:[a-z0-9\\-]+\.)+[a-z]{2,}|
							(?:(?:[01]?\d?\d|2[0-4]\d|25[0-5])\.){3}(?:[01]?\d?\d|2[0-4]\d|25[0-5])
						   )
						  )*$~xiD', $destination)) {
			return 'email';
		}
		
		$path_info     = pathinfo($destination);
		$dir_exists    = file_exists($path_info['dirname']);
		$dir_writable  = ($dir_exists) ? is_writable($path_info['dirname']) : FALSE;
		$file_exists   = file_exists($destination);
		$file_writable = ($file_exists) ? is_writable($destination) : FALSE;
		
		if (!$dir_exists || ($dir_exists && ((!$file_exists && !$dir_writable) || ($file_exists && !$file_writable)))) {
			return FALSE;
		}
			
		return 'file';
	}
	
	
	/**
	 * Returns is the current OS is one of the OSes passed as a parameter
	 * 
	 * Valid OS strings are:
	 *  - `'linux'`
	 *  - `'aix'`
	 *  - `'bsd'`
	 *  - `'freebsd'`
	 *  - `'netbsd'`
	 *  - `'openbsd'`
	 *  - `'osx'`
	 *  - `'solaris'`
	 *  - `'windows'`
	 * 
	 * @param  string $os  The operating system to check - see method description for valid OSes
	 * @param  string ...
	 * @return boolean  If the current OS is included in the list of OSes passed as parameters
	 */
	static public function checkOS($os)
	{
		$oses = func_get_args();
		
		$valid_oses = array('linux', 'aix', 'bsd', 'freebsd', 'openbsd', 'netbsd', 'osx', 'solaris', 'windows');
		
		if ($invalid_oses = array_diff($oses, $valid_oses)) {
			throw new fProgrammerException(
				'One or more of the OSes specified, %$1s, is invalid. Must be one of: %2$s.',
				join(' ', $invalid_oses),
				join(', ', $valid_oses)
			);
		}
		
		$uname = php_uname('s');
		
		if (stripos($uname, 'linux') !== FALSE) {
			return in_array('linux', $oses);
		
		} elseif (stripos($uname, 'aix') !== FALSE) {
			return in_array('aix', $oses);
		
		} elseif (stripos($uname, 'netbsd') !== FALSE) {
			return in_array('netbsd', $oses) || in_array('bsd', $oses);
		
		} elseif (stripos($uname, 'openbsd') !== FALSE) {
			return in_array('openbsd', $oses) || in_array('bsd', $oses);
		
		} elseif (stripos($uname, 'freebsd') !== FALSE) {
			return in_array('freebsd', $oses) || in_array('bsd', $oses);
		
		} elseif (stripos($uname, 'solaris') !== FALSE || stripos($uname, 'sunos') !== FALSE) {
			return in_array('solaris', $oses);
		
		} elseif (stripos($uname, 'windows') !== FALSE) {
			return in_array('windows', $oses);
		
		} elseif (stripos($uname, 'darwin') !== FALSE) {
			return in_array('osx', $oses);
		} 
		
		throw new fEnvironmentException('Unable to determine the current OS');
	}
	
	
	/**
	 * Checks to see if the running version of PHP is greater or equal to the version passed
	 * 
	 * @return boolean  If the running version of PHP is greater or equal to the version passed
	 */
	static public function checkVersion($version)
	{
		static $running_version = NULL;
		
		if ($running_version === NULL) {
			$running_version = preg_replace(
				'#^(\d+\.\d+\.\d+).*$#D',
				'\1',
				PHP_VERSION
			);
		}
		
		return version_compare($running_version, $version, '>=');
	}
	
	
	/**
	 * Composes text using fText if loaded
	 * 
	 * @param  string  $message    The message to compose
	 * @param  mixed   $component  A string or number to insert into the message
	 * @param  mixed   ...
	 * @return string  The composed and possible translated message
	 */
	static private function compose($message)
	{
		$args = array_slice(func_get_args(), 1);
		
		if (class_exists('fText', FALSE)) {
			return call_user_func_array(
				array('fText', 'compose'),
				array($message, $args)
			);
		} else {
			return vsprintf($message, $args);
		}
	}
	
	
	/**
	 * Sets an fSMTP object to be used for sending error and exception emails
	 * 
	 * @param  fSMTP  $smtp        The SMTP connection to send emails over
	 * @param  string $from_email  The email address to use in the `From:` header
	 * @return void
	 */
	static public function configureSMTP($smtp, $from_email)
	{
		self::$smtp_connection = $smtp;
		self::$smtp_from_email = $from_email;
	}
	
	
	/**
	 * Prints a debugging message if global or code-specific debugging is enabled
	 * 
	 * @param  string  $message  The debug message
	 * @param  boolean $force    If debugging should be forced even when global debugging is off
	 * @return void
	 */
	static public function debug($message, $force=FALSE)
	{
		if ($force || self::$debug) {
			if (self::$debug_callback) {
				call_user_func(self::$debug_callback, $message);
			} else {
				self::expose($message);
			}
		}
	}
	
	
	/**
	 * Detects if a PHP opcode cache is installed
	 * 
	 * The following opcode caches are currently detected:
	 * 
	 *  - [http://pecl.php.net/package/APC APC]
	 *  - [http://eaccelerator.net eAccelerator]
	 *  - [http://www.nusphere.com/products/phpexpress.htm Nusphere PhpExpress]
	 *  - [http://turck-mmcache.sourceforge.net/index_old.html Turck MMCache]
	 *  - [http://xcache.lighttpd.net XCache]
	 *  - [http://www.zend.com/en/products/server/ Zend Server (Optimizer+)]
	 *  - [http://www.zend.com/en/products/platform/ Zend Platform (Code Acceleration)]
	 * 
	 * @return boolean  If a PHP opcode cache is loaded
	 */
	static public function detectOpcodeCache()
	{		
		$apc              = ini_get('apc.enabled');
		$eaccelerator     = ini_get('eaccelerator.enable');
		$mmcache          = ini_get('mmcache.enable');
		$phpexpress       = function_exists('phpexpress');
		$xcache           = ini_get('xcache.size') > 0 && ini_get('xcache.cacher');
		$zend_accelerator = ini_get('zend_accelerator.enabled');
		$zend_plus        = ini_get('zend_optimizerplus.enable');
		
		return $apc || $eaccelerator || $mmcache || $phpexpress || $xcache || $zend_accelerator || $zend_plus;
	}
	
	
	/**
	 * Creates a string representation of any variable using predefined strings for booleans, `NULL` and empty strings
	 * 
	 * The string output format of this method is very similar to the output of
	 * [http://php.net/print_r print_r()] except that the following values
	 * are represented as special strings:
	 *   
	 *  - `TRUE`: `'{true}'`
	 *  - `FALSE`: `'{false}'`
	 *  - `NULL`: `'{null}'`
	 *  - `''`: `'{empty_string}'`
	 * 
	 * @param  mixed $data  The value to dump
	 * @return string  The string representation of the value
	 */
	static public function dump($data)
	{
		if (is_bool($data)) {
			return ($data) ? '{true}' : '{false}';
		
		} elseif (is_null($data)) {
			return '{null}';
		
		} elseif ($data === '') {
			return '{empty_string}';
		
		} elseif (is_array($data) || is_object($data)) {
			
			ob_start();
			var_dump($data);
			$output = ob_get_contents();
			ob_end_clean();
			
			// Make the var dump more like a print_r
			$output = preg_replace('#=>\n(  )+(?=[a-zA-Z]|&)#m', ' => ', $output);
			$output = str_replace('string(0) ""', '{empty_string}', $output);
			$output = preg_replace('#=> (&)?NULL#', '=> \1{null}', $output);
			$output = preg_replace('#=> (&)?bool\((false|true)\)#', '=> \1{\2}', $output);
			$output = preg_replace('#string\(\d+\) "#', '', $output);
			$output = preg_replace('#"(\n(  )*)(?=\[|\})#', '\1', $output);
			$output = preg_replace('#(?:float|int)\((-?\d+(?:.\d+)?)\)#', '\1', $output);
			$output = preg_replace('#((?:  )+)\["(.*?)"\]#', '\1[\2]', $output);
			$output = preg_replace('#(?:&)?array\(\d+\) \{\n((?:  )*)((?:  )(?=\[)|(?=\}))#', "Array\n\\1(\n\\1\\2", $output);
			$output = preg_replace('/object\((\w+)\)#\d+ \(\d+\) {\n((?:  )*)((?:  )(?=\[)|(?=\}))/', "\\1 Object\n\\2(\n\\2\\3", $output);
			$output = preg_replace('#^((?:  )+)}(?=\n|$)#m', "\\1)\n", $output);
			$output = substr($output, 0, -2) . ')';
			
			// Fix indenting issues with the var dump output
			$output_lines = explode("\n", $output);
			$new_output = array();
			$stack = 0;
			foreach ($output_lines as $line) {
				if (preg_match('#^((?:  )*)([^ ])#', $line, $match)) {
					$spaces = strlen($match[1]);
					if ($spaces && $match[2] == '(') {
						$stack += 1;
					}
					$new_output[] = str_pad('', ($spaces)+(4*$stack)) . $line;
					if ($spaces && $match[2] == ')') {
						$stack -= 1;
					}
				} else {
					$new_output[] = str_pad('', ($spaces)+(4*$stack)) . $line;
				}
			}
			
			return join("\n", $new_output);
			
		} else {
			return (string) $data;
		}
	}
	
	
	/**
	 * Disables including the context information with exception and error messages
	 * 
	 * The context information includes the following superglobals:
	 * 
	 *  - `$_SERVER`
	 *  - `$_POST`
	 *  - `$_GET`
	 *  - `$_SESSION`
	 *  - `$_FILES`
	 *  - `$_COOKIE`
	 * 
	 * @return void
	 */
	static public function disableContext()
	{
		self::$show_context = FALSE;
	}
	
	
	/**
	 * Enables debug messages globally, i.e. they will be shown for any call to ::debug()
	 * 
	 * @param  boolean $flag  If debugging messages should be shown
	 * @return void
	 */
	static public function enableDebugging($flag)
	{
		self::$debug = (boolean) $flag;
	}
	
	
	/**
	 * Turns on a feature where undefined constants are automatically created with the string value equivalent to the name
	 * 
	 * This functionality only works if ::enableErrorHandling() has been
	 * called first. This functionality may have a very slight performance
	 * impact since a `E_STRICT` error message must be captured and then a
	 * call to [http://php.net/define define()] is made.
	 * 
	 * @return void
	 */
	static public function enableDynamicConstants()
	{
		if (!self::$handles_errors) {
			throw new fProgrammerException(
				'Dynamic constants can not be enabled unless error handling has been enabled via %s',
				__CLASS__ . '::enableErrorHandling()'
			);
		}
		self::$dynamic_constants = TRUE;
	}
	
	
	/**
	 * Turns on developer-friendly error handling that includes context information including a backtrace and superglobal dumps
	 * 
	 * All errors that match the current
	 * [http://php.net/error_reporting error_reporting()] level will be
	 * redirected to the destination and will include a full backtrace. In
	 * addition, dumps of the following superglobals will be made to aid in
	 * debugging:
	 * 
	 *  - `$_SERVER`
	 *  - `$_POST`
	 *  - `$_GET`
	 *  - `$_SESSION`
	 *  - `$_FILES`
	 *  - `$_COOKIE`
	 * 
	 * The superglobal dumps are only done once per page, however a backtrace
	 * in included for each error.
	 * 
	 * If an email address is specified for the destination, only one email
	 * will be sent per script execution. If both error and
	 * [enableExceptionHandling() exception handling] are set to the same
	 * email address, the email will contain both errors and exceptions.
	 * 
	 * @param  string $destination  The destination for the errors and context information - an email address, a file path or the string `'html'`
	 * @return void
	 */
	static public function enableErrorHandling($destination)
	{
		if (!self::checkDestination($destination)) {
			return;
		}
		self::$error_destination = $destination;
		self::$handles_errors    = TRUE;
		set_error_handler(self::callback(self::handleError));
	}
	
	
	/**
	 * Turns on developer-friendly uncaught exception handling that includes context information including a backtrace and superglobal dumps
	 * 
	 * Any uncaught exception will be redirected to the destination specified,
	 * and the page will execute the `$closing_code` callback before exiting.
	 * The destination will receive a message with the exception messaage, a
	 * full backtrace and dumps of the following superglobals to aid in
	 * debugging:
	 * 
	 *  - `$_SERVER`
	 *  - `$_POST`
	 *  - `$_GET`
	 *  - `$_SESSION`
	 *  - `$_FILES`
	 *  - `$_COOKIE`
	 * 
	 * The superglobal dumps are only done once per page, however a backtrace
	 * in included for each error.
	 * 
	 * If an email address is specified for the destination, only one email
	 * will be sent per script execution.
	 * 
	 * If an email address is specified for the destination, only one email
	 * will be sent per script execution. If both exception and
	 * [enableErrorHandling() error handling] are set to the same
	 * email address, the email will contain both exceptions and errors.
	 * 
	 * @param  string   $destination   The destination for the exception and context information - an email address, a file path or the string `'html'`
	 * @param  callback $closing_code  This callback will happen after the exception is handled and before page execution stops. Good for printing a footer. If no callback is provided and the exception extends fException, fException::printMessage() will be called.
	 * @param  array    $parameters    The parameters to send to `$closing_code`
	 * @return void
	 */
	static public function enableExceptionHandling($destination, $closing_code=NULL, $parameters=array())
	{
		if (!self::checkDestination($destination)) {
			return;
		}
		self::$handles_exceptions           = TRUE;
		self::$exception_destination        = $destination;
		self::$exception_handler_callback   = $closing_code;
		if (!is_object($parameters)) {
			settype($parameters, 'array');
		} else {
			$parameters = array($parameters);
		}
		self::$exception_handler_parameters = $parameters;
		set_exception_handler(self::callback(self::handleException));
	}
	
	
	/**
	 * Prints the ::dump() of a value
	 *
	 * The dump will be printed in a `<pre>` tag with the class `exposed` if
	 * PHP is running anywhere but via the command line (cli). If PHP is
	 * running via the cli, the data will be printed, followed by a single
	 * line break (`\n`).
	 * 
	 * If multiple parameters are passed, they are exposed as an array.
	 * 
	 * @param  mixed $data  The value to show
	 * @param  mixed ...
	 * @return void
	 */
	static public function expose($data)
	{
		$args = func_get_args();
		if (count($args) > 1) {
			$data = $args;
		}
		if (PHP_SAPI != 'cli') {
			echo '<pre class="exposed">' . htmlspecialchars((string) self::dump($data), ENT_QUOTES) . '</pre>';
		} else {
			echo self::dump($data) . "\n";
		}
	}
	
	
	/**
	 * Generates some information about the context of an error or exception
	 * 
	 * @return string  A string containing `$_SERVER`, `$_GET`, `$_POST`, `$_FILES`, `$_SESSION` and `$_COOKIE`
	 */
	static private function generateContext()
	{
		return self::compose('Context') . "\n-------" .
			"\n\n\$_SERVER: "  . self::dump($_SERVER) .
			"\n\n\$_POST: " . self::dump($_POST) .
			"\n\n\$_GET: " . self::dump($_GET) .
			"\n\n\$_FILES: "   . self::dump($_FILES) .
			"\n\n\$_SESSION: " . self::dump((isset($_SESSION)) ? $_SESSION : NULL) .
			"\n\n\$_COOKIE: " . self::dump($_COOKIE);
	}
	
	
	/**
	 * If debugging is enabled
	 * 
	 * @param  boolean $force  If debugging is forced
	 * @return boolean  If debugging is enabled
	 */
	static public function getDebug($force=FALSE)
	{
		return self::$debug || $force;
	}
	
	
	/**
	 * Handles an error, creating the necessary context information and sending it to the specified destination
	 * 
	 * @internal
	 * 
	 * @param  integer $error_number   The error type
	 * @param  string  $error_string   The message for the error
	 * @param  string  $error_file     The file the error occured in
	 * @param  integer $error_line     The line the error occured on
	 * @param  array   $error_context  A references to all variables in scope at the occurence of the error
	 * @return void
	 */
	static public function handleError($error_number, $error_string, $error_file=NULL, $error_line=NULL, $error_context=NULL)
	{
		if (self::$dynamic_constants && $error_number == E_NOTICE) {
			if (preg_match("#^Use of undefined constant (\w+) - assumed '\w+'\$#D", $error_string, $matches)) {
				define($matches[1], $matches[1]);
				return;
			}
		}
		
		$capturing   = is_array(self::$captured_errors);
		$level_match = (bool) (error_reporting() & $error_number);
		
		if (!$capturing && !$level_match) {
			return;
		}
		
		$doc_root  = realpath($_SERVER['DOCUMENT_ROOT']);
		$doc_root .= (substr($doc_root, -1) != '/' && substr($doc_root, -1) != '\\') ? '/' : '';
		
		$backtrace = self::backtrace(1);
		
		// Remove the reference to handleError
		$backtrace = preg_replace('#: fCore::handleError\(.*?\)$#', '', $backtrace);
		
		$error_string = preg_replace('# \[<a href=\'.*?</a>\]: #', ': ', $error_string);
		
		// This was added in 5.2
		if (!defined('E_RECOVERABLE_ERROR')) {
			define('E_RECOVERABLE_ERROR', 4096);
		}
		
		// These were added in 5.3
		if (!defined('E_DEPRECATED')) {
			define('E_DEPRECATED', 8192);
		}
		
		if (!defined('E_USER_DEPRECATED')) {
			define('E_USER_DEPRECATED', 16384);
		}
		
		switch ($error_number) {
			case E_WARNING:           $type = self::compose('Warning');           break;
			case E_NOTICE:            $type = self::compose('Notice');            break;
			case E_USER_ERROR:        $type = self::compose('User Error');        break;
			case E_USER_WARNING:      $type = self::compose('User Warning');      break;
			case E_USER_NOTICE:       $type = self::compose('User Notice');       break;
			case E_STRICT:            $type = self::compose('Strict');            break;
			case E_RECOVERABLE_ERROR: $type = self::compose('Recoverable Error'); break;
			case E_DEPRECATED:        $type = self::compose('Deprecated');        break;
			case E_USER_DEPRECATED:   $type = self::compose('User Deprecated');   break;
		}
		
		if ($capturing) {
			$type_to_capture   = (bool) (self::$captured_error_types & $error_number);
			$string_to_capture = !self::$captured_error_regex || (self::$captured_error_regex && preg_match(self::$captured_error_regex, $error_string));
			if ($type_to_capture && $string_to_capture) {
				self::$captured_errors[] = array(
					'number'    => $error_number,
					'type'      => $type,
					'string'    => $error_string,
					'file'      => str_replace($doc_root, '{doc_root}/', $error_file),
					'line'      => $error_line,
					'backtrace' => $backtrace,
					'context'   => $error_context
				);
				return;
			}
			
			// If the old handler is not this method, then we must have been trying to match a regex and failed
			// so we pass the error on to the original handler to do its thing
			if (self::$captured_errors_previous_handler != array('fCore', 'handleError')) {
				if (self::$captured_errors_previous_handler === NULL) {
					return FALSE;
				}
				return call_user_func(self::$captured_errors_previous_handler, $error_number, $error_string, $error_file, $error_line, $error_context);
			
			// If we get here, this method is the error handler, but we don't want to actually report the error so we return
			} elseif (!$level_match) {
				return;
			}
		}
		
		$error = $type . "\n" . str_pad('', strlen($type), '-') . "\n" . $backtrace . "\n" . $error_string;
		
		self::sendMessageToDestination('error', $error);
	}
	
	
	/**
	 * Handles an uncaught exception, creating the necessary context information, sending it to the specified destination and finally executing the closing callback
	 * 
	 * @internal
	 * 
	 * @param  object $exception  The uncaught exception to handle
	 * @return void
	 */
	static public function handleException($exception)
	{
		$message = ($exception->getMessage()) ? $exception->getMessage() : '{no message}';
		if ($exception instanceof fException) {
			$trace = $exception->formatTrace();
		} else {
			$trace = $exception->getTraceAsString();
		}
		$code = ($exception->getCode()) ? ' (code ' . $exception->getCode() . ')' : '';
		
		$info       = $trace . "\n" . $message . $code;
		$headline   = self::compose("Uncaught") . " " . get_class($exception);
		$info_block = $headline . "\n" . str_pad('', strlen($headline), '-') . "\n" . trim($info);
				
		self::sendMessageToDestination('exception', $info_block);
		
		if (self::$exception_handler_callback === NULL) {
			if (self::$exception_destination != 'html' && $exception instanceof fException) {
				$exception->printMessage();
			}
			return;
		}
				
		try {
			self::call(self::$exception_handler_callback, self::$exception_handler_parameters);
		} catch (Exception $e) {
			trigger_error(
				self::compose(
					'An exception was thrown in the %s closing code callback',
					'setExceptionHandling()'
				),
				E_USER_ERROR
			);
		}
	}
	
	
	/**
	 * Registers a callback to handle debug messages instead of the default action of calling ::expose() on the message
	 * 
	 * @param  callback $callback  A callback that accepts a single parameter, the string debug message to handle
	 * @return void
	 */
	static public function registerDebugCallback($callback)
	{
		self::$debug_callback = self::callback($callback);	
	}
	
	
	/**
	 * Resets the configuration of the class
	 * 
	 * @internal
	 * 
	 * @return void
	 */
	static public function reset()
	{
		if (self::$handles_errors) {
			restore_error_handler();
		}
		if (self::$handles_exceptions) {
			restore_exception_handler();
		}
		
		if (is_array(self::$captured_errors)) {
			restore_error_handler();
		}
		
		self::$captured_error_regex             = NULL;
		self::$captured_errors_previous_handler = NULL;
		self::$captured_error_types             = NULL;
		self::$captured_errors                  = NULL;
		self::$context_shown                    = FALSE;
		self::$debug                            = NULL;
		self::$debug_callback                   = NULL;
		self::$dynamic_constants                = FALSE;
		self::$error_destination                = 'html';
		self::$error_message_queue              = array();
		self::$exception_destination            = 'html';
		self::$exception_handler_callback       = NULL;
		self::$exception_handler_parameters     = array();
		self::$exception_message                = NULL;
		self::$handles_errors                   = FALSE;
		self::$handles_exceptions               = FALSE;
		self::$show_context                     = TRUE;
	}
	
	
	/**
	 * Sends an email or writes a file with messages generated during the page execution
	 * 
	 * This method prevents multiple emails from being sent or a log file from
	 * being written multiple times for one script execution.
	 * 
	 * @internal
	 * 
	 * @return void
	 */
	static public function sendMessagesOnShutdown()
	{
		$subject = self::compose(
			'[%1$s] One or more errors or exceptions occured at %2$s',
			isset($_SERVER['SERVER_NAME']) ? $_SERVER['SERVER_NAME'] : php_uname('n'),
			date('Y-m-d H:i:s')
		);
		
		$messages = array();
		
		if (self::$error_message_queue) {
			$message = join("\n\n", self::$error_message_queue);
			$messages[self::$error_destination] = $message;
		}
		
		if (self::$exception_message) {
			if (isset($messages[self::$exception_destination])) {
				$messages[self::$exception_destination] .= "\n\n";
			} else {
				$messages[self::$exception_destination] = '';
			}
			$messages[self::$exception_destination] .= self::$exception_message;
		}
		
		foreach ($messages as $destination => $message) {
			if (self::$show_context) {
				$message .= "\n\n" . self::generateContext();
			}
			
			if (self::checkDestination($destination) == 'email') {
				if (self::$smtp_connection) {
					$email = new fEmail();
					foreach (explode(',', $destination) as $recipient) {
						$email->addRecipient($recipient);
					}
					$email->setFromEmail(self::$smtp_from_email);
					$email->setSubject($subject);
					$email->setBody($message);
					$email->send(self::$smtp_connection);
				} else {
					mail($destination, $subject, $message);
				}
			
			} else {
				$handle = fopen($destination, 'a');
				fwrite($handle, $subject . "\n\n");
				fwrite($handle, $message . "\n\n");
				fclose($handle);
			}
		}
	}
	
	
	/**
	 * Handles sending a message to a destination
	 * 
	 * If the destination is an email address or file, the messages will be
	 * spooled up until the end of the script execution to prevent multiple
	 * emails from being sent or a log file being written to multiple times.
	 * 
	 * @param  string $type     If the message is an error or an exception
	 * @param  string $message  The message to send to the destination
	 * @return void
	 */
	static private function sendMessageToDestination($type, $message)
	{
		$destination = ($type == 'exception') ? self::$exception_destination : self::$error_destination;
		
		if ($destination == 'html') {
			if (self::$show_context && !self::$context_shown) {
				self::expose(self::generateContext());
				self::$context_shown = TRUE;
			}
			self::expose($message);
			return;
		}

		static $registered_function = FALSE;
		if (!$registered_function) {
			register_shutdown_function(self::callback(self::sendMessagesOnShutdown));
			$registered_function = TRUE;
		}
		
		if ($type == 'error') {
			self::$error_message_queue[] = $message;
		} else {
			self::$exception_message = $message;
		}
	}
	
	
	/**
	 * Temporarily enables capturing error messages 
	 * 
	 * @param  integer $types  The error types to capture - this should be as specific as possible - defaults to all (E_ALL | E_STRICT)
	 * @param  string  $regex  A PCRE regex to match against the error message
	 * @return void
	 */
	static public function startErrorCapture($types=NULL, $regex=NULL)
	{
		if ($types === NULL) {
			$types = E_ALL | E_STRICT;
		}
		self::$captured_error_types             = $types;
		self::$captured_errors                  = array();
		self::$captured_errors_previous_handler = set_error_handler(self::callback(self::handleError));
		self::$captured_error_regex             = $regex;
	}
	
	
	/**
	 * Stops capturing error messages, returning all that have been captured
	 * 
	 * @param  string $regex  A PCRE regex to filter messages by
	 * @return array  The captured error messages
	 */
	static public function stopErrorCapture($regex=NULL)
	{
		$captures = self::$captured_errors;
		self::$captured_error_regex             = NULL;
		self::$captured_errors_previous_handler = NULL;
		self::$captured_error_types             = NULL;
		self::$captured_errors                  = NULL;
		
		restore_error_handler();
		
		if ($regex) {
			$new_captures = array();
			foreach ($captures as $capture) {
				if (!preg_match($regex, $capture['string'])) { continue; }
				$new_captures[] = $capture;
			}
			$captures = $new_captures;
		}
		
		return $captures;
	}
	
	
	/**
	 * Forces use as a static class
	 * 
	 * @return fCore
	 */
	private function __construct() { }
}

/**
 * Provides a common API for different databases - will automatically use any installed extension
 * 
 * This class is implemented to use the UTF-8 character encoding. Please see
 * http://flourishlib.com/docs/UTF-8 for more information.
 * 
 * The following databases are supported:
 * 
 *  - [http://ibm.com/db2 DB2]
 *  - [http://microsoft.com/sql/ MSSQL]
 *  - [http://mysql.com MySQL]
 *  - [http://oracle.com Oracle]
 *  - [http://postgresql.org PostgreSQL]
 *  - [http://sqlite.org SQLite]
 * 
 * The class will automatically use the first of the following extensions it finds:
 * 
 *  - DB2
 *   - [http://php.net/ibm_db2 ibm_db2]
 *   - [http://php.net/pdo_ibm pdo_ibm]
 *  - MSSQL
 *   - [http://msdn.microsoft.com/en-us/library/cc296221.aspx sqlsrv]
 *   - [http://php.net/pdo_dblib pdo_dblib]
 *   - [http://php.net/mssql mssql] (or [http://php.net/sybase sybase])
 *  - MySQL
 *   - [http://php.net/mysql mysql]
 *   - [http://php.net/mysqli mysqli]
 *   - [http://php.net/pdo_mysql pdo_mysql]
 *  - Oracle
 *   - [http://php.net/oci8 oci8]
 *   - [http://php.net/pdo_oci pdo_oci]
 *  - PostgreSQL
 *   - [http://php.net/pgsql pgsql]
 *   - [http://php.net/pdo_pgsql pdo_pgsql]
 *  - SQLite
 *   - [http://php.net/pdo_sqlite pdo_sqlite] (for v3.x)
 *   - [http://php.net/sqlite sqlite] (for v2.x)
 * 
 * The `odbc` and `pdo_odbc` extensions are not supported due to character
 * encoding and stability issues on Windows, and functionality on non-Windows
 * operating systems.
 * 
 * @copyright  Copyright (c) 2007-2011 Will Bond
 * @author     Will Bond [wb] <will@flourishlib.com>
 * @license    http://flourishlib.com/license
 * 
 * @package    Flourish
 * @link       http://flourishlib.com/fDatabase
 * 
 * @version    1.0.0b36
 * @changes    1.0.0b36  Updated ::escape() and methods that use ::escape() to handle float values that don't contain a digit before or after the . [wb, 2011-02-01]
 * @changes    1.0.0b35  Updated the class to replace `LIMIT` and `OFFSET` value placeholders in the SQL with their values before translating since most databases that translate `LIMIT` statements need to move or add values together [wb, 2011-01-11]
 * @changes    1.0.0b34  Fixed a bug with creating translated prepared statements [wb, 2011-01-09]
 * @changes    1.0.0b33  Added code to explicitly set the connection encoding for the mysql and mysqli extensions since some PHP installs don't see to fully respect `SET NAMES` [wb, 2010-12-06]
 * @changes    1.0.0b32  Fixed handling auto-incrementing values for Oracle when the trigger was on `INSERT OR UPDATE` instead of just `INSERT` [wb, 2010-12-04]
 * @changes    1.0.0b31  Fixed handling auto-incrementing values for MySQL when the `INTO` keyword is left out of an `INSERT` statement [wb, 2010-11-04]
 * @changes    1.0.0b30  Fixed the pgsql, mssql and mysql extensions to force a new connection instead of reusing an existing one [wb, 2010-08-17]
 * @changes    1.0.0b29  Backwards Compatibility Break - removed ::enableSlowQueryWarnings(), added ability to replicate via ::registerHookCallback() [wb, 2010-08-10]
 * @changes    1.0.0b28  Backwards Compatibility Break - removed ODBC support. Added support for the `pdo_ibm` extension. [wb, 2010-07-31]
 * @changes    1.0.0b27  Fixed a bug with running multiple copies of a SQL statement with string values through a single ::translatedQuery() call [wb, 2010-07-14]
 * @changes    1.0.0b26  Updated the class to use new fCore functionality [wb, 2010-07-05]
 * @changes    1.0.0b25  Added IBM DB2 support [wb, 2010-04-13]
 * @changes    1.0.0b24  Fixed an auto-incrementing transaction bug with Oracle and debugging issues with all databases [wb, 2010-03-17]
 * @changes    1.0.0b23  Resolved another bug with capturing auto-incrementing values for PostgreSQL and Oracle [wb, 2010-03-15]
 * @changes    1.0.0b22  Changed ::clearCache() to also clear the cache on the fSQLTranslation [wb, 2010-03-09]
 * @changes    1.0.0b21  Added ::execute() for result-less SQL queries, ::prepare() and ::translatedPrepare() to create fStatement objects for prepared statements, support for prepared statements in ::query() and ::unbufferedQuery(), fixed default caching key for ::enableCaching() [wb, 2010-03-02]
 * @changes    1.0.0b20  Added a parameter to ::enableCaching() to provide a key token that will allow cached values to be shared between multiple databases with the same schema [wb, 2009-10-28]
 * @changes    1.0.0b19  Added support for escaping identifiers (column and table names) to ::escape(), added support for database schemas, rewrote internal SQL string spliting [wb, 2009-10-22]
 * @changes    1.0.0b18  Updated the class for the new fResult and fUnbufferedResult APIs, fixed ::unescape() to not touch NULLs [wb, 2009-08-12]
 * @changes    1.0.0b17  Added the ability to pass an array of all values as a single parameter to ::escape() instead of one value per parameter [wb, 2009-08-11]
 * @changes    1.0.0b16  Fixed PostgreSQL and Oracle from trying to get auto-incrementing values on inserts when explicit values were given [wb, 2009-08-06]
 * @changes    1.0.0b15  Fixed a bug where auto-incremented values would not be detected when table names were quoted [wb, 2009-07-15]
 * @changes    1.0.0b14  Changed ::determineExtension() and ::determineCharacterSet() to be protected instead of private [wb, 2009-07-08]
 * @changes    1.0.0b13  Updated ::escape() to accept arrays of values for insertion into full SQL strings [wb, 2009-07-06]
 * @changes    1.0.0b12  Updates to ::unescape() to improve performance [wb, 2009-06-15]
 * @changes    1.0.0b11  Changed replacement values in preg_replace() calls to be properly escaped [wb, 2009-06-11]
 * @changes    1.0.0b10  Changed date/time/timestamp escaping from `strtotime()` to fDate/fTime/fTimestamp for better localization support [wb, 2009-06-01]
 * @changes    1.0.0b9   Fixed a bug with ::escape() where floats that start with a . were encoded as `NULL` [wb, 2009-05-09]
 * @changes    1.0.0b8   Added Oracle support, change PostgreSQL code to no longer cause lastval() warnings, added support for arrays of values to ::escape() [wb, 2009-05-03]
 * @changes    1.0.0b7   Updated for new fCore API [wb, 2009-02-16]
 * @changes    1.0.0b6   Fixed a bug with executing transaction queries when using the mysqli extension [wb, 2009-02-12]
 * @changes    1.0.0b5   Changed @ error suppression operator to `error_reporting()` calls [wb, 2009-01-26]
 * @changes    1.0.0b4   Added a few error suppression operators back in so that developers don't get errors and exceptions [wb, 2009-01-14]
 * @changes    1.0.0b3   Removed some unnecessary error suppresion operators [wb, 2008-12-11]
 * @changes    1.0.0b2   Fixed a bug with PostgreSQL when using the PDO extension and executing an INSERT statement [wb, 2008-12-11]
 * @changes    1.0.0b    The initial implementation [wb, 2007-09-25]
 */
class fDatabase
{
	/**
	 * Composes text using fText if loaded
	 * 
	 * @param  string  $message    The message to compose
	 * @param  mixed   $component  A string or number to insert into the message
	 * @param  mixed   ...
	 * @return string  The composed and possible translated message
	 */
	static protected function compose($message)
	{
		$args = array_slice(func_get_args(), 1);
		
		if (class_exists('fText', FALSE)) {
			return call_user_func_array(
				array('fText', 'compose'),
				array($message, $args)
			);
		} else {
			return vsprintf($message, $args);
		}
	}
	
	
	/**
	 * An fCache object to cache the schema info to
	 * 
	 * @var fCache
	 */
	private $cache;
	
	/**
	 * The cache prefix to use for cache entries
	 * 
	 * @var string
	 */
	private $cache_prefix;
	
	/**
	 * Database connection resource or PDO object
	 * 
	 * @var mixed
	 */
	private $connection;
	
	/**
	 * The database name
	 * 
	 * @var string
	 */
	private $database;
	
	/**
	 * If debugging is enabled
	 * 
	 * @var boolean
	 */
	private $debug;
	
	/**
	 * A temporary error holder for the mssql extension
	 * 
	 * @var string
	 */
	private $error;
	
	/**
	 * The extension to use for the database specified
	 * 
	 * Options include:
	 * 
	 *  - `'ibm_db2'`
	 *  - `'mssql'`
	 *  - `'mysql'`
	 *  - `'mysqli'`
	 *  - `'oci8'`
	 *  - `'pgsql'`
	 *  - `'sqlite'`
	 *  - `'sqlsrv'`
	 *  - `'pdo'`
	 * 
	 * @var string
	 */
	protected $extension;
	
	/**
	 * Hooks callbacks to be used for accessing and modifying queries
	 * 
	 * This array will have the structure:
	 * 
	 * {{{
	 * array(
	 *     'unmodified' => array({callbacks}),
	 *     'extracted'  => array({callbacks}),
	 *     'run'        => array({callbacks})
	 * )
	 * }}}
	 * 
	 * @var array
	 */
	private $hook_callbacks;
	
	/**
	 * The host the database server is located on
	 * 
	 * @var string
	 */
	private $host;
	
	/**
	 * If a transaction is in progress
	 * 
	 * @var boolean
	 */
	private $inside_transaction;
	
	/**
	 * The password for the user specified
	 * 
	 * @var string
	 */
	private $password;
	
	/**
	 * The port number for the host
	 * 
	 * @var string
	 */
	private $port;
	
	/**
	 * The total number of seconds spent executing queries
	 * 
	 * @var float
	 */
	private $query_time;
	
	/**
	 * A cache of database-specific code
	 * 
	 * @var array 
	 */
	protected $schema_info;
	
	/**
	 * The last executed fStatement object
	 * 
	 * @var fStatement
	 */
	private $statement;
	
	/**
	 * The fSQLTranslation object for this database
	 * 
	 * @var object
	 */
	private $translation;
	
	/**
	 * The database type: `'db2'`, `'mssql'`, `'mysql'`, `'oracle'`, `'postgresql'`, or `'sqlite'`
	 * 
	 * @var string
	 */
	private $type;
	
	/**
	 * The unbuffered query instance
	 * 
	 * @var fUnbufferedResult
	 */
	private $unbuffered_result;
	
	/**
	 * The user to connect to the database as
	 * 
	 * @var string
	 */
	private $username;
	
	
	/**
	 * Configures the connection to a database - connection is not made until the first query is executed
	 * 
	 * @param  string  $type      The type of the database: `'db2'`, `'mssql'`, `'mysql'`, `'oracle'`, `'postgresql'`, `'sqlite'`
	 * @param  string  $database  Name of the database. If SQLite the path to the database file.
	 * @param  string  $username  Database username - not used for SQLite
	 * @param  string  $password  The password for the username specified - not used for SQLite
	 * @param  string  $host      Database server host or IP, defaults to localhost - not used for SQLite. MySQL socket connection can be made by entering `'sock:'` followed by the socket path. PostgreSQL socket connection can be made by passing just `'sock:'`. 
	 * @param  integer $port      The port to connect to, defaults to the standard port for the database type specified - not used for SQLite
	 * @return fDatabase
	 */
	public function __construct($type, $database, $username=NULL, $password=NULL, $host=NULL, $port=NULL)
	{
		$valid_types = array('db2', 'mssql', 'mysql', 'oracle', 'postgresql', 'sqlite');
		if (!in_array($type, $valid_types)) {
			throw new fProgrammerException(
				'The database type specified, %1$s, is invalid. Must be one of: %2$s.',
				$type,
				join(', ', $valid_types)
			);
		}
		
		if (empty($database)) {
			throw new fProgrammerException('No database was specified');
		}
		
		if ($host === NULL) {
			$host = 'localhost';
		}
		
		$this->type     = $type;
		$this->database = $database;
		$this->username = $username;
		$this->password = $password;
		$this->host     = $host;
		$this->port     = $port;
		
		$this->hook_callbacks = array(
			'unmodified' => array(),
			'extracted'  => array(),
			'run'        => array()
		);
		
		$this->schema_info = array();
		
		$this->determineExtension();
	}
	
	
	/**
	 * Closes the open database connection
	 * 
	 * @internal
	 * 
	 * @return void
	 */
	public function __destruct()
	{
		if (!$this->connection) { return; }
		
		fCore::debug('Total query time: ' . $this->query_time . ' seconds', $this->debug);
		if ($this->extension == 'ibm_db2') {
			db2_close($this->connection);
		} elseif ($this->extension == 'mssql') {
			mssql_close($this->connection);
		} elseif ($this->extension == 'mysql') {
			mysql_close($this->connection);
		} elseif ($this->extension == 'mysqli') {
			mysqli_close($this->connection);
		} elseif ($this->extension == 'oci8') {
			oci_close($this->connection);
		} elseif ($this->extension == 'pgsql') {
			pg_close($this->connection);
		} elseif ($this->extension == 'sqlite') {
			sqlite_close($this->connection);
		} elseif ($this->extension == 'sqlsrv') {
			sqlsrv_close($this->connection);
		} elseif ($this->extension == 'pdo') {
			// PDO objects close their own connections when destroyed
		}
	}
	
	
	/**
	 * All requests that hit this method should be requests for callbacks
	 * 
	 * @internal
	 * 
	 * @param  string $method  The method to create a callback for
	 * @return callback  The callback for the method requested
	 */
	public function __get($method)
	{
		return array($this, $method);		
	}
	
	
	/**
	 * Checks to see if an SQL error occured
	 * 
	 * @param  fResult|fUnbufferedResult|boolean $result      The result object for the query
	 * @param  mixed                             $extra_info  The sqlite extension will pass a string error message, the oci8 extension will pass the statement resource
	 * @param  string                            $sql         The SQL that was executed
	 * @return void
	 */
	private function checkForError($result, $extra_info=NULL, $sql=NULL)
	{
		if ($result === FALSE || $result->getResult() === FALSE) {
			
			if ($this->extension == 'ibm_db2') {
				if (is_resource($extra_info)) {
					$message = db2_stmt_errormsg($extra_info);
				} else {
					$message = db2_stmt_errormsg();
				}
			} elseif ($this->extension == 'mssql') {
				$message = $this->error;
				unset($this->error);
			} elseif ($this->extension == 'mysql') {
				$message = mysql_error($this->connection);
			} elseif ($this->extension == 'mysqli') {
				if (is_object($extra_info)) {
					$message = $extra_info->error;	
				} else {
					$message = mysqli_error($this->connection);
				}
			} elseif ($this->extension == 'oci8') {
				$error_info = oci_error($extra_info);
				$message = $error_info['message'];
			} elseif ($this->extension == 'pgsql') {
				$message = pg_last_error($this->connection);
			} elseif ($this->extension == 'sqlite') {
				$message = $extra_info;
			} elseif ($this->extension == 'sqlsrv') {
				$error_info = sqlsrv_errors(SQLSRV_ERR_ALL);
				$message = $error_info[0]['message'];
			} elseif ($this->extension == 'pdo') {
				if ($extra_info instanceof PDOStatement) {
					$error_info = $extra_info->errorInfo();	
				} else {
					$error_info = $this->connection->errorInfo();
				}
				if (empty($error_info[2])) {
					$error_info[2] = 'Unknown error - this usually indicates a bug in the PDO driver';	
				}
				$message = $error_info[2];
			}
			
			$db_type_map = array(
				'db2'        => 'DB2',
				'mssql'      => 'MSSQL',
				'mysql'      => 'MySQL',
				'oracle'     => 'Oracle',
				'postgresql' => 'PostgreSQL',
				'sqlite'     => 'SQLite'
			);
			
			throw new fSQLException(
				'%1$s error (%2$s) in %3$s',
				$db_type_map[$this->type],
				$message,
				is_object($result) ? $result->getSQL() : $sql
			);
		}
	}
	
	
	/**
	 * Clears all of the schema info out of the object and, if set, the fCache object
	 * 
	 * @return void
	 */
	public function clearCache()
	{
		$this->schema_info = array();
		if ($this->cache) {
			$this->cache->delete($this->makeCachePrefix() . 'schema_info');
		}
		if ($this->type == 'mssql') {
			$this->determineCharacterSet();		
		}
		if ($this->translation) {
			$this->translation->clearCache();	
		}
	}
	
	
	/**
	 * Connects to the database specified if no connection exists
	 * 
	 * @return void
	 */
	private function connectToDatabase()
	{
		// Don't try to reconnect if we are already connected
		if ($this->connection) { return; }

		// Establish a connection to the database
		if ($this->extension == 'pdo') {
			$username = $this->username;
			$password = $this->password;
			
			if ($this->type == 'db2') {
				if ($this->host === NULL && $this->port === NULL) {
					$dsn = 'ibm:DSN:' . $this->database;
				} else {
					$dsn  = 'ibm:DRIVER={IBM DB2 ODBC DRIVER};DATABASE=' . $this->database . ';HOSTNAME=' . $this->host . ';';
					$dsn .= 'PORT=' . ($this->port ? $this->port : 60000) . ';';
					$dsn .= 'PROTOCOL=TCPIP;UID=' . $username . ';PWD=' . $password . ';';
					$username = NULL;
					$password = NULL;
				}
				
			} elseif ($this->type == 'mssql') {
				$separator = (fCore::checkOS('windows')) ? ',' : ':';
				$port      = ($this->port) ? $separator . $this->port : '';
				$driver    = (fCore::checkOs('windows')) ? 'mssql' : 'dblib';
				$dsn = $driver . ':host=' . $this->host . $port . ';dbname=' . $this->database;
				
			} elseif ($this->type == 'mysql') {
				if (substr($this->host, 0, 5) == 'sock:') {
					$dsn = 'mysql:unix_socket=' . substr($this->host, 5) . ';dbname=' . $this->database;	
				} else {
					$port = ($this->port) ? ';port=' . $this->port : '';
					$dsn  = 'mysql:host=' . $this->host . ';dbname=' . $this->database . $port;
				}
				
			} elseif ($this->type == 'oracle') {
				$port = ($this->port) ? ':' . $this->port : '';
				$dsn  = 'oci:dbname=' . $this->host . $port . '/' . $this->database . ';charset=AL32UTF8';
				
			} elseif ($this->type == 'postgresql') {
				
				$dsn = 'pgsql:dbname=' . $this->database;
				if ($this->host && $this->host != 'sock:') {
					$dsn .= ' host=' . $this->host;	
				}
				if ($this->port) {
					$dsn .= ' port=' . $this->port;	
				}
				
			} elseif ($this->type == 'sqlite') {
				$dsn = 'sqlite:' . $this->database;
			}
			
			try {
				$this->connection = new PDO($dsn, $username, $password);	
				if ($this->type == 'mysql') {
					$this->connection->setAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY, 1);	
				}
			} catch (PDOException $e) {
				$this->connection = FALSE;
			}
		}
		
		if ($this->extension == 'sqlite') {
			$this->connection = sqlite_open($this->database);
		}
		
		if ($this->extension == 'ibm_db2') {
			$username = $this->username;
			$password = $this->password;
			if ($this->host === NULL && $this->port === NULL) {
				$connection_string = $this->database;
			} else {
				$connection_string  = 'DATABASE=' . $this->database . ';HOSTNAME=' . $this->host . ';';
				$connection_string .= 'PORT=' . ($this->port ? $this->port : 60000) . ';';
				$connection_string .= 'PROTOCOL=TCPIP;UID=' . $this->username . ';PWD=' . $this->password . ';';
				$username = NULL;
				$password = NULL;
			}
			$options = array(
				'autocommit'    => DB2_AUTOCOMMIT_ON,
				'DB2_ATTR_CASE' => DB2_CASE_LOWER
			);
			$this->connection = db2_connect($connection_string, $username, $password, $options);
		}
		
		if ($this->extension == 'mssql') {
			$separator        = (fCore::checkOS('windows')) ? ',' : ':';
			$this->connection = mssql_connect(($this->port) ? $this->host . $separator . $this->port : $this->host, $this->username, $this->password, TRUE);
			if ($this->connection !== FALSE && mssql_select_db($this->database, $this->connection) === FALSE) {
				$this->connection = FALSE;
			}
		}
		
		if ($this->extension == 'mysql') {
			if (substr($this->host, 0, 5) == 'sock:') {
				$host = substr($this->host, 4);
			} elseif ($this->port) {
				$host = $this->host . ':' . $this->port;	
			} else {
				$host = $this->host;	
			}
			$this->connection = mysql_connect($host, $this->username, $this->password, TRUE);
			if ($this->connection !== FALSE && mysql_select_db($this->database, $this->connection) === FALSE) {
				$this->connection = FALSE;
			}
			if ($this->connection && function_exists('mysql_set_charset') && !mysql_set_charset('utf8', $this->connection)) {
                throw new fConnectivityException(
                	'There was an error setting the database connection to use UTF-8'
				);
            }
		}
			
		if ($this->extension == 'mysqli') {
			if (substr($this->host, 0, 5) == 'sock:') {
				$this->connection = mysqli_connect('localhost', $this->username, $this->password, $this->database, $this->port, substr($this->host, 5));
			} elseif ($this->port) {
				$this->connection = mysqli_connect($this->host, $this->username, $this->password, $this->database, $this->port);
			} else {
				$this->connection = mysqli_connect($this->host, $this->username, $this->password, $this->database);
			}
			if ($this->connection && !mysqli_set_charset($this->connection, 'utf8')) {
                throw new fConnectivityException(
                	'There was an error setting the database connection to use UTF-8'
                );
            }
		}
		
		if ($this->extension == 'oci8') {
			$this->connection = oci_connect($this->username, $this->password, $this->host . ($this->port ? ':' . $this->port : '') . '/' . $this->database, 'AL32UTF8');
		}
			
		if ($this->extension == 'pgsql') {
			$connection_string = "dbname='" . addslashes($this->database) . "'";
			if ($this->host && $this->host != 'sock:') {
				$connection_string .= " host='" . addslashes($this->host) . "'";	
			}
			if ($this->username) {
				$connection_string .= " user='" . addslashes($this->username) . "'";
			}
			if ($this->password) {
				$connection_string .= " password='" . addslashes($this->password) . "'";
			}
			if ($this->port) {
				$connection_string .= " port='" . $this->port . "'";
			}
			$this->connection = pg_connect($connection_string, PGSQL_CONNECT_FORCE_NEW);
		}
		
		if ($this->extension == 'sqlsrv') {
			$options = array(
				'Database' => $this->database,
				'UID'      => $this->username,
				'PWD'      => $this->password
			);
			$this->connection = sqlsrv_connect($this->host . ',' . $this->port, $options);
		}
		
		// Ensure the connection was established
		if ($this->connection === FALSE) {
			throw new fConnectivityException(
				'Unable to connect to database'
			);
		}
		
		// Make MySQL act more strict and use UTF-8
		if ($this->type == 'mysql') {
			$this->execute("SET SQL_MODE = 'REAL_AS_FLOAT,PIPES_AS_CONCAT,ANSI_QUOTES,IGNORE_SPACE'");
			$this->execute("SET NAMES 'utf8'");
			$this->execute("SET CHARACTER SET utf8");
		}
		
		// Make SQLite behave like other DBs for assoc arrays
		if ($this->type == 'sqlite') {
			$this->execute('PRAGMA short_column_names = 1');
		}
		
		// Fix some issues with mssql
		if ($this->type == 'mssql') {
			if (!isset($this->schema_info['character_set'])) {
				$this->determineCharacterSet();
			}
			$this->execute('SET TEXTSIZE 65536');
			$this->execute('SET QUOTED_IDENTIFIER ON');
		}
		
		// Make PostgreSQL use UTF-8
		if ($this->type == 'postgresql') {
			$this->execute("SET NAMES 'UTF8'");
		}
		
		// Oracle has different date and timestamp defaults
		if ($this->type == 'oracle') {
			$this->execute("ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD'");
			$this->execute("ALTER SESSION SET NLS_TIMESTAMP_FORMAT = 'YYYY-MM-DD HH24:MI:SS'");
			$this->execute("ALTER SESSION SET NLS_TIMESTAMP_TZ_FORMAT = 'YYYY-MM-DD HH24:MI:SS TZR'");
			$this->execute("ALTER SESSION SET NLS_TIME_FORMAT = 'HH24:MI:SS'");
			$this->execute("ALTER SESSION SET NLS_TIME_TZ_FORMAT = 'HH24:MI:SS TZR'");
		}
	}
	
	
	/**
	 * Determines the character set of a SQL Server database
	 * 
	 * @return void
	 */
	protected function determineCharacterSet()
	{
		$this->schema_info['character_set'] = 'WINDOWS-1252';
		$this->schema_info['character_set'] = $this->query("SELECT 'WINDOWS-' + CONVERT(VARCHAR, COLLATIONPROPERTY(CONVERT(NVARCHAR, DATABASEPROPERTYEX(DB_NAME(), 'Collation')), 'CodePage')) AS charset")->fetchScalar();
		if ($this->cache) {
			$this->cache->set($this->makeCachePrefix() . 'schema_info', $this->schema_info);	
		}
	}
	
	
	/**
	 * Figures out which extension to use for the database type selected
	 * 
	 * @return void
	 */
	protected function determineExtension()
	{
		switch ($this->type) {
			
			case 'db2':
				
				if (extension_loaded('ibm_db2')) {
					$this->extension = 'ibm_db2';
					
				} elseif (class_exists('PDO', FALSE) && in_array('ibm', PDO::getAvailableDrivers())) {
					$this->extension = 'pdo';
					
				} else {
					$type = 'DB2';
					$exts = 'ibm_db2, pdo_ibm';
				}
				break;
			
			case 'mssql':
			
				if (extension_loaded('sqlsrv')) {
					$this->extension = 'sqlsrv';
					
				} elseif (extension_loaded('mssql')) {
					$this->extension = 'mssql';
					
				} elseif (class_exists('PDO', FALSE) && (in_array('dblib', PDO::getAvailableDrivers()) || in_array('mssql', PDO::getAvailableDrivers()))) {
					$this->extension = 'pdo';
					
				} else {
					$type = 'MSSQL';
					$exts = 'mssql, sqlsrv, pdo_dblib (linux), pdo_mssql (windows)';
				}
				break;
			
			
			case 'mysql':
			
				if (extension_loaded('mysqli')) {
					$this->extension = 'mysqli';
					
				} elseif (class_exists('PDO', FALSE) && in_array('mysql', PDO::getAvailableDrivers())) {
					$this->extension = 'pdo';
					
				} elseif (extension_loaded('mysql')) {
					$this->extension = 'mysql';
					
				} else {
					$type = 'MySQL';
					$exts = 'mysql, pdo_mysql, mysqli';
				}
				break;
				
				
			case 'oracle':
				
				if (extension_loaded('oci8')) {
					$this->extension = 'oci8';
					
				} elseif (class_exists('PDO', FALSE) && in_array('oci', PDO::getAvailableDrivers())) {
					$this->extension = 'pdo';
					
				} else {
					$type = 'Oracle';
					$exts = 'oci8, pdo_oci';
				}
				break;
			
			
			case 'postgresql':
			
				if (extension_loaded('pgsql')) {
					$this->extension = 'pgsql';
					
				} elseif (class_exists('PDO', FALSE) && in_array('pgsql', PDO::getAvailableDrivers())) {
					$this->extension = 'pdo';
					
				} else {
					$type = 'PostgreSQL';
					$exts = 'pgsql, pdo_pgsql';
				}
				break;
				
				
			case 'sqlite':
			
				$sqlite_version = 0;
				
				if (file_exists($this->database)) {
					
					$database_handle  = fopen($this->database, 'r');
					$database_version = fread($database_handle, 64);
					fclose($database_handle);
					
					if (strpos($database_version, 'SQLite format 3') !== FALSE) {
						$sqlite_version = 3;
					} elseif (strpos($database_version, '** This file contains an SQLite 2.1 database **') !== FALSE) {
						$sqlite_version = 2;
					} else {
						throw new fConnectivityException(
							'The database specified does not appear to be a valid %1$s or %2$s database',
							'SQLite v2.1',
							'v3'
						);
					}
				}
				
				if ((!$sqlite_version || $sqlite_version == 3) && class_exists('PDO', FALSE) && in_array('sqlite', PDO::getAvailableDrivers())) {
					$this->extension = 'pdo';
					
				} elseif ($sqlite_version == 3 && (!class_exists('PDO', FALSE) || !in_array('sqlite', PDO::getAvailableDrivers()))) {
					throw new fEnvironmentException(
						'The database specified is an %1$s database and the %2$s extension is not installed',
						'SQLite v3',
						'pdo_sqlite'
					);
				
				} elseif ((!$sqlite_version || $sqlite_version == 2) && extension_loaded('sqlite')) {
					$this->extension = 'sqlite';
					
				} elseif ($sqlite_version == 2 && !extension_loaded('sqlite')) {
					throw new fEnvironmentException(
						'The database specified is an %1$s database and the %2$s extension is not installed',
						'SQLite v2.1',
						'sqlite'
					);
				
				} else {
					$type = 'SQLite';
					$exts = 'pdo_sqlite, sqlite';
				}
				break;
		}
		
		if (!$this->extension) {
			throw new fEnvironmentException(
				'The server does not have any of the following extensions for %2$s support: %2$s',
				$type,
				$exts
			);
		}
	}
	
	
	/**
	 * Sets the schema info to be cached to the fCache object specified
	 * 
	 * @param  fCache $cache      The cache to cache to
	 * @param  string $key_token  Internal use only! (this will be used in the cache key to uniquely identify the cache for this fDatabase object) 
	 * @return void
	 */
	public function enableCaching($cache, $key_token=NULL)
	{
		$this->cache = $cache;
		
		if ($key_token !== NULL) {
			$this->cache_prefix = 'fDatabase::' . $this->type . '::' . $key_token . '::';	
		}
		
		$this->schema_info = $this->cache->get($this->makeCachePrefix() . 'schema_info', array());
	}
	
	
	/**
	 * Sets if debug messages should be shown
	 * 
	 * @param  boolean $flag  If debugging messages should be shown
	 * @return void
	 */
	public function enableDebugging($flag)
	{
		$this->debug = (boolean) $flag;
	}
	
	
	/**
	 * Escapes a value for insertion into SQL
	 * 
	 * The valid data types are:
	 * 
	 *  - `'blob'`
	 *  - `'boolean'`
	 *  - `'date'`
	 *  - `'float'`
	 *  - `'identifier'`
	 *  - `'integer'`
	 *  - `'string'` (also varchar, char or text)
	 *  - `'varchar'`
	 *  - `'char'`
	 *  - `'text'`
	 *  - `'time'`
	 *  - `'timestamp'`
	 * 
	 * In addition to being able to specify the data type, you can also pass
	 * in an SQL statement with data type placeholders in the following form:
	 *   
	 *  - `%l` for a blob
	 *  - `%b` for a boolean
	 *  - `%d` for a date
	 *  - `%f` for a float
	 *  - `%r` for an indentifier (table or column name)
	 *  - `%i` for an integer
	 *  - `%s` for a string
	 *  - `%t` for a time
	 *  - `%p` for a timestamp
	 * 
	 * Depending on what `$sql_or_type` and `$value` are, the output will be
	 * slightly different. If `$sql_or_type` is a data type or a single
	 * placeholder and `$value` is:
	 * 
	 *  - a scalar value - an escaped SQL string is returned
	 *  - an array - an array of escaped SQL strings is returned
	 * 
	 * If `$sql_or_type` is a SQL string and `$value` is:
	 * 
	 *  - a scalar value - the escaped value is inserted into the SQL string
	 *  - an array - the escaped values are inserted into the SQL string separated by commas
	 * 
	 * If `$sql_or_type` is a SQL string, it is also possible to pass an array
	 * of all values as a single parameter instead of one value per parameter.
	 * An example would look like the following:
	 * 
	 * {{{
	 * #!php
	 * $db->escape(
	 *     "SELECT * FROM users WHERE status = %s AND authorization_level = %s",
	 *     array('Active', 'Admin')
	 * );
	 * }}}
	 * 
	 * @param  string $sql_or_type  This can either be the data type to escape or an SQL string with a data type placeholder - see method description
	 * @param  mixed  $value        The value to escape - both single values and arrays of values are supported, see method description for details
	 * @param  mixed  ...
	 * @return mixed  The escaped value/SQL or an array of the escaped values
	 */
	public function escape($sql_or_type, $value)
	{
		$values = array_slice(func_get_args(), 1);
		
		if (sizeof($values) < 1) {
			throw new fProgrammerException(
				'No value was specified to escape'
			);	
		}
		
		// Convert all objects into strings
		$values = $this->scalarize($values);
		
		$value = array_shift($values);
		
		// Handle single value escaping
		$callback = NULL;
		
		switch ($sql_or_type) {
			case 'blob':
			case '%l':
				$callback = $this->escapeBlob;
				break;
			case 'boolean':
			case '%b':
				$callback = $this->escapeBoolean;
				break;
			case 'date':
			case '%d':
				$callback = $this->escapeDate;
				break;
			case 'float':
			case '%f':
				$callback = $this->escapeFloat;
				break;
			case 'identifier':
			case '%r':
				$callback = $this->escapeIdentifier;
				break;
			case 'integer':
			case '%i':
				$callback = $this->escapeInteger;
				break;
			case 'string':
			case 'varchar':
			case 'char':
			case 'text':
			case '%s':
				$callback = $this->escapeString;
				break;
			case 'time':
			case '%t':
				$callback = $this->escapeTime;
				break;
			case 'timestamp':
			case '%p':
				$callback = $this->escapeTimestamp;
				break;
		}
		
		if ($callback) {
			if (is_array($value)) {
				// If the values were passed as a single array, this handles that
				if (count($value) == 1 && is_array(current($value))) {
					$value = current($value);
				}
				return array_map($callback, $value);		
			}
			return call_user_func($callback, $value);
		}	
		
		// Fix \' in MySQL and PostgreSQL
		if(($this->type == 'mysql' || $this->type == 'postgresql') && strpos($sql_or_type, '\\') !== FALSE) {
			$sql_or_type = preg_replace("#(?<!\\\\)((\\\\{2})*)\\\\'#", "\\1''", $sql_or_type);	
		}
		
		// Separate the SQL from quoted values
		$parts = $this->splitSQL($sql_or_type);
		
		$temp_sql = '';
		$strings = array();
		
		// Replace strings with a placeholder so they don't mess up the regex parsing
		foreach ($parts as $part) {
			if ($part[0] == "'") {
				$strings[] = $part;
				$part = ':string_' . (sizeof($strings)-1);
			}
			$temp_sql .= $part;
		}
		
		// If the values were passed as a single array, this handles that
		$placeholders = preg_match_all('#%[lbdfristp]\b#', $temp_sql, $trash);
		if (count($values) == 0 && is_array($value) && count($value) == $placeholders) {
			$values = $value;
			$value  = array_shift($values);	
		}
		
		array_unshift($values, $value);
		
		$sql = $this->escapeSQL($temp_sql, $values);
		
		$string_number = 0;
		foreach ($strings as $string) {
			$string = strtr($string, array('\\' => '\\\\', '$' => '\\$'));
			$sql    = preg_replace('#:string_' . $string_number++ . '\b#', $string, $sql);	
		}
		
		return $sql;
	}
	
	
	/**
	 * Escapes a blob for use in SQL, includes surround quotes when appropriate
	 * 
	 * A `NULL` value will be returned as `'NULL'`
	 * 
	 * @param  string $value  The blob to escape
	 * @return string  The escaped blob
	 */
	private function escapeBlob($value)
	{
		if ($value === NULL) {
			return 'NULL';
		}
		
		$this->connectToDatabase();
		
		if ($this->type == 'db2') {
			return "BLOB(X'" . bin2hex($value) . "')";
			
		} elseif ($this->type == 'mysql') {
			return "x'" . bin2hex($value) . "'";
			
		} elseif ($this->type == 'postgresql') {
			$output = '';
			for ($i=0; $i<strlen($value); $i++) {
				$output .= '\\\\' . str_pad(decoct(ord($value[$i])), 3, '0', STR_PAD_LEFT);
			}
			return "E'" . $output . "'";
			
		} elseif ($this->extension == 'sqlite') {
			return "'" . bin2hex($value) . "'";
			
		} elseif ($this->type == 'sqlite') {
			return "X'" . bin2hex($value) . "'";
			
		} elseif ($this->type == 'mssql') {
			return '0x' . bin2hex($value);
			
		} elseif ($this->type == 'oracle') {
			return "'" . bin2hex($value) . "'";
		}
	}
	
	
	/**
	 * Escapes a boolean for use in SQL, includes surround quotes when appropriate
	 * 
	 * A `NULL` value will be returned as `'NULL'`
	 * 
	 * @param  boolean $value  The boolean to escape
	 * @return string  The database equivalent of the boolean passed
	 */
	private function escapeBoolean($value)
	{
		if ($value === NULL) {
			return 'NULL';
		}
		
		if (in_array($this->type, array('postgresql', 'mysql'))) {
			return ($value) ? 'TRUE' : 'FALSE';
		} elseif (in_array($this->type, array('mssql', 'sqlite', 'db2'))) {
			return ($value) ? "'1'" : "'0'";
		} elseif ($this->type == 'oracle') {
			return ($value) ? '1' : '0';	
		}
	}
	
	
	/**
	 * Escapes a date for use in SQL, includes surrounding quotes
	 * 
	 * A `NULL` or invalid value will be returned as `'NULL'`
	 * 
	 * @param  string $value  The date to escape
	 * @return string  The escaped date
	 */
	private function escapeDate($value)
	{
		if ($value === NULL) {
			return 'NULL';
		}
		
		try {
			$value = new fDate($value);
			return "'" . $value->format('Y-m-d') . "'";
			
		} catch (fValidationException $e) {
			return 'NULL';
		}
	}
	
	
	/**
	 * Escapes a float for use in SQL
	 * 
	 * A `NULL` value will be returned as `'NULL'`
	 * 
	 * @param  float $value  The float to escape
	 * @return string  The escaped float
	 */
	private function escapeFloat($value)
	{
		if ($value === NULL) {
			return 'NULL';
		}
		if (!strlen($value)) {
			return 'NULL';
		}
		if (!preg_match('#^[+\-]?([0-9]+(\.([0-9]+)?)?|(\.[0-9]+))$#D', $value)) {
			return 'NULL';
		}
		
		$value = rtrim($value, '.');
		$value = preg_replace('#(?<![0-9])\.#', '0.', $value);
		
		return (string) $value;
	}
	
	
	/**
	 * Escapes an identifier for use in SQL, necessary for reserved words
	 * 
	 * @param  string $value  The identifier to escape
	 * @return string  The escaped identifier
	 */
	private function escapeIdentifier($value)
	{
		$value = '"' . str_replace(
			array('"', '.'),
			array('',  '"."'),
			$value
		) . '"';
		if (in_array($this->type, array('oracle', 'db2'))) {
			$value = strtoupper($value);	
		}
		return $value;
	}
	
	
	/**
	 * Escapes an integer for use in SQL
	 * 
	 * A `NULL` or invalid value will be returned as `'NULL'`
	 * 
	 * @param  integer $value  The integer to escape
	 * @return string  The escaped integer
	 */
	private function escapeInteger($value)
	{
		if ($value === NULL) {
			return 'NULL';
		}
		if (!strlen($value)) {
			return 'NULL';
		}
		if (!preg_match('#^([+\-]?[0-9]+)(\.[0-9]*)?$#D', $value, $matches)) {
			return 'NULL';
		}
		return str_replace('+', '', $matches[1]);
	}
	
	
	/**
	 * Escapes a string for use in SQL, includes surrounding quotes
	 * 
	 * A `NULL` value will be returned as `'NULL'`.
	 * 
	 * @param  string $value  The string to escape
	 * @return string  The escaped string
	 */
	private function escapeString($value)
	{
		if ($value === NULL) {
			return 'NULL';
		}
		
		$this->connectToDatabase();
		
		if ($this->type == 'db2') {
			return "'" . str_replace("'", "''", $value) . "'";
		} elseif ($this->extension == 'mysql') {
			return "'" . mysql_real_escape_string($value, $this->connection) . "'";
		} elseif ($this->extension == 'mysqli') {
			return "'" . mysqli_real_escape_string($this->connection, $value) . "'";
		} elseif ($this->extension == 'pgsql') {
			return "'" . pg_escape_string($value) . "'";
		} elseif ($this->extension == 'sqlite') {
			return "'" . sqlite_escape_string($value) . "'";
		} elseif ($this->type == 'oracle') {
			return "'" . str_replace("'", "''", $value) . "'";
			
		} elseif ($this->type == 'mssql') {
			
			// If there are any non-ASCII characters, we need to escape
			if (preg_match('#[^\x00-\x7F]#', $value)) {
				preg_match_all('#.|^\z#us', $value, $characters);
				$output    = "";
				$last_type = NULL;
				foreach ($characters[0] as $character) {
					if (strlen($character) > 1) {
						$b = array_map('ord', str_split($character));
						switch (strlen($character)) {
							case 2:
								$bin = substr(decbin($b[0]), 3) .
										   substr(decbin($b[1]), 2);
								break;
							
							case 3:
								$bin = substr(decbin($b[0]), 4) .
										   substr(decbin($b[1]), 2) .
										   substr(decbin($b[2]), 2);
								break;
							
							// If it is a 4-byte character, MSSQL can't store it
							// so instead store a ?
							default:
								$output .= '?';
								continue;
						}
						if ($last_type == 'nchar') {
							$output .= '+';
						} elseif ($last_type == 'char') {
							$output .= "'+";
						}		
						$output .= "NCHAR(" . bindec($bin) . ")";
						$last_type = 'nchar';
					} else {
						if (!$last_type) {
							$output .= "'";
						} elseif ($last_type == 'nchar') {
							$output .= "+'";	
						}
						$output .= $character;
						// Escape single quotes
						if ($character == "'") {
							$output .= "'";
						}
						$last_type = 'char';
					}
				}
				if ($last_type == 'char') {
					$output .= "'";
				} elseif (!$last_type) {
					$output .= "''";	
				}
			
			// ASCII text is normal
			} else {
				$output = "'" . str_replace("'", "''", $value) . "'";
			}
			
			# a \ before a \r\n has to be escaped with another \
			return preg_replace('#(?<!\\\\)\\\\(?=\r\n)#', '\\\\\\\\', $output);
		
		} elseif ($this->extension == 'pdo') {
			return $this->connection->quote($value);
		}
	}
	
	
	/**
	 * Takes a SQL string and an array of values and replaces the placeholders with the value
	 * 
	 * @param string $sql     The SQL string containing placeholders
	 * @param array  $values  An array of values to escape into the SQL
	 * @return string  The SQL with the values escaped into it
	 */
	private function escapeSQL($sql, $values)
	{
		$original_sql = $sql;
		$pieces = preg_split('#(%[lbdfristp])\b#', $sql, -1, PREG_SPLIT_DELIM_CAPTURE|PREG_SPLIT_NO_EMPTY);
		
		$sql   = '';
		$value = array_shift($values);
		
		$missing_values = -1;
		
		foreach ($pieces as $piece) {
			switch ($piece) {
				case '%l':
					$callback = $this->escapeBlob;
					break;
				case '%b':
					$callback = $this->escapeBoolean;
					break;
				case '%d':
					$callback = $this->escapeDate;
					break;
				case '%f':
					$callback = $this->escapeFloat;
					break;
				case '%r':
					$callback = $this->escapeIdentifier;
					break;
				case '%i':
					$callback = $this->escapeInteger;
					break;
				case '%s':
					$callback = $this->escapeString;
					break;
				case '%t':
					$callback = $this->escapeTime;
					break;
				case '%p':
					$callback = $this->escapeTimestamp;
					break;
				default:
					$sql .= $piece;
					continue 2;	
			}
			
			if (is_array($value)) {
				$sql .= join(', ', array_map($callback, $value));		
			} else {
				$sql .= call_user_func($callback, $value);
			}
					
			if (sizeof($values)) {
				$value = array_shift($values);
			} else {
				$value = NULL;
				$missing_values++;	
			}
		}
		
		if ($missing_values > 0) {
			throw new fProgrammerException(
				'%1$s value(s) are missing for the placeholders in: %2$s',
				$missing_values,
				$original_sql
			);	
		}
		
		if (sizeof($values)) {
			throw new fProgrammerException(
				'%1$s extra value(s) were passed for the placeholders in: %2$s',
				sizeof($values),
				$original_sql
			); 	
		}	
		
		return $sql;
	}
	
	
	/**
	 * Escapes a time for use in SQL, includes surrounding quotes
	 * 
	 * A `NULL` or invalid value will be returned as `'NULL'`
	 * 
	 * @param  string $value  The time to escape
	 * @return string  The escaped time
	 */
	private function escapeTime($value)
	{
		if ($value === NULL) {
			return 'NULL';
		}
		
		try {
			$value = new fTime($value);
			
			if ($this->type == 'mssql' || $this->type == 'oracle') {
				return "'" . $value->format('1970-01-01 H:i:s') . "'";	
			}
			
			return "'" . $value->format('H:i:s') . "'";
			
		} catch (fValidationException $e) {
			return 'NULL';
		}
	}
	
	
	/**
	 * Escapes a timestamp for use in SQL, includes surrounding quotes
	 * 
	 * A `NULL` or invalid value will be returned as `'NULL'`
	 * 
	 * @param  string $value  The timestamp to escape
	 * @return string  The escaped timestamp
	 */
	private function escapeTimestamp($value)
	{
		if ($value === NULL) {
			return 'NULL';
		}
		
		try {
			$value = new fTimestamp($value);
			return "'" . $value->format('Y-m-d H:i:s') . "'";
			
		} catch (fValidationException $e) {
			return 'NULL';
		}
	}
	
	
	/**
	 * Executes one or more SQL queries without returning any results
	 * 
	 * @param  string|fStatement $statement  One or more SQL statements in a string or an fStatement prepared statement
	 * @param  mixed             $value      The optional value(s) to place into any placeholders in the SQL - see ::escape() for details
	 * @param  mixed             ...
	 * @return void
	 */
	public function execute($statement)
	{
		$args    = func_get_args();
		$params  = array_slice($args, 1);
		
		if (is_object($statement)) {
			return $this->run($statement, NULL, $params);	
		}
		
		$queries = $this->prepareSQL($statement, $params, FALSE);
		
		$output = array();
		foreach ($queries as $query) {
			$this->run($query);	
		}
	}
	
	
	/**
	 * Takes in a string of SQL that contains multiple queries and returns any array of them
	 * 
	 * @param  string $sql  The string of SQL to parse for queries
	 * @return array  The individual SQL queries
	 */
	private function explodeQueries($sql)
	{
		$sql_queries = array();
		
		// Separate the SQL from quoted values
		preg_match_all("#(?:'([^']*(?:'')*)*?')|(?:[^']+)#", $sql, $matches);
		
		$cur_sql = '';
		foreach ($matches[0] as $match) {
			
			// This is a quoted string value, don't do anything to it
			if ($match[0] == "'") {
				$cur_sql .= $match;
			
			// Handle the SQL, exploding on any ; that isn't escaped with a \
			} else {
				$sql_strings = preg_split('#(?<!\\\\);#', $match);
				$cur_sql .= $sql_strings[0];
				for ($i=1; $i < sizeof($sql_strings); $i++) {
					$cur_sql = trim($cur_sql);
					if ($cur_sql) {
						$sql_queries[] = $cur_sql;
					}
					$cur_sql = $sql_strings[$i];
				}
			}
		}
		if (trim($cur_sql)) {
			$sql_queries[] = $cur_sql;
		}
		
		return $sql_queries;
	}
	
	
	/**
	 * Returns the database connection resource or object
	 * 
	 * @return mixed  The database connection
	 */
	public function getConnection()
	{
		$this->connectToDatabase();
		return $this->connection;
	}
	
	
	/**
	 * Gets the name of the database currently connected to
	 * 
	 * @return string  The name of the database currently connected to
	 */
	public function getDatabase()
	{
		return $this->database;
	}
	
	
	/**
	 * Gets the php extension being used
	 * 
	 * @internal
	 * 
	 * @return string  The php extension used for database interaction
	 */
	public function getExtension()
	{
		return $this->extension;
	}
	
	
	/**
	 * Gets the host for this database
	 * 
	 * @return string  The host
	 */
	public function getHost()
	{
		return $this->host;
	}
	
	
	/**
	 * Gets the port for this database
	 * 
	 * @return string  The port
	 */
	public function getPort()
	{
		return $this->port;
	}
	
	
	/**
	 * Gets the fSQLTranslation object used for translated queries
	 * 
	 * @return fSQLTranslation  The SQL translation object
	 */
	public function getSQLTranslation()
	{
		if (!$this->translation) { new fSQLTranslation($this); }
		return $this->translation;	
	}
	
	
	/**
	 * Gets the database type
	 * 
	 * @return string  The database type: `'mssql'`, `'mysql'`, `'postgresql'` or `'sqlite'`
	 */
	public function getType()
	{
		return $this->type;
	}
	
	
	/**
	 * Gets the username for this database
	 * 
	 * @return string  The username
	 */
	public function getUsername()
	{
		return $this->username;
	}
	
	
	/**
	 * Will grab the auto incremented value from the last query (if one exists)
	 * 
	 * @param  fResult $result    The result object for the query
	 * @param  mixed   $resource  Only applicable for `pdo`, `oci8` and `sqlsrv` extentions or `mysqli` prepared statements - this is either the `PDOStatement` object, `mysqli_stmt` object or the `oci8` or `sqlsrv` resource
	 * @return void
	 */
	private function handleAutoIncrementedValue($result, $resource=NULL)
	{
		if (!preg_match('#^\s*INSERT\s+(?:INTO\s+)?(?:`|"|\[)?(["\w.]+)(?:`|"|\])?#i', $result->getSQL(), $table_match)) {
			$result->setAutoIncrementedValue(NULL);
			return;
		}
		$quoted_table = $table_match[1];
		$table        = str_replace('"', '', strtolower($table_match[1]));
		
		$insert_id = NULL;
		
		if ($this->type == 'oracle') {
			if (!isset($this->schema_info['sequences'])) {
				$sql = "SELECT
								LOWER(OWNER) AS \"SCHEMA\",
								LOWER(TABLE_NAME) AS \"TABLE\",
								TRIGGER_BODY
							FROM
								ALL_TRIGGERS
							WHERE
								TRIGGERING_EVENT LIKE 'INSERT%' AND
								STATUS = 'ENABLED' AND
								TRIGGER_NAME NOT LIKE 'BIN\$%' AND
								OWNER NOT IN (
									'SYS',
									'SYSTEM',
									'OUTLN',
									'ANONYMOUS',
									'AURORA\$ORB\$UNAUTHENTICATED',
									'AWR_STAGE',
									'CSMIG',
									'CTXSYS',
									'DBSNMP',
									'DIP',
									'DMSYS',
									'DSSYS',
									'EXFSYS',
									'FLOWS_020100',
									'FLOWS_FILES',
									'LBACSYS',
									'MDSYS',
									'ORACLE_OCM',
									'ORDPLUGINS',
									'ORDSYS',
									'PERFSTAT',
									'TRACESVR',
									'TSMSYS',
									'XDB'
								)";
								
				$this->schema_info['sequences'] = array();
				
				foreach ($this->query($sql) as $row) {
					if (preg_match('#SELECT\s+(["\w.]+).nextval\s+INTO\s+:new\.(\w+)\s+FROM\s+dual#i', $row['trigger_body'], $matches)) {
						$table_name = $row['table'];
						if ($row['schema'] != strtolower($this->username)) {
							$table_name = $row['schema'] . '.' . $table_name;	
						}
						$this->schema_info['sequences'][$table_name] = array('sequence' => $matches[1], 'column' => str_replace('"', '', $matches[2]));
					}
				}
				
				if ($this->cache) {
					$this->cache->set($this->makeCachePrefix() . 'schema_info', $this->schema_info);	
				}
			}
			
			if (!isset($this->schema_info['sequences'][$table]) || preg_match('#INSERT\s+INTO\s+"?' . preg_quote($quoted_table, '#') . '"?\s+\([^\)]*?(\b|")' . preg_quote($this->schema_info['sequences'][$table]['column'], '#') . '(\b|")#i', $result->getSQL())) {
				return;	
			}
			
			$insert_id_sql = "SELECT " . $this->schema_info['sequences'][$table]['sequence'] . ".currval AS INSERT_ID FROM dual";
		}
		
		if ($this->type == 'postgresql') {
			if (!isset($this->schema_info['sequences'])) {
				$sql = "SELECT
								pg_namespace.nspname AS \"schema\",
								pg_class.relname AS \"table\",
								pg_attribute.attname AS column
							FROM
								pg_attribute INNER JOIN
								pg_class ON pg_attribute.attrelid = pg_class.oid INNER JOIN
								pg_namespace ON pg_class.relnamespace = pg_namespace.oid INNER JOIN
								pg_attrdef ON pg_class.oid = pg_attrdef.adrelid AND pg_attribute.attnum = pg_attrdef.adnum
							WHERE
								NOT pg_attribute.attisdropped AND
								pg_attrdef.adsrc LIKE 'nextval(%'";
								
				$this->schema_info['sequences'] = array();
				
				foreach ($this->query($sql) as $row) {
					$table_name = strtolower($row['table']);
					if ($row['schema'] != 'public') {
						$table_name = $row['schema'] . '.' . $table_name;	
					}
					$this->schema_info['sequences'][$table_name] = $row['column'];
				}
				
				if ($this->cache) {
					$this->cache->set($this->makeCachePrefix() . 'schema_info', $this->schema_info);	
				}	
			}
			
			if (!isset($this->schema_info['sequences'][$table]) || preg_match('#INSERT\s+INTO\s+"?' . preg_quote($quoted_table, '#') . '"?\s+\([^\)]*?(\b|")' . preg_quote($this->schema_info['sequences'][$table], '#') . '(\b|")#i', $result->getSQL())) {
				return;
			} 		
		}
		
		if ($this->extension == 'ibm_db2') {
			$insert_id_res  = db2_exec($this->connection, "SELECT IDENTITY_VAL_LOCAL() FROM SYSIBM.SYSDUMMY1");
			$insert_id_row  = db2_fetch_assoc($insert_id_res);
			$insert_id      = current($insert_id_row);
			db2_free_result($insert_id_res);
		
		} elseif ($this->extension == 'mssql') {
			$insert_id_res = mssql_query("SELECT @@IDENTITY AS insert_id", $this->connection);
			$insert_id     = mssql_result($insert_id_res, 0, 'insert_id');
			mssql_free_result($insert_id_res);
		
		} elseif ($this->extension == 'mysql') {
			$insert_id     = mysql_insert_id($this->connection);
		
		} elseif ($this->extension == 'mysqli') {
			if (is_object($resource)) {
				$insert_id = mysqli_stmt_insert_id($resource);
			} else {
				$insert_id = mysqli_insert_id($this->connection);
			}
		
		} elseif ($this->extension == 'oci8') {
			$oci_statement = oci_parse($this->connection, $insert_id_sql);
			oci_execute($oci_statement, $this->inside_transaction ? OCI_DEFAULT : OCI_COMMIT_ON_SUCCESS);
			$insert_id_row = oci_fetch_array($oci_statement, OCI_ASSOC);
			$insert_id = $insert_id_row['INSERT_ID'];
			oci_free_statement($oci_statement);
		
		} elseif ($this->extension == 'pgsql') {
			
			$insert_id_res = pg_query($this->connection, "SELECT lastval()");
			$insert_id_row = pg_fetch_assoc($insert_id_res);
			$insert_id = array_shift($insert_id_row);
			pg_free_result($insert_id_res);
		
		} elseif ($this->extension == 'sqlite') {
			$insert_id = sqlite_last_insert_rowid($this->connection);
		
		} elseif ($this->extension == 'sqlsrv') {
			$insert_id_res = sqlsrv_query($this->connection, "SELECT @@IDENTITY AS insert_id");
			$insert_id_row = sqlsrv_fetch_array($insert_id_res, SQLSRV_FETCH_ASSOC);
			$insert_id     = $insert_id_row['insert_id'];
			sqlsrv_free_stmt($insert_id_res);
		
		} elseif ($this->extension == 'pdo') {
			
			switch ($this->type) {
				case 'db2':
					$insert_id_statement = $this->connection->query("SELECT IDENTITY_VAL_LOCAL() FROM SYSIBM.SYSDUMMY1");
					$insert_id_row = $insert_id_statement->fetch(PDO::FETCH_ASSOC);
					$insert_id = array_shift($insert_id_row);
					$insert_id_statement->closeCursor();
					unset($insert_id_statement);
					break;
				
				case 'mssql':
					try {
						$insert_id_statement = $this->connection->query("SELECT @@IDENTITY AS insert_id");
						if (!$insert_id_statement) {
							throw new Exception();
						}
						
						$insert_id_row = $insert_id_statement->fetch(PDO::FETCH_ASSOC);
						$insert_id = array_shift($insert_id_row);
						
					} catch (Exception $e) {
						// If there was an error we don't have an insert id
					}
					break;
					
				case 'oracle':
					try {
						$insert_id_statement = $this->connection->query($insert_id_sql);
						if (!$insert_id_statement) {
							throw new Exception();
						}
						
						$insert_id_row = $insert_id_statement->fetch(PDO::FETCH_ASSOC);
						$insert_id = array_shift($insert_id_row);
						
					} catch (Exception $e) {
						// If there was an error we don't have an insert id
					}
					break;
				
				case 'postgresql':
					
					$insert_id_statement = $this->connection->query("SELECT lastval()");
					$insert_id_row = $insert_id_statement->fetch(PDO::FETCH_ASSOC);
					$insert_id = array_shift($insert_id_row);
					$insert_id_statement->closeCursor();
					unset($insert_id_statement);
					
					break;
		
				case 'mysql':
					$insert_id = $this->connection->lastInsertId();
					break;
		
				case 'sqlite':
					$insert_id = $this->connection->lastInsertId();
					break;
			}
		}
		
		$result->setAutoIncrementedValue($insert_id);
	}
	
	
	/**
	 * Handles a PHP error to extract error information for the mssql extension
	 * 
	 * @param  array $errors  An array of error information from fCore::stopErrorCapture()
	 * @return void
	 */
	private function handleErrors($errors)
	{
		if ($this->extension != 'mssql') {
			return;	
		}
		
		foreach ($errors as $error) {
			if (substr($error['string'], 0, 14) == 'mssql_query():') {
				if ($this->error) {
					$this->error .= " ";	
				}
				$this->error .= preg_replace('#^mssql_query\(\): ([^:]+: )?#', '', $error['string']);	
			}
		}
	}
	
	
	/**
	 * Makes sure each database and extension handles BEGIN, COMMIT and ROLLBACK 
	 * 
	 * @param  string &$sql          The SQL to check for a transaction query
	 * @param  string $result_class  The type of result object to create
	 * @return mixed  `FALSE` if normal processing should continue, otherwise an object of the type $result_class
	 */
	private function handleTransactionQueries(&$sql, $result_class)
	{
		// SQL Server supports transactions, but starts then with BEGIN TRANSACTION
		if ($this->type == 'mssql' && preg_match('#^\s*(begin|start(\s+transaction)?)\s*#i', $sql)) {
			$sql = 'BEGIN TRANSACTION';
		}
		
		$begin    = FALSE;
		$commit   = FALSE;
		$rollback = FALSE;
		
		// Track transactions since most databases don't support nesting
		if (preg_match('#^\s*(begin|start)(\s+(transaction|work))?\s*$#iD', $sql)) {
			if ($this->inside_transaction) {
				throw new fProgrammerException('A transaction is already in progress');
			}
			$this->inside_transaction = TRUE;
			$begin = TRUE;
			
		} elseif (preg_match('#^\s*(commit)(\s+(transaction|work))?\s*$#iD', $sql)) {
			if (!$this->inside_transaction) {
				throw new fProgrammerException('There is no transaction in progress');
			}
			$this->inside_transaction = FALSE;
			$commit = TRUE;
			
		} elseif (preg_match('#^\s*(rollback)(\s+(transaction|work))?\s*$#iD', $sql)) {
			if (!$this->inside_transaction) {
				throw new fProgrammerException('There is no transaction in progress');
			}
			$this->inside_transaction = FALSE;
			$rollback = TRUE;
		}
		
		if (!$begin && !$commit && !$rollback) {
			return FALSE;	
		}
		
		// The PDO, OCI8 and SQLSRV extensions require special handling through methods and functions
		$is_pdo     = $this->extension == 'pdo';
		$is_oci     = $this->extension == 'oci8';
		$is_sqlsrv  = $this->extension == 'sqlsrv';
		$is_ibm_db2 = $this->extension == 'ibm_db2';
		
		if (!$is_pdo && !$is_oci && !$is_sqlsrv && !$is_ibm_db2) {
			return FALSE;
		}
		
		$this->statement = $sql;
		
		// PDO seems to act weird if you try to start transactions through a normal query call
		if ($is_pdo) {
			try {
				$is_mssql  = $this->type == 'mssql'  && substr($this->database, 0, 4) != 'dsn:';
				$is_oracle = $this->type == 'oracle' && substr($this->database, 0, 4) != 'dsn:';
				if ($begin) {
					// The SQL Server PDO object hasn't implemented transactions
					if ($is_mssql) {
						$this->connection->exec('BEGIN TRANSACTION');
					} elseif ($is_oracle) {
						$this->connection->setAttribute(PDO::ATTR_AUTOCOMMIT, FALSE);
					} else {
						$this->connection->beginTransaction();
					}
				
				} elseif ($commit) {
					if ($is_mssql) {
						$this->connection->exec('COMMIT');
					} elseif ($is_oracle) {
						$this->connection->exec('COMMIT');
						$this->connection->setAttribute(PDO::ATTR_AUTOCOMMIT, TRUE);
					} else  {
						$this->connection->commit();
					}
				
				} elseif ($rollback) {
					if ($is_mssql) {
						$this->connection->exec('ROLLBACK');
					} elseif ($is_oracle) {                 
						$this->connection->exec('ROLLBACK');
						$this->connection->setAttribute(PDO::ATTR_AUTOCOMMIT, TRUE);
					} else {
						$this->connection->rollBack();
					}
				}
				
			} catch (Exception $e) {
				
				$db_type_map = array(
					'db2'        => 'DB2',
					'mssql'      => 'MSSQL',
					'mysql'      => 'MySQL',
					'oracle'     => 'Oracle',
					'postgresql' => 'PostgreSQL',
					'sqlite'     => 'SQLite'
				);
				
				throw new fSQLException(
					'%1$s error (%2$s) in %3$s',
					$db_type_map[$this->type],
					$e->getMessage(),
					$sql
				);
			}
		
		} elseif ($is_oci) {
			if ($commit) {
				oci_commit($this->connection);
			} elseif ($rollback) {
				oci_rollback($this->connection);
			}
		
		} elseif ($is_sqlsrv) {
			if ($begin) {
				sqlsrv_begin_transaction($this->connection);
			} elseif ($commit) {
				sqlsrv_commit($this->connection);
			} elseif ($rollback) {
				sqlsrv_rollback($this->connection);
			}
			
		} elseif ($is_ibm_db2) {
			if ($begin) {
				db2_autocommit($this->connection, FALSE);
			} elseif ($commit) {
				db2_commit($this->connection);
				db2_autocommit($this->connection, TRUE);
			} elseif ($rollback) {
				db2_rollback($this->connection);
				db2_autocommit($this->connection, TRUE);
			}
		}
		
		if ($result_class) {
			$result = new $result_class($this);
			$result->setSQL($sql);
			$result->setResult(TRUE);
			return $result;
		}
		
		return TRUE;
	}
	
	
	/**
	 * Injects an fSQLTranslation object to handle translation
	 * 
	 * @internal
	 * 
	 * @param  fSQLTranslation $sql_translation  The SQL translation object
	 * @return void
	 */
	public function inject($sql_translation)
	{
		$this->translation = $sql_translation;
	}
	
	
	/**
	 * Will indicate if a transaction is currently in progress
	 * 
	 * @return boolean  If a transaction has been started and not yet rolled back or committed
	 */
	public function isInsideTransaction()
	{
		return $this->inside_transaction;
	}
	
	
	/**
	 * Creates a unique cache prefix to help prevent cache conflicts
	 * 
	 * @return string  The cache prefix to use
	 */
	private function makeCachePrefix()
	{
		if (!$this->cache_prefix) {
			$prefix  = 'fDatabase::' . $this->type . '::';
			if ($this->host) {
				$prefix .= $this->host . '::';
			}
			if ($this->port) {
				$prefix .= $this->port . '::';
			}
			$prefix .= $this->database . '::';
			if ($this->username) {
				$prefix .= $this->username . '::';
			}
			$this->cache_prefix = $prefix;
		}
		
		return $this->cache_prefix;
	}
	
	
	/**
	 * Executes a SQL statement
	 * 
	 * @param  string|fStatement $statement  The statement to perform
	 * @param  array             $params     The parameters for prepared statements
	 * @return void
	 */
	private function perform($statement, $params)
	{
		fCore::startErrorCapture();
		
		$extra = NULL;
		if (is_object($statement)) {
			$result = $statement->execute($params, $extra, $statement != $this->statement);
		} elseif ($this->extension == 'ibm_db2') {
			$result = db2_exec($this->connection, $statement, array('cursor' => DB2_FORWARD_ONLY));
		} elseif ($this->extension == 'mssql') {
			$result = mssql_query($statement, $this->connection);
		} elseif ($this->extension == 'mysql') {
			$result = mysql_unbuffered_query($statement, $this->connection);
		} elseif ($this->extension == 'mysqli') { 
			$result = mysqli_query($this->connection, $statement, MYSQLI_USE_RESULT);
		} elseif ($this->extension == 'oci8') {
			$extra  = oci_parse($this->connection, $statement);
			$result = oci_execute($extra, $this->inside_transaction ? OCI_DEFAULT : OCI_COMMIT_ON_SUCCESS);
		} elseif ($this->extension == 'pgsql') {
			$result = pg_query($this->connection, $statement);
		} elseif ($this->extension == 'sqlite') {
			$result = sqlite_exec($this->connection, $statement, $extra);
		} elseif ($this->extension == 'sqlsrv') {
			$result = sqlsrv_query($this->connection, $statement);
		} elseif ($this->extension == 'pdo') {
			if ($this->type == 'mssql' && !fCore::checkOS('windows')) {
				$result = $this->connection->query($statement);
				if ($result instanceof PDOStatement) {
					$result->closeCursor();	
				}
			} else {
				$result = $this->connection->exec($statement);
			}
		}
		$this->statement = $statement;
		
		$this->handleErrors(fCore::stopErrorCapture());
		
		if ($result === FALSE) {
			$this->checkForError($result, $extra, is_object($statement) ? $statement->getSQL() : $statement);
			
		} elseif (!is_bool($result) && $result !== NULL) {
			if ($this->extension == 'ibm_db2') {
				db2_free_result($result);
			} elseif ($this->extension == 'mssql') {
				mssql_free_result($result);
			} elseif ($this->extension == 'mysql') {
				mysql_free_result($result);
			} elseif ($this->extension == 'mysqli') { 
				mysqli_free_result($result);
			} elseif ($this->extension == 'oci8') {
				oci_free_statement($oci_statement);
			} elseif ($this->extension == 'pgsql') {
				pg_free_result($result);
			} elseif ($this->extension == 'sqlsrv') {
				sqlsrv_free_stmt($result);
			}
		}
	}
	
	
	/**
	 * Executes an SQL query
	 * 
	 * @param  string|fStatement $statement  The statement to perform
	 * @param  fResult           $result     The result object for the query
	 * @param  array             $params     The parameters for prepared statements
	 * @return void
	 */
	private function performQuery($statement, $result, $params)
	{
		fCore::startErrorCapture();
		
		$extra = NULL;
		if (is_object($statement)) {
			$statement->executeQuery($result, $params, $extra, $statement != $this->statement);
			
		} elseif ($this->extension == 'ibm_db2') {
			$extra = db2_exec($this->connection, $statement, array('cursor' => DB2_FORWARD_ONLY));
			if (is_resource($extra)) {
				$rows = array();
				while ($row = db2_fetch_assoc($extra)) {
					$rows[] = $row;	
				}
				$result->setResult($rows);
				unset($rows);
			} else { 
				$result->setResult($extra);	
			}
			
		} elseif ($this->extension == 'mssql') {
			$result->setResult(mssql_query($result->getSQL(), $this->connection));
			
		} elseif ($this->extension == 'mysql') {
			$result->setResult(mysql_query($result->getSQL(), $this->connection));

		} elseif ($this->extension == 'mysqli') {
			$result->setResult(mysqli_query($this->connection, $result->getSQL()));
			
		} elseif ($this->extension == 'oci8') {
			$extra = oci_parse($this->connection, $result->getSQL());
			if (oci_execute($extra, $this->inside_transaction ? OCI_DEFAULT : OCI_COMMIT_ON_SUCCESS)) {
				oci_fetch_all($extra, $rows, 0, -1, OCI_FETCHSTATEMENT_BY_ROW + OCI_ASSOC);
				$result->setResult($rows);
				unset($rows);	
			} else {
				$result->setResult(FALSE);
			}
			
		} elseif ($this->extension == 'pgsql') {
			$result->setResult(pg_query($this->connection, $result->getSQL()));
			
		} elseif ($this->extension == 'sqlite') {
			$result->setResult(sqlite_query($this->connection, $result->getSQL(), SQLITE_ASSOC, $extra));
			
		} elseif ($this->extension == 'sqlsrv') {
			$extra = sqlsrv_query($this->connection, $result->getSQL());
			if (is_resource($extra)) {
				$rows = array();
				while ($row = sqlsrv_fetch_array($extra, SQLSRV_FETCH_ASSOC)) {
					$rows[] = $row;
				}
				$result->setResult($rows);
				unset($rows);
			} else {
				$result->setResult($extra);
			}
			
		} elseif ($this->extension == 'pdo') {
			if (preg_match('#^\s*CREATE(\s+OR\s+REPLACE)?\s+TRIGGER#i', $result->getSQL())) {
				$this->connection->exec($result->getSQL());
				$extra = FALSE;
				$returned_rows = array();
			} else {
				$extra = $this->connection->query($result->getSQL());
				if (is_object($extra)) {
					// This fixes a segfault issue with blobs and fetchAll() for pdo_ibm
					if ($this->type == 'db2') {
						$returned_rows = array();
						$scanned_for_blobs = FALSE;
						$blob_columns = array();
						while (($row = $extra->fetch(PDO::FETCH_ASSOC)) !== FALSE) {
							if (!$scanned_for_blobs) {
								foreach ($row as $key => $value) {
									if (is_resource($value)) {
										$blob_columns[] = $key;
									}
								}
							}
							foreach ($blob_columns as $blob_column) {
								$row[$blob_column] = stream_get_contents($row[$blob_column]);
							}
							$returned_rows[] = $row;
						}
					} else {
						$returned_rows = $extra->fetchAll(PDO::FETCH_ASSOC);
					}	
				} else {
					$returned_rows = $extra;
				}
				
				// The pdo_pgsql driver likes to return empty rows equal to the number of affected rows for insert and deletes
				if ($this->type == 'postgresql' && $returned_rows && $returned_rows[0] == array()) {
					$returned_rows = array(); 		
				}
			}
			
			$result->setResult($returned_rows);
		}
		$this->statement = $statement;
		
		$this->handleErrors(fCore::stopErrorCapture());
		
		$this->checkForError($result, $extra);
		
		if ($this->extension == 'ibm_db2') {
			$this->setAffectedRows($result, $extra);
			if ($extra && !is_object($statement)) {
				db2_free_result($extra);
			}
			
		} elseif ($this->extension == 'pdo') {
			$this->setAffectedRows($result, $extra);
			if ($extra && !is_object($statement)) {
				$extra->closeCursor();
			}
			
		} elseif ($this->extension == 'oci8') {
			$this->setAffectedRows($result, $extra);
			if ($extra && !is_object($statement)) {
				oci_free_statement($extra);
			}
			
		} elseif ($this->extension == 'sqlsrv') {
			$this->setAffectedRows($result, $extra);
			if ($extra && !is_object($statement)) {
				sqlsrv_free_stmt($extra);
			}
			
		} else {
			$this->setAffectedRows($result, $extra);
		}
		
		$this->setReturnedRows($result);
		
		$this->handleAutoIncrementedValue($result, $extra);
	}
	
	
	/**
	 * Executes an unbuffered SQL query
	 * 
	 * @param  string|fStatement $statement  The statement to perform
	 * @param  fUnbufferedResult $result     The result object for the query
	 * @param  array             $params     The parameters for prepared statements
	 * @return void
	 */
	private function performUnbufferedQuery($statement, $result, $params)
	{
		fCore::startErrorCapture();
		
		$extra = NULL;
		if (is_object($statement)) {
			$statement->executeUnbufferedQuery($result, $params, $extra, $statement != $this->statement);
		} elseif ($this->extension == 'ibm_db2') {
			$result->setResult(db2_exec($this->connection, $statement, array('cursor' => DB2_FORWARD_ONLY)));
		} elseif ($this->extension == 'mssql') {
			$result->setResult(mssql_query($result->getSQL(), $this->connection, 20));
		} elseif ($this->extension == 'mysql') {
			$result->setResult(mysql_unbuffered_query($result->getSQL(), $this->connection));
		} elseif ($this->extension == 'mysqli') { 
			$result->setResult(mysqli_query($this->connection, $result->getSQL(), MYSQLI_USE_RESULT));
		} elseif ($this->extension == 'oci8') {
			$extra = oci_parse($this->connection, $result->getSQL());
			if (oci_execute($extra, $this->inside_transaction ? OCI_DEFAULT : OCI_COMMIT_ON_SUCCESS)) {
				$result->setResult($extra);
			} else {
				$result->setResult(FALSE);	
			}
		} elseif ($this->extension == 'pgsql') {
			$result->setResult(pg_query($this->connection, $result->getSQL()));
		} elseif ($this->extension == 'sqlite') {
			$result->setResult(sqlite_unbuffered_query($this->connection, $result->getSQL(), SQLITE_ASSOC, $extra));
		} elseif ($this->extension == 'sqlsrv') {
			$result->setResult(sqlsrv_query($this->connection, $result->getSQL()));
		} elseif ($this->extension == 'pdo') {
			$result->setResult($this->connection->query($result->getSQL()));
		}
		$this->statement = $statement;
		
		$this->handleErrors(fCore::stopErrorCapture());
		
		$this->checkForError($result, $extra);
	}
	
	
	/**
	 * Prepares a single fStatement object to execute prepared statements
	 * 
	 * Identifier placeholders (%r) are not supported with prepared statements.
	 * In addition, multiple values can not be escaped by a placeholder - only
	 * a single value can be provided.
	 * 
	 * @param  string  $sql  The SQL to prepare
	 * @return fStatement  A prepared statement object that can be passed to ::query(), ::unbufferedQuery() or ::execute()
	 */
	public function prepare($sql)
	{
		return $this->prepareStatement($sql);	
	}
	
	
	/**
	 * Prepares a single fStatement object to execute prepared statements
	 * 
	 * Identifier placeholders (%r) are not supported with prepared statements.
	 * In addition, multiple values can not be escaped by a placeholder - only
	 * a single value can be provided.
	 * 
	 * @param  string  $sql        The SQL to prepare
	 * @param  boolean $translate  If the SQL should be translated using fSQLTranslation
	 * @return fStatement  A prepare statement object that can be passed to ::query(), ::unbufferedQuery() or ::execute()
	 */
	private function prepareStatement($sql, $translate=FALSE)
	{
		// Ensure an SQL statement was passed
		if (empty($sql)) {
			throw new fProgrammerException('No SQL statement passed');
		}
		
		// This is just to keep the callback method signature consistent
		$values = array();
		
		if ($this->hook_callbacks['unmodified']) {
			foreach ($this->hook_callbacks['unmodified'] as $callback) {
				$params = array(
					$this,
					&$sql,
					&$values
				);
				call_user_func_array($callback, $params);
			}
		}
		
		// Fix \' in MySQL and PostgreSQL
		if(($this->type == 'mysql' || $this->type == 'postgresql') && strpos($sql, '\\') !== FALSE) {
			$sql = preg_replace("#(?<!\\\\)((\\\\{2})*)\\\\'#", "\\1''", $sql);	
		}
		
		// Separate the SQL from quoted values
		$parts = $this->splitSQL($sql);
		
		$query   = '';
		$strings = array();
		
		foreach ($parts as $part) {
			// We split out all strings except for empty ones because Oracle
			// has to translate empty strings to NULL
			if ($part[0] == "'" && $part != "''") {
				$query    .= ':string_' . sizeof($strings);
				$strings[] = $part;	
			} else {
				$query .= $part;	
			} 		
		}
		
		if ($this->hook_callbacks['extracted']) {
			foreach ($this->hook_callbacks['extracted'] as $callback) {
				$params = array(
					$this,
					&$query,
					&$values,
					&$strings
				);
				call_user_func_array($callback, $params);
			}
		}
		
		$pieces       = preg_split('#(%[lbdfistp])\b#', $query, -1, PREG_SPLIT_DELIM_CAPTURE|PREG_SPLIT_NO_EMPTY);
		$placeholders = array();
		
		$new_query = '';
		foreach ($pieces as $piece) {
			if (strlen($piece) == 2 && $piece[0] == '%') {
				$placeholders[] = $piece;
				$new_query     .= '%s';
			} else {
				$new_query .= $piece;
			}		
		}
		$query = $new_query;
		
		$untranslated_sql = NULL;
		if ($translate) {
			$query = $this->getSQLTranslation()->translate(array($query));
			$query = current($query);
			$untranslated_sql = $sql;
		}
		
		// Unescape literal semicolons in the queries
		$query = preg_replace('#(?<!\\\\)\\\\;#', ';', $query);
		
		// Put the strings back into the SQL
		foreach ($strings as $index => $string) {
			$string = strtr($string, array('\\' => '\\\\', '$' => '\\$'));
			$query  = preg_replace('#:string_' . $index . '\b#', $string, $query, 1);
		}
		
		return new fStatement($this, $query, $placeholders, $untranslated_sql);
	}
	
	
	/**
	 * Prepares the SQL by escaping values, spliting queries, cleaning escaped semicolons, fixing backslashed single quotes and translating
	 * 
	 * @param  string  $sql        The SQL to prepare
	 * @param  array   $values     Literal values to escape into the SQL
	 * @param  boolean $translate  If the SQL should be translated
	 * @return array  The split out SQL queries, queries that have been translated will have a string key of a number, `:` and the original SQL, non-translated SQL will have a numeric key
	 */
	private function prepareSQL($sql, $values, $translate)
	{
		$this->connectToDatabase();
		
		// Ensure an SQL statement was passed
		if (empty($sql)) {
			throw new fProgrammerException('No SQL statement passed');
		}
		
		if ($this->hook_callbacks['unmodified']) {
			foreach ($this->hook_callbacks['unmodified'] as $callback) {
				$params = array(
					$this,
					&$sql,
					&$values
				);
				call_user_func_array($callback, $params);
			}
		}
		
		// Fix \' in MySQL and PostgreSQL
		if(($this->type == 'mysql' || $this->type == 'postgresql') && strpos($sql, '\\') !== FALSE) {
			$sql = preg_replace("#(?<!\\\\)((\\\\{2})*)\\\\'#", "\\1''", $sql);	
		}
		
		$strings = array(array());
		$queries = array('');
		$number  = 0;
		
		// Separate the SQL from quoted values
		$parts = $this->splitSQL($sql);
				
		foreach ($parts as $part) {
			// We split out all strings except for empty ones because Oracle
			// has to translate empty strings to NULL
			if ($part[0] == "'" && $part != "''") {
				$queries[$number]  .= ':string_' . sizeof($strings[$number]);
				$strings[$number][] = $part;	
			} else {
				$split_queries = preg_split('#(?<!\\\\);#', $part);
				
				$queries[$number] .= $split_queries[0];
				
				for ($i=1; $i < sizeof($split_queries); $i++) {
					$queries[$number] = trim($queries[$number]);
					$number++;
					$strings[$number] = array();
					$queries[$number] = $split_queries[$i];
				}	
			} 		
		}
		if (!trim($queries[$number])) {
			unset($queries[$number]);
			unset($strings[$number]);	
		} else {
			$queries[$number] = trim($queries[$number]);	
		}
		
		// If the values were passed as a single array, this handles that
		$placeholders = preg_match_all('#%[lbdfristp]\b#', join(';', $queries), $trash);
		if (count($values) == 1 && is_array($values[0]) && count($values[0]) == $placeholders) {
			$values = array_shift($values);	
		}
		
		// Loop through the queries, chunk the values and add blank strings back in
		$chunked_values = array();
		$value_number   = 0;
		foreach (array_keys($queries) as $number) {
			$pieces       = preg_split('#(%[lbdfristp])\b#', $queries[$number], -1, PREG_SPLIT_DELIM_CAPTURE|PREG_SPLIT_NO_EMPTY);
			$placeholders = 0;
			
			$new_sql = '';
			$chunked_values[$number] = array();
			
			foreach ($pieces as $piece) {
				
				// A placeholder
				if (strlen($piece) == 2 && $piece[0] == '%') {
					
					$value = $values[$value_number];
					
					// Here we put numbers for LIMIT and OFFSET into the SQL so they can be translated properly
					if ($piece == '%i' && preg_match('#\b(LIMIT|OFFSET)\s+#Di', $new_sql)) {
						$new_sql .= (int) $value;
						$value_number++;
					
					// Here we put blank strings back into the SQL so they can be translated for Oracle
					} elseif ($piece == '%s' && $value !== NULL && ((string) $value) == '') {
						$new_sql .= "''";
						$value_number++;
					
					} elseif ($piece == '%r') {
						if (is_array($value)) {
							$new_sql .= join(', ', array_map($this->escapeIdentifier, $value));	
						} else {
							$new_sql .= $this->escapeIdentifier($value);
						}
						$value_number++;
						
					// Other placeholder/value combos just get added
					} else {
						$placeholders++;
						$value_number++;
						$new_sql .= $piece;
						$chunked_values[$number][] = $value;
					}
				
				// A piece of SQL
				} else {
					$new_sql .= $piece;	
				}
			}
			
			$queries[$number] = $new_sql;
		}
		
		if ($this->hook_callbacks['extracted']) {
			foreach (array_keys($queries) as $number) {
				foreach ($this->hook_callbacks['extracted'] as $callback) {
					if (!isset($chunked_values[$number])) {
						$chunked_values[$number] = array();
					}
					$params = array(
						$this,
						&$queries[$number],
						&$chunked_values[$number],
						&$strings[$number]
					);
					call_user_func_array($callback, $params);
				}
			}
		}
		
		// Translate the SQL queries
		if ($translate) {
			$queries = $this->getSQLTranslation()->translate($queries);
		}
		
		$output = array();
		foreach (array_keys($queries) as $key) {
			$query = $queries[$key];
			$parts = explode(':', $key, 2);
			$number = $parts[0];
			
			// Escape the values into the SQL
			if (!empty($chunked_values[$number])) {
				$query = $this->escapeSQL($query, $chunked_values[$number]);	
			}
			
			// Unescape literal semicolons in the queries
			$query = preg_replace('#(?<!\\\\)\\\\;#', ';', $query);
			
			// Put the strings back into the SQL
			if (isset($strings[$number])) {
				foreach ($strings[$number] as $index => $string) {
					$string = strtr($string, array('\\' => '\\\\', '$' => '\\$'));
					$query  = preg_replace('#:string_' . $index . '\b#', $string, $query, 1);
				}
			}
			
			$output[$key] = $query;
		}    
		
		return $output;
	}
	
	
	/**
	 * Executes one or more SQL queries and returns the result(s)
	 * 
	 * @param  string|fStatement $statement  One or more SQL statements in a string or a single fStatement prepared statement
	 * @param  mixed             $value      The optional value(s) to place into any placeholders in the SQL - see ::escape() for details
	 * @param  mixed             ...
	 * @return fResult|array  The fResult object(s) for the query
	 */
	public function query($statement)
	{
		$args    = func_get_args();
		$params  = array_slice($args, 1);
		
		if (is_object($statement)) {
			return $this->run($statement, 'fResult', $params);	
		}
		
		$queries = $this->prepareSQL($statement, $params, FALSE);
		
		$output = array();
		foreach ($queries as $query) {
			$output[] = $this->run($query, 'fResult');	
		}
		
		return sizeof($output) == 1 ? $output[0] : $output;
	}
	
	
	/**
	 * Registers a callback for one of the various query hooks - multiple callbacks can be registered for each hook
	 * 
	 * The following hooks are available:
	 *  - `'unmodified'`: The original SQL passed to fDatabase, for prepared statements this is called just once before the fStatement object is created
	 *  - `'extracted'`: The SQL after all non-empty strings have been extracted and replaced with `:string_{number}` placeholders
	 *  - `'run'`: After the SQL has been run
	 * 
	 * Methods for the `'unmodified'` hook should have the following signature:
	 * 
	 *  - **`$database`**:  The fDatabase instance
	 *  - **`&$sql`**:      The original, unedited SQL
	 *  - **`&$values`**:   The values to be escaped into the placeholders in the SQL - this will be empty for prepared statements
	 * 
	 * Methods for the `'extracted'` hook should have the following signature:
	 * 
	 *  - **`$database`**:  The fDatabase instance
	 *  - **`&$sql`**:      The original, unedited SQL
	 *  - **`&$values`**:   The values to be escaped into the placeholders in the SQL - this will be empty for prepared statements
	 *  - **`&$strings`**   The literal strings that were extracted from the SQL
	 * 
	 * The `extracted` hook is the best place to modify the SQL since there is
	 * no risk of breaking string literals. Please note that there may be empty
	 * strings (`''`) present in the SQL since some database treat those as
	 * `NULL`.
	 * 
	 * Methods for the `'run'` hook should have the following signature:
	 * 
	 *  - **`$database`**:    The fDatabase instance
	 *  - **`$query`**:       The (string) SQL or `array(0 => {fStatement object}, 1 => {values array})` 
	 *  - **`$query_time`**:  The (float) number of seconds the query took
	 *  - **`$result`**       The fResult or fUnbufferedResult object, or `FALSE` if no result
	 * 
	 * @param  string   $hook      The hook to register for
	 * @param  callback $callback  The callback to register - see the method description for details about the method signature
	 * @return void
	 */
	public function registerHookCallback($hook, $callback)
	{
		$valid_hooks = array(
			'unmodified',
			'extracted',
			'run'
		);
		
		if (!in_array($hook, $valid_hooks)) {
			throw new fProgrammerException(
				'The hook specified, %1$s, should be one of: %2$s.',
				$hook,
				join(', ', $valid_hooks)
			);
		}
		
		$this->hook_callbacks[$hook][] = $callback;
	}
	
	
	/**
	 * Runs a single statement and times it, removes any old unbuffered queries before starting
	 * 
	 * @param  string|fStatement $statement    The SQL statement or prepared statement to execute
	 * @param  string            $result_type  The type of result object to return, fResult or fUnbufferedResult
	 * @return fResult|fUnbufferedResult  The result for the query
	 */
	private function run($statement, $result_type=NULL, $params=array())
	{
		if ($this->unbuffered_result) {
			$this->unbuffered_result->__destruct();
			$this->unbuffered_result = NULL;
		}
		
		$start_time = microtime(TRUE);	
		
		if (is_object($statement)) {
			$sql = $statement->getSQL();		
		} else {
			$sql = $statement;	
		}
			
		if (!$result = $this->handleTransactionQueries($sql, $result_type)) {
			if ($result_type) {
				$result = new $result_type($this, $this->type == 'mssql' ? $this->schema_info['character_set'] : NULL);
				$result->setSQL($sql);
				
				if ($result_type == 'fResult') {
					$this->performQuery($statement, $result, $params);
				} else {
					$this->performUnbufferedQuery($statement, $result, $params);	
				}
				
				if ($statement instanceof fStatement && $statement->getUntranslatedSQL()) {
					$result->setUntranslatedSQL($statement->getUntranslatedSQL());
				}
				
			} else {
				$this->perform($statement, $params);	
			}
		}
		
		// Write some debugging info
		$query_time = microtime(TRUE) - $start_time;
		$this->query_time += $query_time;
		if (fCore::getDebug($this->debug)) {
			fCore::debug(
				self::compose(
					'Query time was %1$s seconds for:%2$s',
					$query_time,
					"\n" . $sql
				),
				$this->debug
			);
		}
		
		if ($this->hook_callbacks['run']) {
			foreach ($this->hook_callbacks['run'] as $callback) {
				$callback_params = array(
					$this,
					is_object($statement) ? array($statement, $params) : $sql,
					$query_time,
					$result
				);
				call_user_func_array($callback, $callback_params);
			}
		}
		
		if ($result_type) {
			return $result;
		}
	}
	
	
	/**
	 * Turns an array possibly containing objects into an array of all strings
	 * 
	 * @param  array $values  The array of values to scalarize
	 * @return array  The scalarized values
	 */
	private function scalarize($values)
	{
		$new_values = array();
		foreach ($values as $value) {
			if (is_object($value) && is_callable(array($value, '__toString'))) {
				$value = $value->__toString();
			} elseif (is_object($value)) {
				$value = (string) $value;	
			} elseif (is_array($value)) {
				$value = $this->scalarize($value);	
			}
			$new_values[] = $value;
		}
		return $new_values;	
	}
	
	
	/**
	 * Sets the number of rows affected by the query
	 * 
	 * @param  fResult $result    The result object for the query
	 * @param  mixed   $resource  Only applicable for `ibm_db2`, `pdo`, `oci8` and `sqlsrv` extentions or `mysqli` prepared statements - this is either the `PDOStatement` object, `mysqli_stmt` object or the `oci8` or `sqlsrv` resource
	 * @return void
	 */
	private function setAffectedRows($result, $resource=NULL)
	{
		if ($this->extension == 'ibm_db2') {
			$insert_update_delete = preg_match('#^\s*(INSERT|UPDATE|DELETE)\b#i', $result->getSQL());
			$result->setAffectedRows(!$insert_update_delete ? 0 : db2_num_rows($resource));
		} elseif ($this->extension == 'mssql') {
			$affected_rows_result = mssql_query('SELECT @@ROWCOUNT AS rows', $this->connection);
			$result->setAffectedRows((int) mssql_result($affected_rows_result, 0, 'rows'));
		} elseif ($this->extension == 'mysql') {
			$result->setAffectedRows(mysql_affected_rows($this->connection));
		} elseif ($this->extension == 'mysqli') {
			if (is_object($resource)) {
				$result->setAffectedRows($resource->affected_rows);
			} else {
				$result->setAffectedRows(mysqli_affected_rows($this->connection));
			}
		} elseif ($this->extension == 'oci8') {
			$result->setAffectedRows(oci_num_rows($resource));
		} elseif ($this->extension == 'pgsql') {
			$result->setAffectedRows(pg_affected_rows($result->getResult()));
		} elseif ($this->extension == 'sqlite') {
			$result->setAffectedRows(sqlite_changes($this->connection));
		} elseif ($this->extension == 'sqlsrv') {
			$result->setAffectedRows(sqlsrv_rows_affected($resource));
		} elseif ($this->extension == 'pdo') {
			// This fixes the fact that rowCount is not reset for non INSERT/UPDATE/DELETE statements
			try {
				if (!$resource || !$resource->fetch()) {
					throw new PDOException();
				}
				$result->setAffectedRows(0);
			} catch (PDOException $e) {
				// The SQLite PDO driver seems to return 1 when no rows are returned from a SELECT statement
				if ($this->type == 'sqlite' && $this->extension == 'pdo' && preg_match('#^\s*SELECT#i', $result->getSQL())) {
					$result->setAffectedRows(0);	
				} elseif (!$resource) {
					$result->setAffectedRows(0);
				} else {
					$result->setAffectedRows($resource->rowCount());
				}
			}
		}
	}
	
	
	/**
	 * Sets the number of rows returned by the query
	 * 
	 * @param  fResult $result  The result object for the query
	 * @return void
	 */
	private function setReturnedRows($result)
	{
		if (is_resource($result->getResult()) || is_object($result->getResult())) {
			if ($this->extension == 'mssql') {
				$result->setReturnedRows(mssql_num_rows($result->getResult()));
			} elseif ($this->extension == 'mysql') {
				$result->setReturnedRows(mysql_num_rows($result->getResult()));
			} elseif ($this->extension == 'mysqli') {
				$result->setReturnedRows(mysqli_num_rows($result->getResult()));
			} elseif ($this->extension == 'pgsql') {
				$result->setReturnedRows(pg_num_rows($result->getResult()));
			} elseif ($this->extension == 'sqlite') {
				$result->setReturnedRows(sqlite_num_rows($result->getResult()));
			}
		} elseif (is_array($result->getResult())) {
			$result->setReturnedRows(sizeof($result->getResult()));
		}
	}
	
	
	/**
	 * Splits SQL into pieces of SQL and quoted strings
	 * 
	 * @param  string $sql  The SQL to split
	 * @return array  The pieces
	 */
	private function splitSQL($sql)
	{
		$parts = array();
		$temp_sql      = $sql;
		$start_pos     = 0;
		$inside_string = FALSE;
		do {
			$pos = strpos($temp_sql, "'", $start_pos);
			if ($pos !== FALSE) {
				if (!$inside_string) {
					$parts[]   = substr($temp_sql, 0, $pos);
					$temp_sql  = substr($temp_sql, $pos);
					$start_pos = 1;
					$inside_string = TRUE;
					 
				} elseif ($pos == strlen($temp_sql)) {
					$parts[]  = $temp_sql;
					$temp_sql = '';
					$pos = FALSE;	
				
				} elseif (strlen($temp_sql) > $pos+1 && $temp_sql[$pos+1] == "'") {
					$start_pos = $pos+2;
							
				} else {
					$parts[]   = substr($temp_sql, 0, $pos+1);
					$temp_sql  = substr($temp_sql, $pos+1);
					$start_pos = 0;
					$inside_string = FALSE;
				}
			}
		} while ($pos !== FALSE);
		if ($temp_sql) {
			$parts[] = $temp_sql;	
		}
		
		return $parts;	
	}
	
	
	/**
	 * Translates one or more SQL statements using fSQLTranslation and executes them without returning any results
	 * 
	 * @param  string $sql    One or more SQL statements
	 * @param  mixed  $value  The optional value(s) to place into any placeholders in the SQL - see ::escape() for details
	 * @param  mixed  ...
	 * @return void
	 */
	public function translatedExecute($sql)
	{
		$args    = func_get_args();
		$queries = $this->prepareSQL(
			$sql,
			array_slice($args, 1),
			TRUE
		);
		
		$output = array();
		foreach ($queries as $query) {
			$this->run($query);	
		}
	}
	
	
	/**
	 * Translates a SQL statement and creates an fStatement object from it
	 * 
	 * Identifier placeholders (%r) are not supported with prepared statements.
	 * In addition, multiple values can not be escaped by a placeholder - only
	 * a single value can be provided.
	 * 
	 * @param  string  $sql  The SQL to prepare
	 * @return fStatement  A prepared statement object that can be passed to ::query(), ::unbufferedQuery() or ::execute()
	 */
	public function translatedPrepare($sql)
	{
		return $this->prepareStatement($sql, TRUE);	
	}
	
	
	/**
	 * Translates one or more SQL statements using fSQLTranslation and executes them
	 * 
	 * @param  string $sql    One or more SQL statements
	 * @param  mixed  $value  The optional value(s) to place into any placeholders in the SQL - see ::escape() for details
	 * @param  mixed  ...
	 * @return fResult|array  The fResult object(s) for the query
	 */
	public function translatedQuery($sql)
	{
		$args    = func_get_args();
		$queries = $this->prepareSQL(
			$sql,
			array_slice($args, 1),
			TRUE
		);
		
		$output = array();
		foreach ($queries as $key => $query) {
			$result = $this->run($query, 'fResult');
			if (!is_numeric($key)) {
				list($number, $original_query) = explode(':', $key, 2);
				$result->setUntranslatedSQL($original_query);
			}
			$output[] = $result;
		}
		
		return sizeof($output) == 1 ? $output[0] : $output;
	}
	
	
	/**
	 * Executes a single SQL statement in unbuffered mode. This is optimal for
	 * large results sets since it does not load the whole result set into
	 * memory first. The gotcha is that only one unbuffered result can exist at
	 * one time. If another unbuffered query is executed, the old result will
	 * be deleted.
	 * 
	 * @param  string|fStatement $statement  A single SQL statement
	 * @param  mixed             $value      The optional value(s) to place into any placeholders in the SQL - see ::escape() for details
	 * @param  mixed             ...
	 * @return fUnbufferedResult  The result object for the unbuffered query
	 */
	public function unbufferedQuery($statement)
	{
		$args    = func_get_args();
		$params  = array_slice($args, 1);
		
		if (is_object($statement)) {
			$result = $this->run($statement, 'fUnbufferedResult', $params);
			
		} else {
			$queries = $this->prepareSQL($statement, $params, FALSE);
			
			if (sizeof($queries) > 1) {
				throw new fProgrammerException(
					'Only a single unbuffered query can be run at a time, however %d were passed',
					sizeof($queries)	
				);
			}
			
			$result = $this->run($queries[0], 'fUnbufferedResult');
		}
		
		$this->unbuffered_result = $result;
		
		return $result;
	}
	
	
	/**
	 * Translates the SQL statement using fSQLTranslation and then executes it
	 * in unbuffered mode. This is optimal for large results sets since it does
	 * not load the whole result set into memory first. The gotcha is that only
	 * one unbuffered result can exist at one time. If another unbuffered query
	 * is executed, the old result will be deleted.
	 * 
	 * @param  string $sql    A single SQL statement
	 * @param  mixed  $value  The optional value(s) to place into any placeholders in the SQL - see ::escape() for details
	 * @param  mixed  ...
	 * @return fUnbufferedResult  The result object for the unbuffered query
	 */
	public function unbufferedTranslatedQuery($sql)
	{
		$args    = func_get_args();
		$queries = $this->prepareSQL(
			$sql,
			array_slice($args, 1),
			TRUE
		);  
		
		if (sizeof($queries) > 1) {
			throw new fProgrammerException(
				'Only a single unbuffered query can be run at a time, however %d were passed',
				sizeof($queries)	
			);
		}
		
		$query_keys = array_keys($queries);
		$key        = $query_keys[0];
		list($number, $original_query) = explode(':', $key, 2);
		
		$result = $this->run($queries[$key], 'fUnbufferedResult');
		$result->setUntranslatedSQL($original_query);
		
		$this->unbuffered_result = $result;
		
		return $result;
	}
	
	
	/**
	 * Unescapes a value coming out of a database based on its data type
	 * 
	 * The valid data types are:
	 * 
	 *  - `'blob'` (or `'%l'`)
	 *  - `'boolean'` (or `'%b'`)
	 *  - `'date'` (or `'%d'`)
	 *  - `'float'` (or `'%f'`)
	 *  - `'integer'` (or `'%i'`)
	 *  - `'string'` (also `'%s'`, `'varchar'`, `'char'` or `'text'`)
	 *  - `'time'` (or `'%t'`)
	 *  - `'timestamp'` (or `'%p'`)
	 * 
	 * @param  string $data_type  The data type being unescaped - see method description for valid values
	 * @param  mixed  $value      The value or array of values to unescape
	 * @return mixed  The unescaped value
	 */
	public function unescape($data_type, $value)
	{
		if ($value === NULL) {
			return $value;	
		}
		
		$callback = NULL;
		
		switch ($data_type) {
			// Testing showed that strings tend to be most common,
			// and moving this to the top of the switch statement
			// improved performance on read-heavy pages
			case 'string':
			case 'varchar':
			case 'char':
			case 'text':
			case '%s':
				return $value;
			
			case 'boolean':
			case '%b':
				$callback = $this->unescapeBoolean;
				break;
				
			case 'date':
			case '%d':
				$callback = $this->unescapeDate;
				break;
				
			case 'float':
			case '%f':
				return $value;
				
			case 'integer':
			case '%i':
				return $value;
			
			case 'time':
			case '%t':
				$callback = $this->unescapeTime;
				break;
				
			case 'timestamp':
			case '%p':
				$callback = $this->unescapeTimestamp;
				break;
			
			case 'blob':
			case '%l':
				$callback = $this->unescapeBlob;
				break;
		}
		
		if ($callback) {
			if (is_array($value)) {
				return array_map($callback, $value);	
			}
			return call_user_func($callback, $value);
		}	
		
		throw new fProgrammerException(
			'Unknown data type, %1$s, specified. Must be one of: %2$s.',
			$data_type,
			'blob, %l, boolean, %b, date, %d, float, %f, integer, %i, string, %s, time, %t, timestamp, %p'
		);	
	}
	
	
	/**
	 * Unescapes a blob coming out of the database
	 * 
	 * @param  string $value  The value to unescape
	 * @return binary  The binary data
	 */
	private function unescapeBlob($value)
	{
		$this->connectToDatabase();
		
		if ($this->extension == 'pgsql') {
			return pg_unescape_bytea($value);
		} elseif ($this->extension == 'pdo' && is_resource($value)) {
			return stream_get_contents($value);
		} elseif ($this->extension == 'sqlite') {
			return pack('H*', $value);
		} else {
			return $value;
		}
	}
	
	
	/**
	 * Unescapes a boolean coming out of the database
	 * 
	 * @param  string $value  The value to unescape
	 * @return boolean  The boolean
	 */
	private function unescapeBoolean($value)
	{
		return ($value === 'f' || !$value) ? FALSE : TRUE;
	}
	
	
	/**
	 * Unescapes a date coming out of the database
	 * 
	 * @param  string $value  The value to unescape
	 * @return string  The date in YYYY-MM-DD format
	 */
	private function unescapeDate($value)
	{
		if ($this->extension == 'sqlsrv' && $value instanceof DateTime) {
			return $value->format('Y-m-d');
		} elseif ($this->type == 'mssql') {
			$value = preg_replace('#:\d{3}#', '', $value);
		}
		return date('Y-m-d', strtotime($value));
	}
	
	
	/**
	 * Unescapes a time coming out of the database
	 * 
	 * @param  string $value  The value to unescape
	 * @return string  The time in `HH:MM:SS` format
	 */
	private function unescapeTime($value)
	{
		if ($this->extension == 'sqlsrv' && $value instanceof DateTime) {
			return $value->format('H:i:s');
		} elseif ($this->type == 'mssql') {
			$value = preg_replace('#:\d{3}#', '', $value);
		}
		return date('H:i:s', strtotime($value));
	}
	
	
	/**
	 * Unescapes a timestamp coming out of the database
	 * 
	 * @param  string $value  The value to unescape
	 * @return string  The timestamp in `YYYY-MM-DD HH:MM:SS` format
	 */
	private function unescapeTimestamp($value)
	{
		if ($this->extension == 'sqlsrv' && $value instanceof DateTime) {
			return $value->format('Y-m-d H:i:s');
		} elseif ($this->type == 'mssql') {
			$value = preg_replace('#:\d{3}#', '', $value);
		}
		return date('Y-m-d H:i:s', strtotime($value));
	}
}

/**
 * Representation of a result from a query against the fDatabase class
 * 
 * @copyright  Copyright (c) 2007-2010 Will Bond
 * @author     Will Bond [wb] <will@flourishlib.com>
 * @license    http://flourishlib.com/license
 * 
 * @package    Flourish
 * @link       http://flourishlib.com/fResult
 * 
 * @version    1.0.0b11
 * @changes    1.0.0b11  Backwards Compatibility Break - removed ODBC support [wb, 2010-07-31]
 * @changes    1.0.0b10  Added IBM DB2 support [wb, 2010-04-13]
 * @changes    1.0.0b9   Added support for prepared statements [wb, 2010-03-02]
 * @changes    1.0.0b8   Fixed a bug with decoding MSSQL national column when using an ODBC connection [wb, 2009-09-18]
 * @changes    1.0.0b7   Added the method ::unescape(), changed ::tossIfNoRows() to return the object for chaining [wb, 2009-08-12]
 * @changes    1.0.0b6   Fixed a bug where ::fetchAllRows() would throw a fNoRowsException [wb, 2009-06-30]
 * @changes    1.0.0b5   Added the method ::asObjects() to allow for returning objects instead of associative arrays [wb, 2009-06-23]
 * @changes    1.0.0b4   Fixed a bug with not properly converting SQL Server text to UTF-8 [wb, 2009-06-18]
 * @changes    1.0.0b3   Added support for Oracle, various bug fixes [wb, 2009-05-04]
 * @changes    1.0.0b2   Updated for new fCore API [wb, 2009-02-16]
 * @changes    1.0.0b    The initial implementation [wb, 2007-09-25]
 */
class fResult implements Iterator
{
	/**
	 * Composes text using fText if loaded
	 * 
	 * @param  string  $message    The message to compose
	 * @param  mixed   $component  A string or number to insert into the message
	 * @param  mixed   ...
	 * @return string  The composed and possible translated message
	 */
	static protected function compose($message)
	{
		$args = array_slice(func_get_args(), 1);
		
		if (class_exists('fText', FALSE)) {
			return call_user_func_array(
				array('fText', 'compose'),
				array($message, $args)
			);
		} else {
			return vsprintf($message, $args);
		}
	}
	
	
	/**
	 * The number of rows affected by an `INSERT`, `UPDATE`, `DELETE`, etc
	 * 
	 * @var integer
	 */
	private $affected_rows = 0;
	
	/**
	 * The auto incremented value from the query
	 * 
	 * @var integer
	 */
	private $auto_incremented_value = NULL;
	
	/**
	 * The character set to transcode from for MSSQL queries
	 * 
	 * @var string
	 */
	private $character_set = NULL;
	
	/**
	 * The current row of the result set
	 * 
	 * @var array
	 */
	private $current_row = NULL;
	
	/**
	 * The database object this result was created from
	 * 
	 * @var fDatabase
	 */
	private $database = NULL;
	
	/**
	 * If rows should be converted to objects
	 * 
	 * @var boolean
	 */
	private $output_objects = FALSE;
	
	/**
	 * The position of the pointer in the result set
	 * 
	 * @var integer
	 */
	private $pointer;
	
	/**
	 * The result resource or array
	 * 
	 * @var mixed
	 */
	private $result = NULL;
	
	/**
	 * The number of rows returned by a select
	 * 
	 * @var integer
	 */
	private $returned_rows = 0;
	
	/**
	 * The SQL query
	 * 
	 * @var string
	 */
	private $sql = '';
	
	/**
	 * Holds the data types for each column to allow for on-the-fly unescaping
	 * 
	 * @var array
	 */
	private $unescape_map = array();
	
	/**
	 * The SQL from before translation - only applicable to translated queries
	 * 
	 * @var string
	 */
	private $untranslated_sql = NULL;
	
	
	/**
	 * Configures the result set
	 * 
	 * @internal
	 * 
	 * @param  fDatabase $database       The database object this result set was created from
	 * @param  string    $character_set  MSSQL only: the character set to transcode from since MSSQL doesn't do UTF-8
	 * @return fResult
	 */
	public function __construct($database, $character_set=NULL)
	{
		if (!$database instanceof fDatabase) {
			throw new fProgrammerException(
				'The database object provided does not appear to be a descendant of fDatabase'
			);
		}
		
		$this->database      = $database;
		$this->character_set = $character_set;
	}
	
	
	/**
	 * Frees up the result object to save memory
	 * 
	 * @internal
	 * 
	 * @return void
	 */
	public function __destruct()
	{
		if (!is_resource($this->result) && !is_object($this->result)) {
			return;
		}
		
		switch ($this->database->getExtension()) {
			case 'mssql':
				mssql_free_result($this->result);
				break;
				
			case 'mysql':
				mysql_free_result($this->result);
				break;
				
			case 'mysqli':
				if (is_resource($this->result)) {
					mysqli_free_result($this->result);
				}
				break;
				
			case 'pgsql':
				pg_free_result($this->result);
				break;
		}
		
		$this->result = NULL;
	}
	
	
	/**
	 * All requests that hit this method should be requests for callbacks
	 * 
	 * @internal
	 * 
	 * @param  string $method  The method to create a callback for
	 * @return callback  The callback for the method requested
	 */
	public function __get($method)
	{
		return array($this, $method);		
	}
	
	
	/**
	 * Gets the next row from the result and assigns it to the current row
	 * 
	 * @return void
	 */
	private function advanceCurrentRow()
	{
		$type      = $this->database->getType();
		$extension = $this->database->getExtension();
		
		switch ($extension) {
			case 'mssql':
				$row = mssql_fetch_assoc($this->result);
				if (!empty($row)) {
					$row = $this->fixDblibMSSQLDriver($row);
				}
				break;
				
			case 'mysql':
				$row = mysql_fetch_assoc($this->result);
				break;
				
			case 'mysqli':
				if (is_object($this->result)) {
					$row = mysqli_fetch_assoc($this->result);
				} else {
					$row = $this->result[$this->pointer];
				}
				break;
				
			case 'pgsql':
				$row = pg_fetch_assoc($this->result);
				break;
				
			case 'sqlite':
				$row = sqlite_fetch_array($this->result, SQLITE_ASSOC);
				break;
				
			case 'ibm_db2':
			case 'oci8':
			case 'pdo':
			case 'sqlsrv':
				$row = $this->result[$this->pointer];
				break;
		}
		
		
		// Fix uppercase column names to lowercase
		if ($row && ($type == 'oracle' || ($type == 'db2' && $extension != 'ibm_db2'))) {
			$new_row = array();
			foreach ($row as $column => $value) {
				$new_row[strtolower($column)] = $value;
			}	
			$row = $new_row;
		}
		
		// This is an unfortunate fix that required for databases that don't support limit
		// clauses with an offset. It prevents unrequested columns from being returned.
		if ($row && in_array($type, array('mssql', 'oracle', 'db2'))) {
			if ($this->untranslated_sql !== NULL && isset($row['flourish__row__num'])) {
				unset($row['flourish__row__num']);
			}	
		}
		
		// This decodes the data coming out of MSSQL into UTF-8
		if ($row && $type == 'mssql') {
			if ($this->character_set) {
				foreach ($row as $key => $value) {
					if (!is_string($value) || strpos($key, 'fmssqln__') === 0 || isset($row['fmssqln__' . $key]) || preg_match('#[\x0-\x8\xB\xC\xE-\x1F]#', $value)) {
						continue;
					} 		
					$row[$key] = iconv($this->character_set, 'UTF-8', $value);
				}
			}
			$row = $this->decodeMSSQLNationalColumns($row);
		}
		
		if ($this->unescape_map) {
			foreach ($this->unescape_map as $column => $type) {
				if (!isset($row[$column])) { continue; }
				$row[$column] = $this->database->unescape($type, $row[$column]);
			}	
		} 
		
		$this->current_row = $row;
	}
	
	
	/**
	 * Sets the object to return rows as objects instead of associative arrays (the default)
	 * 
	 * @return fResult  The result object, to allow for method chaining
	 */
	public function asObjects()
	{
		$this->output_objects = TRUE;
		return $this;
	}
	
	
	/**
	 * Returns the number of rows affected by the query
	 * 
	 * @return integer  The number of rows affected by the query
	 */
	public function countAffectedRows()
	{
		return $this->affected_rows;
	}
	
	
	/**
	 * Returns the number of rows returned by the query
	 * 
	 * @return integer  The number of rows returned by the query
	 */
	public function countReturnedRows()
	{
		return $this->returned_rows;
	}
	
	
	/**
	 * Returns the current row in the result set (required by iterator interface)
	 * 
	 * @throws fNoRowsException       When the query did not return any rows
	 * @throws fNoRemainingException  When there are no remaining rows in the result
	 * @internal
	 * 
	 * @return array|stdClass  The current row
	 */
	public function current()
	{
		if(!$this->returned_rows) {
			throw new fNoRowsException('The query did not return any rows');
		}
		
		if (!$this->valid()) {
			throw new fNoRemainingException('There are no remaining rows');
		}
		
		// Primes the result set
		if ($this->pointer === NULL) {
			$this->pointer = 0;
			$this->advanceCurrentRow();
		}
		
		if ($this->output_objects) {
			return (object) $this->current_row;	
		}
		return $this->current_row;
	}
	
	
	/**
	 * Decodes national (unicode) character data coming out of MSSQL into UTF-8
	 * 
	 * @param  array $row  The row from the database
	 * @return array  The fixed row
	 */
	private function decodeMSSQLNationalColumns($row)
	{
		if (strpos($this->sql, 'fmssqln__') === FALSE) {
			return $row;
		}
		
		$columns = array_keys($row);
		
		foreach ($columns as $column) {
			if (substr($column, 0, 9) != 'fmssqln__') {
				continue;
			}	
			
			$real_column = substr($column, 9);
			
			$row[$real_column] = iconv('ucs-2le', 'utf-8', $this->database->unescape('blob', $row[$column]));
			unset($row[$column]);
		}
		
		return $row;
	}
	
	
	/**
	 * Returns all of the rows from the result set
	 * 
	 * @return array  The array of rows
	 */
	public function fetchAllRows()
	{
		$all_rows = array();
		foreach ($this as $row) {
			$all_rows[] = $row;
		}
		return $all_rows;
	}
	
	
	/**
	 * Returns the row next row in the result set (where the pointer is currently assigned to)
	 * 
	 * @throws fNoRowsException       When the query did not return any rows
	 * @throws fNoRemainingException  When there are no rows left in the result
	 * 
	 * @return array|stdClass  The next row in the result
	 */
	public function fetchRow()
	{
		$row = $this->current();
		$this->next();
		return $row;
	}
	
	
	/**
	 * Wraps around ::fetchRow() and returns the first field from the row instead of the whole row
	 * 
	 * @throws fNoRowsException       When the query did not return any rows
	 * @throws fNoRemainingException  When there are no rows left in the result
	 * 
	 * @return string|number|boolean  The first scalar value from ::fetchRow()
	 */
	public function fetchScalar()
	{
		$row = $this->fetchRow();
		return array_shift($row);
	}
	
	
	/**
	 * Warns the user about bugs in the DBLib driver for MSSQL, fixes some bugs
	 * 
	 * @param  array $row  The row from the database
	 * @return array  The fixed row
	 */
	private function fixDblibMSSQLDriver($row)
	{
		static $using_dblib = NULL;
		
		if ($using_dblib === NULL) {
		
			// If it is not a windows box we are definitely not using dblib
			if (!fCore::checkOS('windows')) {
				$using_dblib = FALSE;
			
			// Check this windows box for dblib
			} else {
				ob_start();
				phpinfo(INFO_MODULES);
				$module_info = ob_get_contents();
				ob_end_clean();
				
				$using_dblib = !preg_match('#FreeTDS#ims', $module_info, $match);
			}
		}
		
		if (!$using_dblib) {
			return $row;
		}
		
		foreach ($row as $key => $value) {
			if ($value === ' ') {
				$row[$key] = '';
				trigger_error(
					self::compose(
						'A single space was detected coming out of the database and was converted into an empty string - see %s for more information',
						'http://bugs.php.net/bug.php?id=26315'
					),
					E_USER_NOTICE
				);
			}
			if (strlen($key) == 30) {
				trigger_error(
					self::compose(
						'A column name exactly 30 characters in length was detected coming out of the database - this column name may be truncated, see %s for more information.',
						'http://bugs.php.net/bug.php?id=23990'
					),
					E_USER_NOTICE
				);
			}
			if (strlen($value) == 256) {
				trigger_error(
					self::compose(
						'A value exactly 255 characters in length was detected coming out of the database - this value may be truncated, see %s for more information.',
						'http://bugs.php.net/bug.php?id=37757'
					),
					E_USER_NOTICE
				);
			}
		}
		
		return $row;
	}
	
	
	/**
	 * Returns the last auto incremented value for this database connection. This may or may not be from the current query.
	 * 
	 * @return integer  The auto incremented value
	 */
	public function getAutoIncrementedValue()
	{
		return $this->auto_incremented_value;
	}
	
	
	/**
	 * Returns the result
	 * 
	 * @internal
	 * 
	 * @return mixed  The result of the query
	 */
	public function getResult()
	{
		return $this->result;
	}
	
	
	/**
	 * Returns the SQL used in the query
	 * 
	 * @return string  The SQL used in the query
	 */
	public function getSQL()
	{
		return $this->sql;
	}
	
	
	/**
	 * Returns the SQL as it was before translation
	 * 
	 * @return string  The SQL from before translation
	 */
	public function getUntranslatedSQL()
	{
		return $this->untranslated_sql;
	}
	
	
	/**
	 * Returns the current row number (required by iterator interface)
	 * 
	 * @throws fNoRowsException       When the query did not return any rows
	 * @throws fNoRemainingException  When there are no remaining rows in the result
	 * @internal
	 * 
	 * @return integer  The current row number
	 */
	public function key()
	{
		if ($this->pointer === NULL) {
			$this->current();
		}
		
		return $this->pointer;
	}
	
	
	/**
	 * Advances to the next row in the result (required by iterator interface)
	 * 
	 * @throws fNoRowsException       When the query did not return any rows
	 * @throws fNoRemainingException  When there are no remaining rows in the result
	 * @internal
	 * 
	 * @return void
	 */
	public function next()
	{
		if ($this->pointer === NULL) {
			$this->current();
		}
		
		$this->pointer++;
		
		if ($this->valid()) {
			$this->advanceCurrentRow();
		} else {
			$this->current_row = NULL;
		}
	}
	
	
	/**
	 * Rewinds the query (required by iterator interface)
	 * 
	 * @internal
	 * 
	 * @return void
	 */
	public function rewind()
	{
		try {
			$this->seek(0);
		} catch (Exception $e) { }
	}
	
	
	/** 
	 * Seeks to the specified zero-based row for the specified SQL query
	 * 
	 * @throws fNoRowsException  When the query did not return any rows
	 * 
	 * @param  integer $row  The row number to seek to (zero-based)
	 * @return void
	 */
	public function seek($row)
	{
		if(!$this->returned_rows) {
			throw new fNoRowsException('The query did not return any rows');
		}
		
		if ($row >= $this->returned_rows || $row < 0) {
			throw new fProgrammerException('The row requested does not exist');
		}
		
		$this->pointer = $row;
					
		switch ($this->database->getExtension()) {			
			case 'mssql':
				$success = mssql_data_seek($this->result, $row);
				break;
				
			case 'mysql':
				$success = mysql_data_seek($this->result, $row);
				break;
				
			case 'mysqli':
				if (is_object($this->result)) {
					$success = mysqli_data_seek($this->result, $row);
				} else {
					$success = TRUE;
				}
				break;
				
			case 'pgsql':
				$success = pg_result_seek($this->result, $row);
				break;
				
			case 'sqlite':
				$success = sqlite_seek($this->result, $row);
				break;
				
			case 'ibm_db2':
			case 'oci8':
			case 'pdo':
			case 'sqlsrv':
				// Do nothing since we already changed the pointer
				$success = TRUE;
				break;
		}
		
		if (!$success) {
			throw new fSQLException(
				'There was an error seeking to row %s',
				$row
			);
		}
		
		$this->advanceCurrentRow();
	}
	
	
	/**
	 * Sets the number of affected rows
	 * 
	 * @internal
	 * 
	 * @param  integer $affected_rows  The number of affected rows
	 * @return void
	 */
	public function setAffectedRows($affected_rows)
	{
		if ($affected_rows === -1) { $affected_rows = 0; }
		$this->affected_rows = (int) $affected_rows;
	}
	
	
	/**
	 * Sets the auto incremented value
	 * 
	 * @internal
	 * 
	 * @param  integer $auto_incremented_value  The auto incremented value
	 * @return void
	 */
	public function setAutoIncrementedValue($auto_incremented_value)
	{
		$this->auto_incremented_value = ($auto_incremented_value == 0) ? NULL : $auto_incremented_value;
	}
	
	
	/**
	 * Sets the result from the query
	 * 
	 * @internal
	 * 
	 * @param  mixed $result  The result from the query
	 * @return void
	 */
	public function setResult($result)
	{
		$this->result = $result;
	}
	
	
	/**
	 * Sets the number of rows returned
	 * 
	 * @internal
	 * 
	 * @param  integer $returned_rows  The number of rows returned
	 * @return void
	 */
	public function setReturnedRows($returned_rows)
	{
		$this->returned_rows = (int) $returned_rows;
		if ($this->returned_rows) {
			$this->affected_rows = 0;
		}
	}
	
	
	/**
	 * Sets the SQL used in the query
	 * 
	 * @internal
	 * 
	 * @param  string $sql  The SQL used in the query
	 * @return void
	 */
	public function setSQL($sql)
	{
		$this->sql = $sql;
	}
	
	
	/**
	 * Sets the SQL from before translation
	 * 
	 * @internal
	 * 
	 * @param  string $untranslated_sql  The SQL from before translation
	 * @return void
	 */
	public function setUntranslatedSQL($untranslated_sql)
	{
		$this->untranslated_sql = $untranslated_sql;
	}
	
	
	/**
	 * Throws an fNoResultException if the query did not return any rows
	 * 
	 * @throws fNoRowsException  When the query did not return any rows
	 * 
	 * @param  string $message  The message to use for the exception if there are no rows in this result set
	 * @return fResult  The result object, to allow for method chaining
	 */
	public function tossIfNoRows($message=NULL)
	{
		if (!$this->returned_rows && !$this->affected_rows) {
			if ($message === NULL) {
				$message = 'No rows were returned or affected by the query';
			}
			throw new fNoRowsException($message);
		}
		
		return $this;
	}
	
	
	/**
	 * Sets the result object to unescape all values as they are retrieved from the object
	 * 
	 * The data types should be from the list of types supported by
	 * fDatabase::unescape().
	 * 
	 * @param  array $column_data_type_map  An associative array with column names as the keys and the data types as the values
	 * @return fResult  The result object, to allow for method chaining
	 */
	public function unescape($column_data_type_map)
	{
		 if (!is_array($column_data_type_map)) {
			throw new fProgrammerException(
				'The column to data type map specified, %s, does not appear to be an array',
				$column_data_type_map
			);
		 }
		 
		 $this->unescape_map = $column_data_type_map;
		 
		 return $this;
	}
	
	
	/**
	 * Returns if the query has any rows left
	 * 
	 * @return boolean  If the iterator is still valid
	 */
	public function valid()
	{
		if (!$this->returned_rows) {
			return FALSE;
		}
		
		if ($this->pointer === NULL) {
			return TRUE;
		}
		
		return ($this->pointer < $this->returned_rows);
	}
}

/**
 * Gets schema information for the selected database
 * 
 * @copyright  Copyright (c) 2007-2011 Will Bond
 * @author     Will Bond [wb] <will@flourishlib.com>
 * @license    http://flourishlib.com/license
 * 
 * @package    Flourish
 * @link       http://flourishlib.com/fSchema
 * 
 * @version    1.0.0b46
 * @changes    1.0.0b46  Enhanced SQLite schema detection to cover situations where `UNIQUE` constraints are defined separately from the table and when comments are used in `CREATE TABLE` statements [wb, 2011-02-06]
 * @changes    1.0.0b45  Fixed Oracle auto incrementing detection to work with `INSERT OR UPDATE` triggers, fixed detection of dynamic default date/time/timestamp values for DB2 and Oracle [wb, 2010-12-04]
 * @changes    1.0.0b44  Fixed the list of valid elements for ::getColumnInfo() [wb, 2010-11-28]
 * @changes    1.0.0b43  Added the `comment` element to the information returned by ::getColumnInfo() [wb, 2010-11-28]
 * @changes    1.0.0b42  Fixed a bug with MySQL detecting default `ON DELETE` clauses [wb, 2010-10-19]
 * @changes    1.0.0b41  Fixed handling MySQL table names that require quoting [wb, 2010-08-24]
 * @changes    1.0.0b40  Fixed bugs in the documentation and error message of ::getColumnInfo() about what are valid elements [wb, 2010-07-21]
 * @changes    1.0.0b39  Fixed a regression where key detection SQL was not compatible with PostgreSQL 8.1 [wb, 2010-04-13]
 * @changes    1.0.0b38  Added Oracle support to ::getDatabases() [wb, 2010-04-13]
 * @changes    1.0.0b37  Fixed ::getDatabases() for MSSQL [wb, 2010-04-09]
 * @changes    1.0.0b36  Fixed PostgreSQL to properly report explicit `NULL` default values via ::getColumnInfo() [wb, 2010-03-30]
 * @changes    1.0.0b35  Added `max_length` values for various text and blob data types across all databases [wb, 2010-03-29]
 * @changes    1.0.0b34  Added `min_value` and `max_value` attributes to ::getColumnInfo() to specify the valid range for numeric columns [wb, 2010-03-16]
 * @changes    1.0.0b33  Changed it so that PostgreSQL unique indexes containing functions are ignored since they can't be properly detected at this point [wb, 2010-03-14]
 * @changes    1.0.0b32  Fixed ::getTables() to not include views for MySQL [wb, 2010-03-14]
 * @changes    1.0.0b31  Fixed the creation of the default caching key for ::enableCaching() [wb, 2010-03-02]
 * @changes    1.0.0b30  Fixed the class to work with lower privilege Oracle accounts and added detection of Oracle number columns [wb, 2010-01-25]
 * @changes    1.0.0b29  Added on_delete and on_update elements to one-to-one relationship info retrieved by ::getRelationships() [wb, 2009-12-16]
 * @changes    1.0.0b28  Fixed a bug with detecting some multi-column unique constraints in SQL Server databases [wb, 2009-11-13]
 * @changes    1.0.0b27  Added a parameter to ::enableCaching() to provide a key token that will allow cached values to be shared between multiple databases with the same schema [wb, 2009-10-28]
 * @changes    1.0.0b26  Added the placeholder element to the output of ::getColumnInfo(), added support for PostgreSQL, MSSQL and Oracle "schemas", added support for parsing quoted SQLite identifiers [wb, 2009-10-22]
 * @changes    1.0.0b25  One-to-one relationships utilizing the primary key as a foreign key are now properly detected [wb, 2009-09-22]
 * @changes    1.0.0b24  Fixed MSSQL support to work with ODBC database connections [wb, 2009-09-18]
 * @changes    1.0.0b23  Fixed a bug where one-to-one relationships were being listed as many-to-one [wb, 2009-07-21]
 * @changes    1.0.0b22  PostgreSQL UNIQUE constraints that are created as indexes and not table constraints are now properly detected [wb, 2009-07-08]
 * @changes    1.0.0b21  Added support for the UUID data type in PostgreSQL [wb, 2009-06-18]
 * @changes    1.0.0b20  Add caching of merged info, improved performance of ::getColumnInfo() [wb, 2009-06-15]
 * @changes    1.0.0b19  Fixed a couple of bugs with ::setKeysOverride() [wb, 2009-06-04]
 * @changes    1.0.0b18  Added missing support for MySQL mediumint columns [wb, 2009-05-18]
 * @changes    1.0.0b17  Fixed a bug with ::clearCache() not properly reseting the tables and databases list [wb, 2009-05-13]
 * @changes    1.0.0b16  Backwards Compatibility Break - ::setCacheFile() changed to ::enableCaching() and now requires an fCache object, ::flushInfo() renamed to ::clearCache(), added Oracle support [wb, 2009-05-04]
 * @changes    1.0.0b15  Added support for the three different types of identifier quoting in SQLite [wb, 2009-03-28]
 * @changes    1.0.0b14  Added support for MySQL column definitions containing the COLLATE keyword [wb, 2009-03-28]
 * @changes    1.0.0b13  Fixed a bug with detecting PostgreSQL columns having both a CHECK constraint and a UNIQUE constraint [wb, 2009-02-27]
 * @changes    1.0.0b12  Fixed detection of multi-column primary keys in MySQL [wb, 2009-02-27]
 * @changes    1.0.0b11  Fixed an issue parsing MySQL tables with comments [wb, 2009-02-25]
 * @changes    1.0.0b10  Added the ::getDatabases() method [wb, 2009-02-24]
 * @changes    1.0.0b9   Now detects unsigned and zerofill MySQL data types that do not have a parenthetical part [wb, 2009-02-16]
 * @changes    1.0.0b8   Mapped the MySQL data type `'set'` to `'varchar'`, however valid values are not implemented yet [wb, 2009-02-01]
 * @changes    1.0.0b7   Fixed a bug with detecting MySQL timestamp columns [wb, 2009-01-28]
 * @changes    1.0.0b6   Fixed a bug with detecting MySQL columns that accept `NULL` [wb, 2009-01-19]
 * @changes    1.0.0b5   ::setColumnInfo(): fixed a bug with not grabbing the real database schema first, made general improvements [wb, 2009-01-19]
 * @changes    1.0.0b4   Added support for MySQL binary data types, numeric data type options unsigned and zerofill, and per-column character set definitions [wb, 2009-01-17]
 * @changes    1.0.0b3   Fixed detection of the data type of MySQL timestamp columns, added support for dynamic default date/time values [wb, 2009-01-11]
 * @changes    1.0.0b2   Fixed a bug with detecting multi-column unique keys in MySQL [wb, 2009-01-03]
 * @changes    1.0.0b    The initial implementation [wb, 2007-09-25]
 */
class fSchema
{
	/**
	 * The place to cache to
	 * 
	 * @var fCache
	 */
	private $cache = NULL;
	
	/**
	 * The cache prefix to use for cache entries
	 * 
	 * @var string
	 */
	private $cache_prefix;
	
	/**
	 * The cached column info
	 * 
	 * @var array
	 */
	private $column_info = array();
	
	/**
	 * The column info to override
	 * 
	 * @var array
	 */
	private $column_info_override = array();
	
	/**
	 * A reference to an instance of the fDatabase class
	 * 
	 * @var fDatabase
	 */
	private $database = NULL;
	
	/**
	 * The databases on the current database server
	 * 
	 * @var array
	 */
	private $databases = NULL;
	
	/**
	 * The cached key info
	 * 
	 * @var array
	 */
	private $keys = array();
	
	/**
	 * The key info to override
	 * 
	 * @var array
	 */
	private $keys_override = array();
	
	/**
	 * The merged column info
	 * 
	 * @var array
	 */
	private $merged_column_info = array();
	
	/**
	 * The merged key info
	 * 
	 * @var array
	 */
	private $merged_keys = array();
	
	/**
	 * The relationships in the database
	 * 
	 * @var array
	 */
	private $relationships = array();
	
	/**
	 * The tables in the database
	 * 
	 * @var array
	 */
	private $tables = NULL;
	
	/**
	 * The version of the database being queried
	 * 
	 * This is currently only used for MSSQL and MySQL
	 * 
	 * @var integer
	 */
	private $version = NULL;
	
	
	/**
	 * Sets the database
	 * 
	 * @param  fDatabase $database  The fDatabase instance
	 * @return fSchema
	 */
	public function __construct($database)
	{
		$this->database = $database;
	}
	
	
	/**
	 * All requests that hit this method should be requests for callbacks
	 * 
	 * @internal
	 * 
	 * @param  string $method  The method to create a callback for
	 * @return callback  The callback for the method requested
	 */
	public function __get($method)
	{
		return array($this, $method);		
	}
	
	
	/**
	 * Checks to see if a column is part of a single-column `UNIQUE` key
	 * 
	 * @param  string $table   The table the column is located in
	 * @param  string $column  The column to check
	 * @return boolean  If the column is part of a single-column unique key
	 */
	private function checkForSingleColumnUniqueKey($table, $column)
	{        
		foreach ($this->merged_keys[$table]['unique'] as $key) {
			if (array($column) == $key) {
				return TRUE;
			}
		}
		if (array($column) == $this->merged_keys[$table]['primary']) {
			return TRUE;
		}
		return FALSE;
	}
	
	
	/**
	 * Clears all of the schema info out of the object and, if set, the fCache object
	 * 
	 * @internal
	 * 
	 * @return void
	 */
	public function clearCache()
	{
		$this->column_info        = array();
		$this->databases          = NULL;
		$this->keys               = array();
		$this->merged_column_info = array();
		$this->merged_keys        = array();
		$this->relationships      = array();
		$this->tables             = NULL;
		if ($this->cache) {
			$prefix = $this->makeCachePrefix();
			$this->cache->delete($prefix . 'column_info');
			$this->cache->delete($prefix . 'databases');
			$this->cache->delete($prefix . 'keys');
			$this->cache->delete($prefix . 'merged_column_info');
			$this->cache->delete($prefix . 'merged_keys');
			$this->cache->delete($prefix . 'relationships');
			$this->cache->delete($prefix . 'tables');
		}
	}
	
	
	/**
	 * Sets the schema to be cached to the fCache object specified
	 * 
	 * @param  fCache $cache      The cache to cache to
	 * @param  string $key_token  Internal use only! (this will be used in the cache key to uniquely identify the cache for this fSchema object) 
	 * @return void
	 */
	public function enableCaching($cache, $key_token=NULL)
	{
		$this->cache = $cache;
		
		if ($key_token !== NULL) {
			$this->cache_prefix = 'fSchema::' . $this->database->getType() . '::' . $key_token . '::';
		}
		$prefix = $this->makeCachePrefix();
		
		$this->column_info        = $this->cache->get($prefix . 'column_info',          array());
		$this->databases          = $this->cache->get($prefix . 'databases',            NULL);
		$this->keys               = $this->cache->get($prefix . 'keys',                 array());
		$this->version            = $this->cache->get($prefix . 'version',              NULL);
		
		if (!$this->column_info_override && !$this->keys_override) {
			$this->merged_column_info = $this->cache->get($prefix . 'merged_column_info',   array());
			$this->merged_keys        = $this->cache->get($prefix . 'merged_keys',          array());  
			$this->relationships      = $this->cache->get($prefix . 'relationships',        array());
		}
		
		$this->tables             = $this->cache->get($prefix . 'tables',               NULL);   
	}
	
	
	/**
	 * Gets the column info from the database for later access
	 * 
	 * @param  string $table  The table to fetch the column info for
	 * @return void
	 */
	private function fetchColumnInfo($table)
	{
		if (isset($this->column_info[$table])) {
			return;	
		}
		
		switch ($this->database->getType()) {
			case 'db2':
				$column_info = $this->fetchDB2ColumnInfo($table);
				break;
			
			case 'mssql':
				$column_info = $this->fetchMSSQLColumnInfo($table);
				break;
			
			case 'mysql':
				$column_info = $this->fetchMySQLColumnInfo($table);
				break;
				
			case 'oracle':
				$column_info = $this->fetchOracleColumnInfo($table);
				break;
			
			case 'postgresql':
				$column_info = $this->fetchPostgreSQLColumnInfo($table);
				break;
				
			case 'sqlite':
				$column_info = $this->fetchSQLiteColumnInfo($table);
				break;
		}
			
		if (!$column_info) {
			return;	
		}
			
		$this->column_info[$table] = $column_info;
		if ($this->cache) {
			$this->cache->set($this->makeCachePrefix() . 'column_info', $this->column_info);	
		}
	}
	
	
	/**
	 * Gets the column info from a DB2 database
	 * 
	 * @param  string $table  The table to fetch the column info for
	 * @return array  The column info for the table specified - see ::getColumnInfo() for details
	 */
	private function fetchDB2ColumnInfo($table)
	{
		$column_info = array();
		
		$schema = strtolower($this->database->getUsername());
		if (strpos($table, '.') !== FALSE) {
			list ($schema, $table) = explode('.', $table);
		}
		
		$data_type_mapping = array(
			'smallint'          => 'integer',
			'integer'           => 'integer',
			'bigint'            => 'integer',
			'timestamp'         => 'timestamp',
			'date'              => 'date',
			'time'              => 'time',
			'varchar'           => 'varchar',
			'long varchar'      => 'varchar',
			'vargraphic'        => 'varchar',
			'long vargraphic'   => 'varchar',
			'character'         => 'char',
			'graphic'           => 'char',
			'real'              => 'float',
			'decimal'           => 'float',
			'numeric'           => 'float',
			'blob'              => 'blob',
			'clob'              => 'text',
			'dbclob'            => 'text'
		);
		
		$max_min_values = array(
			'smallint'   => array('min' => new fNumber(-32768),                  'max' => new fNumber(32767)),
			'integer'    => array('min' => new fNumber(-2147483648),             'max' => new fNumber(2147483647)),
			'bigint'     => array('min' => new fNumber('-9223372036854775808'),  'max' => new fNumber('9223372036854775807'))
		);
		
		// Get the column info
		$sql = "SELECT
					LOWER(C.COLNAME) AS \"COLUMN\",
					C.TYPENAME AS TYPE,
					C.NULLS AS NULLABLE,
					C.DEFAULT,
					C.LENGTH AS MAX_LENGTH,
					C.SCALE,
					CASE WHEN C.IDENTITY = 'Y' AND (C.GENERATED = 'D' OR C.GENERATED = 'A') THEN '1' ELSE '0' END AS AUTO_INCREMENT,
					CH.TEXT AS \"CONSTRAINT\",
					C.REMARKS AS \"COMMENT\"
				FROM
					SYSCAT.COLUMNS AS C LEFT JOIN
					SYSCAT.COLCHECKS AS CC ON C.TABSCHEMA = CC.TABSCHEMA AND C.TABNAME = CC.TABNAME AND C.COLNAME = CC.COLNAME AND CC.USAGE = 'R' LEFT JOIN
					SYSCAT.CHECKS AS CH ON C.TABSCHEMA = CH.TABSCHEMA AND C.TABNAME = CH.TABNAME AND CH.TYPE = 'C' AND CH.CONSTNAME = CC.CONSTNAME
				WHERE
					C.TABSCHEMA = %s AND
					C.TABNAME = %s
				ORDER BY
					C.COLNO ASC";
		
		$result = $this->database->query($sql, strtoupper($schema), strtoupper($table));
		
		foreach ($result as $row) {
			
			$info = array();
			
			foreach ($data_type_mapping as $data_type => $mapped_data_type) {
				if (stripos($row['type'], $data_type) === 0) {
					if (isset($max_min_values[$data_type])) {
						$info['min_value'] = $max_min_values[$data_type]['min'];
						$info['max_value'] = $max_min_values[$data_type]['max'];
					}
					$info['type'] = $mapped_data_type;
					break;
				}
			}
			
			// Handle decimal places and min/max for numeric/decimals
			if (in_array(strtolower($row['type']), array('decimal', 'numeric'))) {
				$info['decimal_places'] = $row['scale'];
				$before_digits = str_pad('', $row['max_length'] - $row['scale'], '9');
				$after_digits  = str_pad('', $row['scale'], '9');
				$max_min       = $before_digits . ($after_digits ? '.' : '') . $after_digits;
				$info['min_value'] = new fNumber('-' . $max_min);
				$info['max_value'] = new fNumber($max_min);
			}
			
			if (!isset($info['type'])) {
				$info['type'] = $row['type'];
			}
			
			// Handle the special data for varchar columns
			if (in_array($info['type'], array('char', 'varchar', 'text', 'blob'))) {
				$info['max_length'] = $row['max_length'];
			}
			
			// The generally accepted practice for boolean on DB2 is a CHAR(1) with a CHECK constraint
			if ($info['type'] == 'char' && $info['max_length'] == 1 && !empty($row['constraint'])) {
				if (is_resource($row['constraint'])) {
					$row['constraint'] = stream_get_contents($row['constraint']);
				}
				if (preg_match('/^\s*' . preg_quote($row['column'], '/') . '\s+in\s+\(\s*(\'0\',\s*\'1\'|\'1\',\s*\'0\')\s*\)\s*$/i', $row['constraint'])) {
					$info['type'] = 'boolean';
					$info['max_length'] = NULL;
				}
			}
			
			// If the column has a constraint, look for valid values
			if (in_array($info['type'], array('char', 'varchar')) && !empty($row['constraint'])) {
				if (preg_match('/^\s*' . preg_quote($row['column'], '/') . '\s+in\s+\((.*?)\)\s*$/i', $row['constraint'], $match)) {
					if (preg_match_all("/(?<!')'((''|[^']+)*)'/", $match[1], $matches, PREG_PATTERN_ORDER)) {
						$info['valid_values'] = str_replace("''", "'", $matches[1]);
					}			
				}
			}
			
			// Handle auto increment
			if ($row['auto_increment']) {
				$info['auto_increment'] = TRUE;
			}
			
			// Handle default values
			if ($row['default'] !== NULL) {
				if ($row['default'] == 'NULL') {
					$info['default'] = NULL;
				} elseif (in_array($info['type'], array('timestamp', 'date', 'time')) && $row['default'][0] != "'") {
					$info['default'] = str_replace(' ', '_', $row['default']);
				} elseif (in_array($info['type'], array('char', 'varchar', 'text', 'timestamp', 'date', 'time')) ) {
					$info['default'] = substr($row['default'], 1, -1);
				} elseif ($info['type'] == 'boolean') {
					$info['default'] = (boolean) substr($row['default'], 1, -1);
				} else {
					$info['default'] = $row['default'];
				}
			}
			
			// Handle not null
			$info['not_null'] = ($row['nullable'] == 'N') ? TRUE : FALSE;
			
			$info['comment'] = $row['comment'];
			
			$column_info[$row['column']] = $info;
		}
		
		return $column_info;
	}
	
	
	/**
	 * Fetches the key info for a DB2 database
	 * 
	 * @return array  The keys arrays for every table in the database - see ::getKeys() for details
	 */
	private function fetchDB2Keys()
	{
		$keys = array();
		
		$default_schema = strtolower($this->database->getUsername());
		
		$tables = $this->getTables();
		foreach ($tables as $table) {
			$keys[$table] = array();
			$keys[$table]['primary'] = array();
			$keys[$table]['unique']  = array();
			$keys[$table]['foreign'] = array();
		}
		
		$params  = array();
		
		$sql  = "(SELECT
					 LOWER(RTRIM(R.TABSCHEMA)) AS \"SCHEMA\",
					 LOWER(R.TABNAME) AS \"TABLE\",
					 R.CONSTNAME AS CONSTRAINT_NAME,
					 'foreign' AS \"TYPE\",
					 LOWER(K.COLNAME) AS \"COLUMN\",
					 LOWER(RTRIM(R.REFTABSCHEMA)) AS FOREIGN_SCHEMA,
					 LOWER(R.REFTABNAME) AS FOREIGN_TABLE,
					 LOWER(FK.COLNAME) AS FOREIGN_COLUMN,
					 CASE R.DELETERULE WHEN 'C' THEN 'cascade' WHEN 'A' THEN 'no_action' WHEN 'R' THEN 'restrict' ELSE 'set_null' END AS ON_DELETE,
					 CASE R.UPDATERULE WHEN 'A' THEN 'no_action' WHEN 'R' THEN 'restrict' END AS ON_UPDATE,
					 K.COLSEQ
				 FROM
					 SYSCAT.REFERENCES AS R INNER JOIN 
					 SYSCAT.KEYCOLUSE AS K ON R.CONSTNAME = K.CONSTNAME AND R.TABSCHEMA = K.TABSCHEMA AND R.TABNAME = K.TABNAME INNER JOIN
					 SYSCAT.KEYCOLUSE AS FK ON R.REFKEYNAME = FK.CONSTNAME AND R.REFTABSCHEMA = FK.TABSCHEMA AND R.REFTABNAME = FK.TABNAME
				 WHERE ";
		
		$conditions = array();
		foreach ($tables as $table) {
			if (strpos($table, '.') === FALSE) {
				$table = $default_schema . '.' . $table;
			}	
			list ($schema, $table) = explode('.', strtoupper($table));
			$conditions[] = "R.TABSCHEMA = %s AND R.TABNAME = %s";
			$params[] = $schema;
			$params[] = $table;
		}
		$sql .= '((' . join(') OR( ', $conditions) . '))';
		 
		$sql .= "
				 ) UNION (
				 SELECT
					 LOWER(RTRIM(I.TABSCHEMA)) AS \"SCHEMA\",
					 LOWER(I.TABNAME) AS \"TABLE\",
					 LOWER(I.INDNAME) AS CONSTRAINT_NAME,
					 CASE I.UNIQUERULE WHEN 'U' THEN 'unique' ELSE 'primary' END AS \"TYPE\",
					 LOWER(C.COLNAME) AS \"COLUMN\",
					 NULL AS FOREIGN_SCHEMA,
					 NULL AS FOREIGN_TABLE,
					 NULL AS FOREIGN_COLUMN,
					 NULL AS ON_DELETE,
					 NULL AS ON_UPDATE,
					 C.COLSEQ
				 FROM
					 SYSCAT.INDEXES AS I INNER JOIN
					 SYSCAT.INDEXCOLUSE AS C ON I.INDSCHEMA = C.INDSCHEMA AND I.INDNAME = C.INDNAME
				 WHERE
					 I.UNIQUERULE IN ('U', 'P') AND
					 ";
		
		$conditions = array();
		foreach ($tables as $table) {
			if (strpos($table, '.') === FALSE) {
				$table = $default_schema . '.' . $table;
			}	
			list ($schema, $table) = explode('.', strtoupper($table));
			$conditions[] = "I.TABSCHEMA = %s AND I.TABNAME = %s";
			$params[] = $schema;
			$params[] = $table;
		}
		$sql .= '((' . join(') OR( ', $conditions) . '))';
		
		$sql .= "
				 )
				 ORDER BY 4, 1, 2, 3, 11";
		
		$result = $this->database->query($sql, $params);
		
		$last_name  = '';
		$last_table = '';
		$last_type  = '';
		foreach ($result as $row) {
			
			if ($row['constraint_name'] != $last_name) {
				
				if ($last_name) {
					if ($last_type == 'foreign' || $last_type == 'unique') {
						$keys[$last_table][$last_type][] = $temp;
					} else {
						$keys[$last_table][$last_type] = $temp;
					}
				}
				
				$temp = array();
				if ($row['type'] == 'foreign') {
					
					$temp['column']         = $row['column'];
					$temp['foreign_table']  = $row['foreign_table'];
					if ($row['foreign_schema'] != $default_schema) {
						$temp['foreign_table'] = $row['foreign_schema'] . '.' . $temp['foreign_table'];
					}
					$temp['foreign_column'] = $row['foreign_column'];
					$temp['on_delete']      = 'no_action';
					$temp['on_update']      = 'no_action';
					
					if (!empty($row['on_delete'])) {
						$temp['on_delete'] = $row['on_delete'];
					}
					if (!empty($row['on_update'])) {
						$temp['on_update'] = $row['on_update'];
					}
					
				} else {
					$temp[] = $row['column'];
				}
				
				$last_table = $row['table'];
				if ($row['schema'] != $default_schema) {
					$last_table = $row['schema'] . '.' . $last_table;
				}
				$last_name  = $row['constraint_name'];
				$last_type  = $row['type'];
				
			} else {
				$temp[] = $row['column'];
			}
		}
		
		if (isset($temp)) {
			if ($last_type == 'foreign' || $last_type == 'unique') {
				$keys[$last_table][$last_type][] = $temp;
			} else {
				$keys[$last_table][$last_type] = $temp;
			}
		}
		
		return $keys;
	}
	
	
	/**
	 * Gets the `PRIMARY KEY`, `FOREIGN KEY` and `UNIQUE` key constraints from the database
	 * 
	 * @return void
	 */
	private function fetchKeys()
	{
		if ($this->keys) {
			return;	
		}
		
		switch ($this->database->getType()) {
			case 'db2':
				$keys = $this->fetchDB2Keys();
				break;
			
			case 'mssql':
				$keys = $this->fetchMSSQLKeys();
				break;
				
			case 'mysql':
				$keys = $this->fetchMySQLKeys();
				break;
				
			case 'oracle':
				$keys = $this->fetchOracleKeys();
				break;
			
			case 'postgresql':
				$keys = $this->fetchPostgreSQLKeys();
				break;
			
			case 'sqlite':
				$keys = $this->fetchSQLiteKeys();
				break;
		}
		
		$this->keys = $keys;
		if ($this->cache) {
			$this->cache->set($this->makeCachePrefix() . 'keys', $this->keys);	
		}
	}
	
	
	/**
	 * Gets the column info from a MSSQL database
	 * 
	 * @param  string $table  The table to fetch the column info for
	 * @return array  The column info for the table specified - see ::getColumnInfo() for details
	 */
	private function fetchMSSQLColumnInfo($table)
	{
		$column_info = array();
		
		$schema = 'dbo';
		if (strpos($table, '.') !== FALSE) {
			list ($schema, $table) = explode('.', $table);
		}
		
		$data_type_mapping = array(
			'bit'               => 'boolean',
			'tinyint'           => 'integer',
			'smallint'          => 'integer',
			'int'               => 'integer',
			'bigint'            => 'integer',
			'timestamp'         => 'integer',
			'datetime'          => 'timestamp',
			'smalldatetime'     => 'timestamp',
			'datetime2'         => 'timestamp',
			'date'              => 'date',
			'time'              => 'time',
			'varchar'           => 'varchar',
			'nvarchar'          => 'varchar',
			'uniqueidentifier'  => 'varchar',
			'char'              => 'char',
			'nchar'             => 'char',
			'real'              => 'float',
			'float'             => 'float',
			'money'             => 'float',
			'smallmoney'        => 'float',
			'decimal'           => 'float',
			'numeric'           => 'float',
			'binary'            => 'blob',
			'varbinary'         => 'blob',
			'image'             => 'blob',
			'text'              => 'text',
			'ntext'             => 'text',
			'xml'               => 'text'
		);
		
		$max_min_values = array(
			'tinyint'    => array('min' => new fNumber(0),                       'max' => new fNumber(255)),
			'smallint'   => array('min' => new fNumber(-32768),                  'max' => new fNumber(32767)),
			'int'        => array('min' => new fNumber(-2147483648),             'max' => new fNumber(2147483647)),
			'bigint'     => array('min' => new fNumber('-9223372036854775808'),  'max' => new fNumber('9223372036854775807')),
			'smallmoney' => array('min' => new fNumber('-214748.3648'),          'max' => new fNumber('214748.3647')),
			'money'      => array('min' => new fNumber('-922337203685477.5808'), 'max' => new fNumber('922337203685477.5807'))
		);
		
		if (!$this->version) {
			$this->version = (int) $this->database->query("SELECT CAST(SERVERPROPERTY('productversion') AS VARCHAR(20))")->fetchScalar();
			if ($this->cache) {
				$this->cache->set($this->makeCachePrefix() . 'version', $this->version);
			}
		}
		
		// Get the column info
		$sql = "SELECT
						c.column_name              AS 'column',
						c.data_type                AS 'type',
						c.is_nullable              AS nullable,
						c.column_default           AS 'default',
						c.character_maximum_length AS max_length,
						c.numeric_precision        AS precision,
						c.numeric_scale            AS decimal_places,
						CASE
							WHEN
							  COLUMNPROPERTY(OBJECT_ID(QUOTENAME(c.table_schema) + '.' + QUOTENAME(c.table_name)), c.column_name, 'IsIdentity') = 1 AND
							  OBJECTPROPERTY(OBJECT_ID(QUOTENAME(c.table_schema) + '.' + QUOTENAME(c.table_name)), 'IsMSShipped') = 0
							THEN '1'
							ELSE '0'
						  END AS auto_increment,
						cc.check_clause AS 'constraint',
						CAST(ex.value AS VARCHAR(7500)) AS 'comment'
					FROM
						INFORMATION_SCHEMA.COLUMNS AS c LEFT JOIN
						INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE AS ccu ON c.column_name = ccu.column_name AND c.table_name = ccu.table_name AND c.table_catalog = ccu.table_catalog LEFT JOIN
						INFORMATION_SCHEMA.CHECK_CONSTRAINTS AS cc ON ccu.constraint_name = cc.constraint_name AND ccu.constraint_catalog = cc.constraint_catalog";
		
		if ($this->version < 9) {
			$sql .= " LEFT JOIN sysproperties AS ex ON ex.id = OBJECT_ID(QUOTENAME(c.table_schema) + '.' + QUOTENAME(c.table_name)) AND ex.smallid = c.ordinal_position AND ex.name = 'MS_Description' AND OBJECTPROPERTY(OBJECT_ID(QUOTENAME(c.table_schema) + '.' + QUOTENAME(c.table_name)), 'IsMsShipped') = 0 ";
		} else {
			$sql .= " LEFT JOIN SYS.EXTENDED_PROPERTIES AS ex ON ex.major_id = OBJECT_ID(QUOTENAME(c.table_schema) + '.' + QUOTENAME(c.table_name)) AND ex.minor_id = c.ordinal_position AND ex.name = 'MS_Description' AND OBJECTPROPERTY(OBJECT_ID(QUOTENAME(c.table_schema) + '.' + QUOTENAME(c.table_name)), 'IsMsShipped') = 0 ";
		}
		
		$sql .= "
					WHERE
						c.table_name = %s AND
						c.table_schema = %s AND
						c.table_catalog = DB_NAME()";
		
		$result = $this->database->query($sql, $table, $schema);
		
		foreach ($result as $row) {
			
			$info = array();
			
			foreach ($data_type_mapping as $data_type => $mapped_data_type) {
				if (stripos($row['type'], $data_type) === 0) {
					if (isset($max_min_values[$data_type])) {
						$info['min_value'] = $max_min_values[$data_type]['min'];
						$info['max_value'] = $max_min_values[$data_type]['max'];
					}
					$info['type'] = $mapped_data_type;
					break;
				}
			}
			
			// Handle decimal places and min/max for numeric/decimals
			if (in_array(strtolower($row['type']), array('decimal', 'numeric'))) {
				$info['decimal_places'] = $row['decimal_places'];
				$before_digits = str_pad('', $row['precision'] - $row['decimal_places'], '9');
				$after_digits  = str_pad('', $row['decimal_places'], '9');
				$max_min       = $before_digits . ($after_digits ? '.' : '') . $after_digits;
				$info['min_value'] = new fNumber('-' . $max_min);
				$info['max_value'] = new fNumber($max_min);
			}
			
			if (!isset($info['type'])) {
				$info['type'] = $row['type'];
			}
			
			// Handle decimal places for money/smallmoney
			if (in_array($row['type'], array('money', 'smallmoney'))) {
				$info['decimal_places'] = 2;
			}
			
			// Handle the special data for varchar columns
			if (in_array($info['type'], array('char', 'varchar', 'text', 'blob'))) {
				if ($row['type'] == 'uniqueidentifier') {
					$row['max_length'] = 32;
				} elseif ($row['max_length'] == -1) {
					$row['max_length'] = $row['type'] == 'nvarchar' ? 1073741823 : 2147483647;
				}
				$info['max_length'] = $row['max_length'];
			}
			
			// If the column has a constraint, look for valid values
			if (in_array($info['type'], array('char', 'varchar')) && !empty($row['constraint'])) {
				if (preg_match('#^\(((?:(?: OR )?\[[^\]]+\]\s*=\s*\'(?:\'\'|[^\']+)+\')+)\)$#D', $row['constraint'], $matches)) {
					$valid_values = explode(' OR ', $matches[1]);
					foreach ($valid_values as $key => $value) {
						$value = preg_replace('#^\s*\[' . preg_quote($row['column'], '#') . '\]\s*=\s*\'(.*)\'\s*$#', '\1', $value);
						$valid_values[$key] = str_replace("''", "'", $value);
					}
					// SQL Server turns CHECK constraint values into a reversed list, so we fix it here
					$info['valid_values'] = array_reverse($valid_values);
				}
			}
			
			// Handle auto increment
			if ($row['auto_increment']) {
				$info['auto_increment'] = TRUE;
			}
			
			// Handle default values
			if ($row['default'] !== NULL) {
				if ($row['default'] == '(getdate())') {
					$info['default'] = 'CURRENT_TIMESTAMP';
				} elseif (in_array($info['type'], array('char', 'varchar', 'text', 'timestamp')) ) {
					$info['default'] = substr($row['default'], 2, -2);
				} elseif ($info['type'] == 'boolean') {
					$info['default'] = (boolean) substr($row['default'], 2, -2);
				} elseif (in_array($info['type'], array('integer', 'float')) ) {
					$info['default'] = str_replace(array('(', ')'), '', $row['default']);
				} else {
					$info['default'] = pack('H*', substr($row['default'], 3, -1));
				}
			}
			
			// Handle not null
			$info['not_null'] = ($row['nullable'] == 'NO') ? TRUE : FALSE;
			
			$info['comment'] = $row['comment'];
			
			$column_info[$row['column']] = $info;
		}
		
		return $column_info;
	}
	
	
	/**
	 * Fetches the key info for an MSSQL database
	 * 
	 * @return array  The key info arrays for every table in the database - see ::getKeys() for details
	 */
	private function fetchMSSQLKeys()
	{
		$keys = array();
		
		$tables   = $this->getTables();
		foreach ($tables as $table) {
			$keys[$table] = array();
			$keys[$table]['primary'] = array();
			$keys[$table]['unique']  = array();
			$keys[$table]['foreign'] = array();
		}
		
		$sql  = "SELECT
						c.table_schema AS \"schema\",
						c.table_name AS \"table\",
						kcu.constraint_name AS constraint_name,
						CASE c.constraint_type
							WHEN 'PRIMARY KEY' THEN 'primary'
							WHEN 'FOREIGN KEY' THEN 'foreign'
							WHEN 'UNIQUE' THEN 'unique'
						END AS 'type',
						kcu.column_name AS 'column',
						ccu.table_schema AS foreign_schema,
						ccu.table_name AS foreign_table,
						ccu.column_name AS foreign_column,
						REPLACE(LOWER(rc.delete_rule), ' ', '_') AS on_delete,
						REPLACE(LOWER(rc.update_rule), ' ', '_') AS on_update
					FROM
						INFORMATION_SCHEMA.TABLE_CONSTRAINTS AS c INNER JOIN
						INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS kcu ON c.table_name = kcu.table_name AND c.constraint_name = kcu.constraint_name LEFT JOIN
						INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS AS rc ON c.constraint_name = rc.constraint_name LEFT JOIN
						INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE AS ccu ON ccu.constraint_name = rc.unique_constraint_name
					WHERE
						c.constraint_catalog = DB_NAME() AND
						c.table_name != 'sysdiagrams'
					ORDER BY
						LOWER(c.table_schema),
						LOWER(c.table_name),
						c.constraint_type,
						LOWER(kcu.constraint_name),
						kcu.ordinal_position,
						LOWER(kcu.column_name)";
		
		$result = $this->database->query($sql);
		
		$last_name  = '';
		$last_table = '';
		$last_type  = '';
		foreach ($result as $row) {
			
			if ($row['constraint_name'] != $last_name) {
				
				if ($last_name) {
					if ($last_type == 'foreign' || $last_type == 'unique') {
						if (!isset($keys[$last_table][$last_type])) {
							$keys[$last_table][$last_type] = array();		
						}
						$keys[$last_table][$last_type][] = $temp;
					} else {
						$keys[$last_table][$last_type] = $temp;
					}
				}
				
				$temp = array();
				if ($row['type'] == 'foreign') {
					
					$temp['column']         = $row['column'];
					$temp['foreign_table']  = $row['foreign_table'];
					if ($row['foreign_schema'] != 'dbo') {
						 $temp['foreign_table'] = $row['foreign_schema'] . '.' . $temp['foreign_table'];	
					}
					$temp['foreign_column'] = $row['foreign_column'];
					$temp['on_delete']      = 'no_action';
					$temp['on_update']      = 'no_action';
					if (!empty($row['on_delete'])) {
						$temp['on_delete'] = $row['on_delete'];
					}
					if (!empty($row['on_update'])) {
						$temp['on_update'] = $row['on_update'];
					}
					
				} else {
					$temp[] = $row['column'];
				}
				
				$last_table = $row['table'];
				if ($row['schema'] != 'dbo') {
					$last_table = $row['schema'] . '.' . $last_table;	
				}
				$last_name  = $row['constraint_name'];
				$last_type  = $row['type'];
				
			} else {
				$temp[] = $row['column'];
			}
		}
		
		if (isset($temp)) {
			if ($last_type == 'foreign' || $last_type == 'unique') {
				if (!isset($keys[$last_table][$last_type])) {
					$keys[$last_table][$last_type] = array();		
				}
				$keys[$last_table][$last_type][] = $temp;
			} else {
				$keys[$last_table][$last_type] = $temp;
			}
		}
		
		return $keys;
	}
	
	
	/**
	 * Gets the column info from a MySQL database
	 * 
	 * @param  string $table  The table to fetch the column info for
	 * @return array  The column info for the table specified - see ::getColumnInfo() for details
	 */
	private function fetchMySQLColumnInfo($table)
	{
		$data_type_mapping = array(
			'tinyint'			=> 'integer',
			'smallint'			=> 'integer',
			'mediumint'         => 'integer',
			'int'				=> 'integer',
			'bigint'			=> 'integer',
			'datetime'			=> 'timestamp',
			'timestamp'			=> 'timestamp',
			'date'				=> 'date',
			'time'				=> 'time',
			'enum'				=> 'varchar',
			'set'               => 'varchar',
			'varchar'			=> 'varchar',
			'char'				=> 'char',
			'float'				=> 'float',
			'double'			=> 'float',
			'decimal'			=> 'float',
			'binary'            => 'blob',
			'varbinary'         => 'blob',
			'tinyblob'			=> 'blob',
			'blob'				=> 'blob',
			'mediumblob'		=> 'blob',
			'longblob'			=> 'blob',
			'tinytext'			=> 'text',
			'text'				=> 'text',
			'mediumtext'		=> 'text',
			'longtext'			=> 'text'
		);
		
		$max_min_values = array(
			'tinyint'             => array('min' => new fNumber(-128),                    'max' => new fNumber(127)),
			'unsigned tinyint'    => array('min' => new fNumber(0),                       'max' => new fNumber(255)),
			'smallint'            => array('min' => new fNumber(-32768),                  'max' => new fNumber(32767)),
			'unsigned smallint'   => array('min' => new fNumber(0),                       'max' => new fNumber(65535)),
			'mediumint'           => array('min' => new fNumber(-8388608),                'max' => new fNumber(8388607)),
			'unsigned mediumint'  => array('min' => new fNumber(0),                       'max' => new fNumber(16777215)),
			'int'                 => array('min' => new fNumber(-2147483648),             'max' => new fNumber(2147483647)),
			'unsigned int'        => array('min' => new fNumber(0),                       'max' => new fNumber('4294967295')),
			'bigint'              => array('min' => new fNumber('-9223372036854775808'),  'max' => new fNumber('9223372036854775807')),
			'unsigned bigint'     => array('min' => new fNumber(0),                       'max' => new fNumber('18446744073709551615'))
		);
		
		$column_info = array();
		
		$result     = $this->database->query('SHOW CREATE TABLE %r', $table);
		
		try {
			$row        = $result->fetchRow();
			$create_sql = $row['Create Table'];
		} catch (fNoRowsException $e) {
			return array();
		}
		
		preg_match_all('#(?<=,|\()\s+(?:"|\`)(\w+)(?:"|\`)\s+(?:([a-z]+)(?:\(([^)]+)\))?( unsigned)?(?: zerofill)?)(?: character set [^ ]+)?(?: collate [^ ]+)?(?: NULL)?( NOT NULL)?(?: DEFAULT ((?:[^, \']*|\'(?:\'\'|[^\']+)*\')))?( auto_increment)?( COMMENT \'(?:\'\'|[^\']+)*\')?( ON UPDATE CURRENT_TIMESTAMP)?\s*(?:,|\s*(?=\)))#mi', $create_sql, $matches, PREG_SET_ORDER);
		
		foreach ($matches as $match) {
			
			$info = array();
			
			foreach ($data_type_mapping as $data_type => $mapped_data_type) {
				if (stripos($match[2], $data_type) === 0) {
					if ($match[2] == 'tinyint' && $match[3] == 1) {
						$mapped_data_type = 'boolean';
					
					} elseif (preg_match('#((?:unsigned )?(?:tiny|small|medium|big)?int)#', (isset($match[4]) ? $match[4] . ' ' : '') . $data_type, $int_match)) {
						if (isset($max_min_values[$int_match[1]])) {
							$info['min_value'] = $max_min_values[$int_match[1]]['min'];
							$info['max_value'] = $max_min_values[$int_match[1]]['max'];	
						}
					}
					
					$info['type'] = $mapped_data_type;
					break;
				}
			}
			if (!isset($info['type'])) {
				$info['type'] = preg_replace('#^([a-z ]+).*$#iD', '\1', $match[2]);
			}
			
			switch ($match[2]) {
				case 'tinyblob':
				case 'tinytext':
					$info['max_length'] = 255;
					break;
				
				case 'blob':
				case 'text':
					$info['max_length'] = 65535;
					break;
				
				case 'mediumblob':
				case 'mediumtext':
					$info['max_length'] = 16777215;
					break;
				
				case 'longblob':
				case 'longtext':
					$info['max_length'] = 4294967295;
					break;
			}
		
			if (stripos($match[2], 'enum') === 0) {
				$info['valid_values'] = preg_replace("/^'|'\$/D", '', explode(",", $match[3]));
				$match[3] = 0;
				foreach ($info['valid_values'] as $valid_value) {
					if (strlen(utf8_decode($valid_value)) > $match[3]) {
						$match[3] = strlen(utf8_decode($valid_value));
					}
				}
			}
			
			// The set data type is currently only supported as a varchar
			// with a max length of all valid values concatenated by ,s
			if (stripos($match[2], 'set') === 0) {
				$values = preg_replace("/^'|'\$/D", '', explode(",", $match[3]));
				$match[3] = strlen(join(',', $values));
			}
			
			// Type specific information
			if (in_array($info['type'], array('char', 'varchar'))) {
				$info['max_length'] = $match[3];
			}
			
			// Grab the number of decimal places
			if (stripos($match[2], 'decimal') === 0) {
				if (preg_match('#^\s*(\d+)\s*,\s*(\d+)\s*$#D', $match[3], $data_type_info)) {
					$info['decimal_places'] = $data_type_info[2];
					$before_digits = str_pad('', $data_type_info[1] - $info['decimal_places'], '9');
					$after_digits  = str_pad('', $info['decimal_places'], '9');
					$max_min       = $before_digits . ($after_digits ? '.' : '') . $after_digits;
					$info['min_value'] = new fNumber('-' . $max_min);
					$info['max_value'] = new fNumber($max_min);
				}
			}
			
			// Not null
			$info['not_null'] = (!empty($match[5])) ? TRUE : FALSE;
		
			// Default values
			if (!empty($match[6]) && $match[6] != 'NULL') {
				$info['default'] = preg_replace("/^'|'\$/D", '', $match[6]);
			}
			
			if ($info['type'] == 'boolean' && isset($info['default'])) {
				$info['default'] = (boolean) $info['default'];
			}
		
			// Auto increment fields
			if (!empty($match[7])) {
				$info['auto_increment'] = TRUE;
			}
			
			// Column comments
			if (!empty($match[8])) {
				$info['comment'] = str_replace("''", "'", substr($match[8], 10, -1));
			}
		
			$column_info[$match[1]] = $info;
		}
		
		return $column_info;
	}
	
	
	/**
	 * Fetches the keys for a MySQL database
	 * 
	 * @return array  The keys arrays for every table in the database - see ::getKeys() for details
	 */
	private function fetchMySQLKeys()
	{
		$tables   = $this->getTables();
		$keys = array();
		
		foreach ($tables as $table) {
			
			$keys[$table] = array();
			$keys[$table]['primary'] = array();
			$keys[$table]['foreign'] = array();
			$keys[$table]['unique']  = array();
			
			$result = $this->database->query('SHOW CREATE TABLE %r', $table);
			$row    = $result->fetchRow();
			
			// Primary keys
			preg_match_all('/PRIMARY KEY\s+\("(.*?)"\),?\n/U', $row['Create Table'], $matches, PREG_SET_ORDER);
			if (!empty($matches)) {
				$keys[$table]['primary'] = explode('","', $matches[0][1]);
			}
			
			// Unique keys
			preg_match_all('/UNIQUE KEY\s+"([^"]+)"\s+\("(.*?)"\),?\n/U', $row['Create Table'], $matches, PREG_SET_ORDER);
			foreach ($matches as $match) {
				$keys[$table]['unique'][] = explode('","', $match[2]);
			}
			
			// Foreign keys
			preg_match_all('#FOREIGN KEY \("([^"]+)"\) REFERENCES "([^"]+)" \("([^"]+)"\)(?:\sON\sDELETE\s(SET\sNULL|SET\sDEFAULT|CASCADE|NO\sACTION|RESTRICT))?(?:\sON\sUPDATE\s(SET\sNULL|SET\sDEFAULT|CASCADE|NO\sACTION|RESTRICT))?#', $row['Create Table'], $matches, PREG_SET_ORDER);
			foreach ($matches as $match) {
				$temp = array('column'         => $match[1],
							  'foreign_table'  => $match[2],
							  'foreign_column' => $match[3],
							  'on_delete'      => 'no_action',
							  'on_update'      => 'no_action');
				if (!empty($match[4])) {
					$temp['on_delete'] = strtolower(str_replace(' ', '_', $match[4]));
				}
				if (!empty($match[5])) {
					$temp['on_update'] = strtolower(str_replace(' ', '_', $match[5]));
				}
				$keys[$table]['foreign'][] = $temp;
			}
		}
		
		return $keys;
	}
	
	
	/**
	 * Gets the column info from an Oracle database
	 * 
	 * @param  string $table  The table to fetch the column info for
	 * @return array  The column info for the table specified - see ::getColumnInfo() for details
	 */
	private function fetchOracleColumnInfo($table)
	{
		$table = strtoupper($table);
		
		$schema = strtoupper($this->database->getUsername());
		if (strpos($table, '.') !== FALSE) {
			list ($schema, $table) = explode('.', $table);
		}
		
		$column_info = array();
		
		$data_type_mapping = array(
			'boolean'			=> 'boolean',
			'number'            => 'integer',
			'integer'			=> 'integer',
			'timestamp'			=> 'timestamp',
			'date'				=> 'date',
			'varchar2'          => 'varchar',
			'nvarchar2'			=> 'varchar',
			'char'              => 'char',
			'nchar'             => 'char',
			'float'				=> 'float',
			'binary_float'      => 'float',
			'binary_double'     => 'float',
			'blob'				=> 'blob',
			'bfile'             => 'varchar',
			'clob'				=> 'text',
			'nclob'             => 'text'
		);
		
		$sql = "SELECT
						LOWER(ATC.COLUMN_NAME) COLUMN_NAME,
						CASE
							WHEN
								ATC.DATA_TYPE = 'NUMBER' AND
								ATC.DATA_PRECISION IS NULL AND
								ATC.DATA_SCALE = 0
							THEN
								'integer'
							WHEN
								ATC.DATA_TYPE = 'NUMBER' AND
								ATC.DATA_PRECISION = 1 AND
								ATC.DATA_SCALE = 0
							THEN
								'boolean'
							WHEN
								ATC.DATA_TYPE = 'NUMBER' AND
								ATC.DATA_PRECISION IS NOT NULL AND
								ATC.DATA_SCALE != 0 AND
								ATC.DATA_SCALE IS NOT NULL
							THEN
								'float'
							ELSE
								LOWER(ATC.DATA_TYPE)
							END DATA_TYPE,
						CASE
							WHEN
								ATC.CHAR_LENGTH <> 0
							THEN
								ATC.CHAR_LENGTH
							WHEN
								ATC.DATA_TYPE = 'NUMBER' AND
								ATC.DATA_PRECISION != 1 AND
								ATC.DATA_SCALE != 0	AND
								ATC.DATA_PRECISION IS NOT NULL
							THEN
								ATC.DATA_SCALE
							ELSE
								NULL
							END LENGTH,
						ATC.DATA_PRECISION PRECISION,
						ATC.NULLABLE,
						ATC.DATA_DEFAULT,
						AC.SEARCH_CONDITION CHECK_CONSTRAINT,
						ACCM.COMMENTS
					FROM
						ALL_TAB_COLUMNS ATC LEFT JOIN
						ALL_CONS_COLUMNS ACC ON
							ATC.OWNER = ACC.OWNER AND
							ATC.COLUMN_NAME = ACC.COLUMN_NAME AND
							ATC.TABLE_NAME = ACC.TABLE_NAME AND
							ACC.POSITION IS NULL LEFT JOIN
						ALL_CONSTRAINTS AC ON
							AC.OWNER = ACC.OWNER AND
							AC.CONSTRAINT_NAME = ACC.CONSTRAINT_NAME AND
							AC.CONSTRAINT_TYPE = 'C' AND
							AC.STATUS = 'ENABLED' LEFT JOIN
						ALL_COL_COMMENTS ACCM ON
							ATC.OWNER = ACCM.OWNER AND
							ATC.COLUMN_NAME = ACCM.COLUMN_NAME AND
							ATC.TABLE_NAME = ACCM.TABLE_NAME
					WHERE
						ATC.TABLE_NAME = %s AND
						ATC.OWNER = %s
					ORDER BY
						ATC.TABLE_NAME ASC,
						ATC.COLUMN_ID ASC";
		
		$result = $this->database->query($sql, $table, $schema);
		
		foreach ($result as $row) {
			
			$column = $row['column_name'];
			
			// Since Oracle stores check constraints in LONG columns, it is
			// not possible to check or modify the constraints in SQL which
			// ends up causing multiple rows with duplicate data except for
			// the check constraint
			$duplicate = FALSE;
			
			if (isset($column_info[$column])) {
				$info = $column_info[$column];
				$duplicate = TRUE;
			} else {
				$info = array();
			}
			
			if (!$duplicate) {
				// Get the column type
				foreach ($data_type_mapping as $data_type => $mapped_data_type) {
					if (stripos($row['data_type'], $data_type) === 0) {
						$info['type'] = $mapped_data_type;
						break;
					}
				}
				
				if (!isset($info['type'])) {
					$info['type'] = $row['data_type'];
				}
				
				if (in_array($info['type'], array('blob', 'text'))) {
					$info['max_length'] = 4294967295;
				}
				
				if ($row['data_type'] == 'float' && $row['precision']) {
					$row['length'] = (int) $row['length'];
					$before_digits = str_pad('', $row['precision'] - $row['length'], '9');
					$after_digits  = str_pad('', $row['length'], '9');
					$max_min       = $before_digits . ($after_digits ? '.' : '') . $after_digits;
					$info['min_value'] = new fNumber('-' . $max_min);
					$info['max_value'] = new fNumber($max_min);	
				}
				
				// Handle the length of decimal/numeric fields
				if ($info['type'] == 'float' && $row['length']) {
					$info['decimal_places'] = (int) $row['length'];
				}
				
				// Handle the special data for varchar fields
				if (in_array($info['type'], array('char', 'varchar'))) {
					$info['max_length'] = (int) $row['length'];
				}
			}
			
			// Handle check constraints that are just simple lists
			if (in_array($info['type'], array('varchar', 'char')) && $row['check_constraint']) {
				if (preg_match('/^\s*' . preg_quote($column, '/') . '\s+in\s+\((.*?)\)\s*$/i', $row['check_constraint'], $match)) {
					if (preg_match_all("/(?<!')'((''|[^']+)*)'/", $match[1], $matches, PREG_PATTERN_ORDER)) {
						$info['valid_values'] = str_replace("''", "'", $matches[1]);
					}			
				}
			}
			
			if (!$duplicate) {
				// Handle default values
				if ($row['data_default'] !== NULL) {
					if (in_array($info['type'], array('date', 'time', 'timestamp')) && $row['data_default'][0] != "'") {
						$info['default'] = trim(preg_replace('#^SYS#', 'CURRENT_', $row['data_default']));
						
					} elseif (in_array($info['type'], array('char', 'varchar', 'text', 'date', 'time', 'timestamp'))) {
						$info['default'] = str_replace("''", "'", substr(trim($row['data_default']), 1, -1));
						
					} elseif ($info['type'] == 'boolean') {
						$info['default'] = (boolean) trim($row['data_default']);
						
					} elseif (in_array($info['type'], array('integer', 'float'))) {
						$info['default'] = trim($row['data_default']);
						
					} else {
						$info['default'] = $row['data_default'];
					}
				}
			
				// Not null values
				$info['not_null'] = ($row['nullable'] == 'N') ? TRUE : FALSE;
				
				$info['comment'] = $row['comments'];
			}
			
			$column_info[$column] = $info;
		}
		
		$sql = "SELECT
						TRIGGER_BODY
					FROM
						ALL_TRIGGERS
					WHERE
						TRIGGERING_EVENT LIKE 'INSERT%' AND
						STATUS = 'ENABLED' AND
						TRIGGER_NAME NOT LIKE 'BIN\$%' AND
						TABLE_NAME = %s AND
						OWNER = %s";
						
		foreach ($this->database->query($sql, $table, $schema) as $row) {
			if (preg_match('#SELECT\s+(["\w.]+).nextval\s+INTO\s+:new\.(\w+)\s+FROM\s+dual#i', $row['trigger_body'], $matches)) {
				$column = strtolower($matches[2]);
				$column_info[$column]['auto_increment'] = TRUE;
			}
		}
		
		return $column_info;
	}
	
	
	/**
	 * Fetches the key info for an Oracle database
	 * 
	 * @return array  The keys arrays for every table in the database - see ::getKeys() for details
	 */
	private function fetchOracleKeys()
	{
		$keys = array();
		
		$default_schema = strtolower($this->database->getUsername());
		
		$tables = $this->getTables();
		foreach ($tables as $table) {
			$keys[$table] = array();
			$keys[$table]['primary'] = array();
			$keys[$table]['unique']  = array();
			$keys[$table]['foreign'] = array();
		}
		
		$params = array();
		
		$sql  = "SELECT
						 LOWER(AC.OWNER) \"SCHEMA\",
						 LOWER(AC.TABLE_NAME) \"TABLE\",
						 AC.CONSTRAINT_NAME CONSTRAINT_NAME,
						 CASE AC.CONSTRAINT_TYPE
							 WHEN 'P' THEN 'primary'
							 WHEN 'R' THEN 'foreign'
							 WHEN 'U' THEN 'unique'
							 END TYPE,
						 LOWER(ACC.COLUMN_NAME) \"COLUMN\",
						 LOWER(FKC.OWNER) FOREIGN_SCHEMA,
						 LOWER(FKC.TABLE_NAME) FOREIGN_TABLE,
						 LOWER(FKC.COLUMN_NAME) FOREIGN_COLUMN,
						 CASE WHEN FKC.TABLE_NAME IS NOT NULL THEN REPLACE(LOWER(AC.DELETE_RULE), ' ', '_') ELSE NULL END ON_DELETE
					 FROM
						 ALL_CONSTRAINTS AC INNER JOIN
						 ALL_CONS_COLUMNS ACC ON AC.CONSTRAINT_NAME = ACC.CONSTRAINT_NAME AND AC.OWNER = ACC.OWNER LEFT JOIN
						 ALL_CONSTRAINTS FK ON AC.R_CONSTRAINT_NAME = FK.CONSTRAINT_NAME AND AC.OWNER = FK.OWNER LEFT JOIN
						 ALL_CONS_COLUMNS FKC ON FK.CONSTRAINT_NAME = FKC.CONSTRAINT_NAME AND FK.OWNER = FKC.OWNER
					 WHERE
						 AC.CONSTRAINT_TYPE IN ('U', 'P', 'R') AND ";
		
		$conditions = array();
		foreach ($tables as $table) {
			if (strpos($table, '.') === FALSE) {
				$table = $default_schema . '.' . $table;
			}	
			list ($schema, $table) = explode('.', strtoupper($table));
			$conditions[] = "AC.OWNER = %s AND AC.TABLE_NAME = %s";
			$params[] = $schema;
			$params[] = $table;
		}
		$sql .= '((' . join(') OR( ', $conditions) . '))';
		
		$sql .= " ORDER BY
						 AC.OWNER ASC,
						 AC.TABLE_NAME ASC,
						 AC.CONSTRAINT_TYPE ASC,
						 AC.CONSTRAINT_NAME ASC,
						 ACC.POSITION ASC";
		
		$result = $this->database->query($sql, $params);
		
		$last_name  = '';
		$last_table = '';
		$last_type  = '';
		foreach ($result as $row) {
			
			if ($row['constraint_name'] != $last_name) {
				
				if ($last_name) {
					if ($last_type == 'foreign' || $last_type == 'unique') {
						$keys[$last_table][$last_type][] = $temp;
					} else {
						$keys[$last_table][$last_type] = $temp;
					}
				}
				
				$temp = array();
				if ($row['type'] == 'foreign') {
					
					$temp['column']         = $row['column'];
					$temp['foreign_table']  = $row['foreign_table'];
					if ($row['foreign_schema'] != $default_schema) {
						$temp['foreign_table'] = $row['foreign_schema'] . '.' . $temp['foreign_table'];
					}
					$temp['foreign_column'] = $row['foreign_column'];
					$temp['on_delete']      = 'no_action';
					$temp['on_update']      = 'no_action';
					
					if (!empty($row['on_delete'])) {
						$temp['on_delete'] = $row['on_delete'];
					}
					
				} else {
					$temp[] = $row['column'];
				}
				
				$last_table = $row['table'];
				if ($row['schema'] != $default_schema) {
					$last_table = $row['schema'] . '.' . $last_table;
				}
				$last_name  = $row['constraint_name'];
				$last_type  = $row['type'];
				
			} else {
				$temp[] = $row['column'];
			}
		}
		
		if (isset($temp)) {
			if ($last_type == 'foreign' || $last_type == 'unique') {
				$keys[$last_table][$last_type][] = $temp;
			} else {
				$keys[$last_table][$last_type] = $temp;
			}
		}
		
		return $keys;
	}
	
	
	/**
	 * Gets the column info from a PostgreSQL database
	 * 
	 * @param  string $table  The table to fetch the column info for
	 * @return array  The column info for the table specified - see ::getColumnInfo() for details
	 */
	private function fetchPostgreSQLColumnInfo($table)
	{
		$column_info = array();
		
		$schema = 'public';
		if (strpos($table, '.') !== FALSE) {
			list ($schema, $table) = explode('.', $table);	
		}
		
		$data_type_mapping = array(
			'boolean'			=> 'boolean',
			'smallint'			=> 'integer',
			'int'				=> 'integer',
			'bigint'			=> 'integer',
			'serial'			=> 'integer',
			'bigserial'			=> 'integer',
			'timestamp'			=> 'timestamp',
			'date'				=> 'date',
			'time'				=> 'time',
			'uuid'              => 'varchar',
			'character varying'	=> 'varchar',
			'character'			=> 'char',
			'real'				=> 'float',
			'double'			=> 'float',
			'numeric'			=> 'float',
			'bytea'				=> 'blob',
			'text'				=> 'text',
			'mediumtext'		=> 'text',
			'longtext'			=> 'text'
		);
		
		$max_min_values = array(
			'smallint'  => array('min' => new fNumber(-32768),                  'max' => new fNumber(32767)),
			'int'       => array('min' => new fNumber(-2147483648),             'max' => new fNumber(2147483647)),
			'bigint'    => array('min' => new fNumber('-9223372036854775808'),  'max' => new fNumber('9223372036854775807')),
			'serial'    => array('min' => new fNumber(-2147483648),             'max' => new fNumber(2147483647)),
			'bigserial' => array('min' => new fNumber('-9223372036854775808'),  'max' => new fNumber('9223372036854775807'))
		);
		
		// PgSQL required this complicated SQL to get the column info
		$sql = "SELECT
						pg_attribute.attname                                        AS column,
						format_type(pg_attribute.atttypid, pg_attribute.atttypmod)  AS data_type,
						pg_attribute.attnotnull                                     AS not_null,
						pg_attrdef.adsrc                                            AS default,
						pg_get_constraintdef(pg_constraint.oid)                     AS constraint,
						col_description(pg_class.oid, pg_attribute.attnum)          AS comment              
					FROM
						pg_attribute LEFT JOIN
						pg_class ON pg_attribute.attrelid = pg_class.oid LEFT JOIN
						pg_namespace ON pg_class.relnamespace = pg_namespace.oid LEFT JOIN
						pg_type ON pg_type.oid = pg_attribute.atttypid LEFT JOIN
						pg_constraint ON pg_constraint.conrelid = pg_class.oid AND
										 pg_attribute.attnum = ANY (pg_constraint.conkey) AND
										 pg_constraint.contype = 'c' LEFT JOIN
						pg_attrdef ON pg_class.oid = pg_attrdef.adrelid AND
									  pg_attribute.attnum = pg_attrdef.adnum
					WHERE
						NOT pg_attribute.attisdropped AND
						pg_class.relname = %s AND
						pg_namespace.nspname = %s AND
						pg_type.typname NOT IN ('oid', 'cid', 'xid', 'cid', 'xid', 'tid')
					ORDER BY
						pg_attribute.attnum,
						pg_constraint.contype";
		$result = $this->database->query($sql, $table, $schema);
		
		foreach ($result as $row) {
			
			$info = array();
			
			// Get the column type
			preg_match('#([\w ]+)\s*(?:\(\s*(\d+)(?:\s*,\s*(\d+))?\s*\))?#', $row['data_type'], $column_data_type);
			
			foreach ($data_type_mapping as $data_type => $mapped_data_type) {
				if (stripos($column_data_type[1], $data_type) === 0) {
					$info['type'] = $mapped_data_type;
					if (isset($max_min_values[$data_type])) {
						$info['min_value'] = $max_min_values[$data_type]['min'];
						$info['max_value'] = $max_min_values[$data_type]['max'];
					}
					break;
				}
			}
			
			if (!isset($info['type'])) {
				$info['type'] = $column_data_type[1];
			}
			
			if ($info['type'] == 'blob' || $info['type'] == 'text') {
				$info['max_length'] = 1073741824; 
			}
			
			// Handle the length of decimal/numeric fields
			if ($info['type'] == 'float' && isset($column_data_type[3]) && strlen($column_data_type[3]) > 0) {
				$info['decimal_places'] = (int) $column_data_type[3];
				$before_digits = str_pad('', $column_data_type[2] - $info['decimal_places'], '9');
				$after_digits  = str_pad('', $info['decimal_places'], '9');
				$max_min       = $before_digits . ($after_digits ? '.' : '') . $after_digits;
				$info['min_value'] = new fNumber('-' . $max_min);
				$info['max_value'] = new fNumber($max_min);
			}
			
			// Handle the special data for varchar fields
			if (in_array($info['type'], array('char', 'varchar'))) {
				if (!empty($column_data_type[2])) {
					$info['max_length'] = $column_data_type[2];
				} else {
					$info['max_length'] = 1073741824; 
				}
			}
			
			// In PostgreSQL, a UUID can be the 32 digits, 32 digits plus 4 hyphens or 32 digits plus 4 hyphens and 2 curly braces
			if ($row['data_type'] == 'uuid') {
				$info['max_length'] = 38;	
			}
			
			// Handle check constraints that are just simple lists
			if (in_array($info['type'], array('varchar', 'char')) && !empty($row['constraint'])) {
				if (preg_match('/CHECK[\( "]+' . $row['column'] . '[a-z\) ":]+\s+=\s+/i', $row['constraint'])) {
					if (preg_match_all("/(?!').'((''|[^']+)*)'/", $row['constraint'], $matches, PREG_PATTERN_ORDER)) {
						$info['valid_values'] = str_replace("''", "'", $matches[1]);
					}
				}
			}
			
			// Handle default values and serial data types
			if ($info['type'] == 'integer' && stripos($row['default'], 'nextval(') !== FALSE) {
				$info['auto_increment'] = TRUE;
				
			} elseif ($row['default'] !== NULL) {
				if (preg_match('#^NULL::[\w\s]+$#', $row['default'])) {
					$info['default'] = NULL;
				} elseif ($row['default'] == 'now()') {
					$info['default'] = 'CURRENT_TIMESTAMP';
				} elseif ($row['default'] == "('now'::text)::date") {
					$info['default'] = 'CURRENT_DATE';
				} elseif ($row['default'] == "('now'::text)::time with time zone") {
					$info['default'] = 'CURRENT_TIME';	
				} else {
					$info['default'] = str_replace("''", "'", preg_replace("/^'(.*)'::[a-z ]+\$/iD", '\1', $row['default']));
					if ($info['type'] == 'boolean') {
						$info['default'] = ($info['default'] == 'false' || !$info['default']) ? FALSE : TRUE;
					}
				}
			}
			
			// Not null values
			$info['not_null'] = ($row['not_null'] == 't') ? TRUE : FALSE;
			
			$info['comment'] = $row['comment'];
			
			$column_info[$row['column']] = $info;
		}
		
		return $column_info;
	}
	
	
	/**
	 * Fetches the key info for a PostgreSQL database
	 * 
	 * @return array  The keys arrays for every table in the database - see ::getKeys() for details
	 */
	private function fetchPostgreSQLKeys()
	{
		$keys = array();
		
		$tables   = $this->getTables();
		foreach ($tables as $table) {
			$keys[$table] = array();
			$keys[$table]['primary'] = array();
			$keys[$table]['unique']  = array();
			$keys[$table]['foreign'] = array();
		}
		
		$sql  = "(
				 SELECT
						 s.nspname AS \"schema\",
						 t.relname AS \"table\",
						 con.conname AS constraint_name,
						 CASE con.contype
							 WHEN 'f' THEN 'foreign'
							 WHEN 'p' THEN 'primary'
							 WHEN 'u' THEN 'unique'
						 END AS type,
						 col.attname AS column,
						 fs.nspname AS foreign_schema,
						 ft.relname AS foreign_table,
						 fc.attname AS foreign_column,
						 CASE con.confdeltype
							 WHEN 'c' THEN 'cascade'
							 WHEN 'a' THEN 'no_action'
							 WHEN 'r' THEN 'restrict'
							 WHEN 'n' THEN 'set_null'
							 WHEN 'd' THEN 'set_default'
						 END AS on_delete,
						 CASE con.confupdtype
							 WHEN 'c' THEN 'cascade'
							 WHEN 'a' THEN 'no_action'
							 WHEN 'r' THEN 'restrict'
							 WHEN 'n' THEN 'set_null'
							 WHEN 'd' THEN 'set_default'
						 END AS on_update,
						CASE WHEN con.conkey IS NOT NULL THEN position('-'||col.attnum||'-' in '-'||array_to_string(con.conkey, '-')||'-') ELSE 0 END AS column_order
					 FROM
						 pg_attribute AS col INNER JOIN
						 pg_class AS t ON col.attrelid = t.oid INNER JOIN
						 pg_namespace AS s ON t.relnamespace = s.oid INNER JOIN
						 pg_constraint AS con ON (col.attnum = ANY (con.conkey) AND
												  con.conrelid = t.oid) LEFT JOIN
						 pg_class AS ft ON con.confrelid = ft.oid LEFT JOIN
						 pg_namespace AS fs ON ft.relnamespace = fs.oid LEFT JOIN
						 pg_attribute AS fc ON (fc.attnum = ANY (con.confkey) AND
												ft.oid = fc.attrelid)
					 WHERE
						 NOT col.attisdropped AND
						 (con.contype = 'p' OR
						  con.contype = 'f' OR
						  con.contype = 'u')
				) UNION (
				SELECT
						n.nspname AS \"schema\",
						t.relname AS \"table\",
						ic.relname AS constraint_name,
						'unique' AS type,
						col.attname AS column,
						NULL AS foreign_schema,
						NULL AS foreign_table,
						NULL AS foreign_column,
						NULL AS on_delete,
						NULL AS on_update,
						CASE WHEN ind.indkey IS NOT NULL THEN position('-'||col.attnum||'-' in '-'||array_to_string(ind.indkey, '-')||'-') ELSE 0 END AS column_order
					FROM
						pg_class AS t INNER JOIN
						pg_index AS ind ON ind.indrelid = t.oid INNER JOIN
						pg_namespace AS n ON t.relnamespace = n.oid INNER JOIN
						pg_class AS ic ON ind.indexrelid = ic.oid LEFT JOIN
						pg_constraint AS con ON con.conrelid = t.oid AND con.contype = 'u' AND con.conname = ic.relname INNER JOIN
						pg_attribute AS col ON col.attrelid = t.oid AND col.attnum = ANY (ind.indkey)  
					WHERE
						n.nspname NOT IN ('pg_catalog', 'pg_toast') AND
						indisunique = TRUE AND
						indisprimary = FALSE AND
						con.oid IS NULL AND
						0 != ALL ((ind.indkey)::int[])
				) ORDER BY 1, 2, 4, 3, 11";
		
		$result = $this->database->query($sql);
		
		$last_name  = '';
		$last_table = '';
		$last_type  = '';
		foreach ($result as $row) {
			
			if ($row['constraint_name'] != $last_name) {
				
				if ($last_name) {
					if ($last_type == 'foreign' || $last_type == 'unique') {
						$keys[$last_table][$last_type][] = $temp;
					} else {
						$keys[$last_table][$last_type] = $temp;
					}
				}
				
				$temp = array();
				if ($row['type'] == 'foreign') {
					
					$temp['column']         = $row['column'];
					$temp['foreign_table']  = $row['foreign_table'];
					if ($row['foreign_schema'] != 'public') {
						$temp['foreign_table'] = $row['foreign_schema'] . '.' . $temp['foreign_table'];	
					}
					$temp['foreign_column'] = $row['foreign_column'];
					$temp['on_delete']      = 'no_action';
					$temp['on_update']      = 'no_action';
					
					if (!empty($row['on_delete'])) {
						$temp['on_delete'] = $row['on_delete'];
					}
					
					if (!empty($row['on_update'])) {
						$temp['on_update'] = $row['on_update'];
					}
					
				} else {
					$temp[] = $row['column'];
				}
				
				$last_table = $row['table'];
				if ($row['schema'] != 'public') {
					$last_table = $row['schema'] . '.' . $last_table;	
				}
				$last_name  = $row['constraint_name'];
				$last_type  = $row['type'];
				
			} else {
				$temp[] = $row['column'];
			}
		}
		
		if (isset($temp)) {
			if ($last_type == 'foreign' || $last_type == 'unique') {
				$keys[$last_table][$last_type][] = $temp;
			} else {
				$keys[$last_table][$last_type] = $temp;
			}
		}
		
		return $keys;
	}
	
	
	/**
	 * Gets the column info from a SQLite database
	 * 
	 * @param  string $table  The table to fetch the column info for
	 * @return array  The column info for the table specified - see ::getColumnInfo() for details
	 */
	private function fetchSQLiteColumnInfo($table)
	{
		$column_info = array();
		
		$data_type_mapping = array(
			'boolean'			=> 'boolean',
			'serial'            => 'integer',
			'smallint'			=> 'integer',
			'int'				=> 'integer',
			'integer'           => 'integer',
			'bigint'			=> 'integer',
			'timestamp'			=> 'timestamp',
			'date'				=> 'date',
			'time'				=> 'time',
			'varchar'			=> 'varchar',
			'char'				=> 'char',
			'real'				=> 'float',
			'numeric'           => 'float',
			'float'             => 'float',
			'double'			=> 'float',
			'decimal'			=> 'float',
			'blob'				=> 'blob',
			'text'				=> 'text'
		);
		
		$result = $this->database->query("SELECT sql FROM sqlite_master WHERE type = 'table' AND name = %s", $table);
		
		try {
			$row        = $result->fetchRow();
			$create_sql = $row['sql'];
		} catch (fNoRowsException $e) {
			return array();			
		}
		
		preg_match_all('#(?<=,|\(|\*/|\n)\s*(?:`|"|\[)?(\w+)(?:`|"|\])?\s+([a-z]+)(?:\(\s*(\d+)(?:\s*,\s*(\d+))?\s*\))?(?:(\s+NOT\s+NULL)|(?:\s+NULL)|(?:\s+DEFAULT\s+([^, \']*|\'(?:\'\'|[^\']+)*\'))|(\s+UNIQUE)|(\s+PRIMARY\s+KEY(?:\s+AUTOINCREMENT)?)|(\s+CHECK\s*\(\w+\s+IN\s+\(\s*(?:(?:[^, \']+|\'(?:\'\'|[^\']+)*\')\s*,\s*)*\s*(?:[^, \']+|\'(?:\'\'|[^\']+)*\')\)\)))*(\s+REFERENCES\s+["`\[]?\w+["`\]]?\s*\(\s*["`\[]?\w+["`\]]?\s*\)\s*(?:\s+(?:ON\s+DELETE|ON\s+UPDATE)\s+(?:CASCADE|NO\s+ACTION|RESTRICT|SET\s+NULL|SET\s+DEFAULT))*(?:\s+(?:DEFERRABLE|NOT\s+DEFERRABLE))?)?([ \t]*(?:/\*(?:(?!\*/).)*\*/))?\s*(?:,([ \t]*--[^\n]*\n)?|(--[^\n]*\n)?\s*(?=\)))#msi', $create_sql, $matches, PREG_SET_ORDER);
		
		foreach ($matches as $match) {
			$info = array();
			
			foreach ($data_type_mapping as $data_type => $mapped_data_type) {
				if (stripos($match[2], $data_type) === 0) {
					$info['type'] = $mapped_data_type;
					break;
				}
			}
		
			// Type specific information
			if (in_array($info['type'], array('char', 'varchar'))) {
				if (!empty($match[3])) {
					$info['max_length'] = $match[3];
				} else {
					$info['max_length'] = 1000000000;   
				}
			}
			
			if ($info['type'] == 'text' || $info['type'] == 'blob') {
				$info['max_length'] = 1000000000;   
			}
			
			// Figure out how many decimal places for a decimal
			if (in_array(strtolower($match[2]), array('decimal', 'numeric')) && !empty($match[4])) {
				$info['decimal_places'] = $match[4];
				$before_digits = str_pad('', $match[3] - $match[4], '9');
				$after_digits  = str_pad('', $match[4], '9');
				$max_min       = $before_digits . ($after_digits ? '.' : '') . $after_digits;
				$info['min_value'] = new fNumber('-' . $max_min);
				$info['max_value'] = new fNumber($max_min);
			}
			
			// Not null
			$info['not_null'] = (!empty($match[5]) || !empty($match[8])) ? TRUE : FALSE;
		
			// Default values
			if (isset($match[6]) && $match[6] != '' && $match[6] != 'NULL') {
				$info['default'] = preg_replace("/^'|'\$/D", '', $match[6]);
			}
			if ($info['type'] == 'boolean' && isset($info['default'])) {
				$info['default'] = ($info['default'] == 'f' || $info['default'] == 0 || $info['default'] == 'false') ? FALSE : TRUE;
			}
		
			// Check constraints
			if (isset($match[9]) && preg_match('/CHECK\s*\(\s*' . $match[1] . '\s+IN\s+\(\s*((?:(?:[^, \']*|\'(?:\'\'|[^\']+)*\')\s*,\s*)*(?:[^, \']*|\'(?:\'\'|[^\']+)*\'))\s*\)/i', $match[9], $check_match)) {
				$info['valid_values'] = str_replace("''", "'", preg_replace("/^'|'\$/D", '', preg_split("#\s*,\s*#", $check_match[1])));
			}
		
			// Auto increment fields
			if (!empty($match[8]) && (stripos($match[8], 'autoincrement') !== FALSE || $info['type'] == 'integer')) {
				$info['auto_increment'] = TRUE;
			}
			
			// Column comments
			if (!empty($match[11]) || !empty($match[12]) || !empty($match[13])) {
				if (!empty($match[11])) {
					$comment = $match[11];
				} elseif (!empty($match[12])) {
					$comment = $match[12];
				} else {
					$comment = $match[13];
				}
				$comment = trim($comment);
				$comment = substr($comment, 0, 2) == '--' ? substr($comment, 2) : substr($comment, 2, -2);
				$info['comment'] = trim($comment);
			}
		
			$column_info[$match[1]] = $info;
		}
		
		return $column_info;
	}
	
	
	/**
	 * Fetches the key info for an SQLite database
	 * 
	 * @return array  The keys arrays for every table in the database - see ::getKeys() for details
	 */
	private function fetchSQLiteKeys()
	{
		$tables = $this->getTables();
		$keys   = array();
		
		foreach ($tables as $table) {
			$keys[$table] = array();
			$keys[$table]['primary'] = array();
			$keys[$table]['foreign'] = array();
			$keys[$table]['unique']  = array();
			
			$result     = $this->database->query("SELECT sql FROM sqlite_master WHERE type = 'table' AND name = %s", $table);
			$row        = $result->fetchRow();
			$create_sql = $row['sql'];
			
			// Collapse strings into empty string to make the matching simpler
			$create_sql = preg_replace('#\'(?:\'\'|[^\']+)*\'#', "''", $create_sql);
			
			// Remove single-line comments
			$create_sql = preg_replace('#--[^\n]*\n#', "\n", $create_sql);
			
			// Remove multi-line comments
			$create_sql = preg_replace('#/\*((?!\*/).)*\*/#', '', $create_sql);
			
			// Get column level key definitions
			preg_match_all('#(?<=,|\()\s*["`\[]?(\w+)["`\]]?\s+(?:[a-z]+)(?:\((?:\d+)\))?(?:(?:\s+NOT\s+NULL)|(?:\s+DEFAULT\s+(?:[^, \']*|\'(?:\'\'|[^\']+)*\'))|(\s+UNIQUE)|(\s+PRIMARY\s+KEY(?:\s+AUTOINCREMENT)?)|(?:\s+CHECK\s*\(\w+\s+IN\s+\(\s*(?:(?:[^, \']+|\'(?:\'\'|[^\']+)*\')\s*,\s*)*\s*(?:[^, \']+|\'(?:\'\'|[^\']+)*\')\)\)))*(\s+REFERENCES\s+["`\[]?(\w+)["`\]]?\s*\(\s*["`\[]?(\w+)["`\]]?\s*\)\s*(?:(?:\s+(?:ON\s+DELETE\s+(CASCADE|NO\s+ACTION|RESTRICT|SET\s+NULL|SET\s+DEFAULT)))|(?:\s+(?:ON\s+UPDATE\s+(CASCADE|NO\s+ACTION|RESTRICT|SET\s+NULL|SET\s+DEFAULT))))*(?:\s+(?:DEFERRABLE|NOT\s+DEFERRABLE))?)?\s*(?:,|\s*(?=\)))#mi', $create_sql, $matches, PREG_SET_ORDER);
			
			foreach ($matches as $match) {
				if (!empty($match[2])) {
					$keys[$table]['unique'][] = array($match[1]);
				}
				
				if (!empty($match[3])) {
					$keys[$table]['primary'] = array($match[1]);
				}
				
				if (!empty($match[4])) {
					$temp = array('column'         => $match[1],
								  'foreign_table'  => $match[5],
								  'foreign_column' => $match[6],
								  'on_delete'      => 'no_action',
								  'on_update'      => 'no_action');
					if (isset($match[7])) {
						$temp['on_delete'] = strtolower(str_replace(' ', '_', $match[7]));
					}
					if (isset($match[8])) {
						$temp['on_update'] = strtolower(str_replace(' ', '_', $match[8]));
					}
					$keys[$table]['foreign'][] = $temp;
				}
			}
			
			// Get table level primary key definitions
			preg_match_all('#(?<=,|\()\s*PRIMARY\s+KEY\s*\(\s*((?:\s*["`\[]?\w+["`\]]?\s*,\s*)*["`\[]?\w+["`\]]?)\s*\)\s*(?:,|\s*(?=\)))#mi', $create_sql, $matches, PREG_SET_ORDER);
			
			foreach ($matches as $match) {
				$columns = preg_split('#\s*,\s*#', $match[1]);
				foreach ($columns as $column) {
					$keys[$table]['primary'][] = str_replace(array('[', '"', '`', ']'), '', $column);	
				}
			}
			
			// Get table level foreign key definitions
			preg_match_all('#(?<=,|\()\s*FOREIGN\s+KEY\s*(?:["`\[]?(\w+)["`\]]?|\(\s*["`\[]?(\w+)["`\]]?\s*\))\s+REFERENCES\s+["`\[]?(\w+)["`\]]?\s*\(\s*["`\[]?(\w+)["`\]]?\s*\)\s*(?:\s+(?:ON\s+DELETE\s+(CASCADE|NO\s+ACTION|RESTRICT|SET\s+NULL|SET\s+DEFAULT)))?(?:\s+(?:ON\s+UPDATE\s+(CASCADE|NO\s+ACTION|RESTRICT|SET\s+NULL|SET\s+DEFAULT)))?(?:\s+(?:DEFERRABLE|NOT\s+DEFERRABLE))?\s*(?:,|\s*(?=\)))#mis', $create_sql, $matches, PREG_SET_ORDER);
			
			foreach ($matches as $match) {
				if (empty($match[1])) { $match[1] = $match[2]; }
				$temp = array('column'         => $match[1],
							  'foreign_table'  => $match[3],
							  'foreign_column' => $match[4],
							  'on_delete'      => 'no_action',
							  'on_update'      => 'no_action');
				if (isset($match[5])) {
					$temp['on_delete'] = strtolower(str_replace(' ', '_', $match[5]));
				}
				if (isset($match[6])) {
					$temp['on_update'] = strtolower(str_replace(' ', '_', $match[6]));
				}
				$keys[$table]['foreign'][] = $temp;
			}
			
			// Get table level unique key definitions
			preg_match_all('#(?<=,|\()\s*UNIQUE\s*\(\s*((?:\s*["`\[]?\w+["`\]]?\s*,\s*)*["`\[]?\w+["`\]]?)\s*\)\s*(?:,|\s*(?=\)))#mi', $create_sql, $matches, PREG_SET_ORDER);
			
			foreach ($matches as $match) {
				$columns = preg_split('#\s*,\s*#', $match[1]);
				$key = array();
				foreach ($columns as $column) {
					$key[] = str_replace(array('[', '"', '`', ']'), '', $column);
				}
				$keys[$table]['unique'][] = $key;
			}
			
			// Get all CREATE UNIQUE INDEX statements
			$result = $this->database->query("SELECT sql FROM sqlite_master WHERE type = 'index' AND sql <> '' AND tbl_name = %s", $table);
			foreach ($result as $row) {
				$create_sql = $row['sql'];
				if (!preg_match('#^\s*CREATE\s+UNIQUE\s+INDEX\s+(?:\w+\.)?\w+\s+ON\s+\w+\s*\(\s*((?:\s*["`\[]?\w+["`\]]?\s*,\s*)*["`\[]?\w+["`\]]?)\s*\)$#Di', $create_sql, $match)) {
					continue;
				}
				$columns = preg_split('#\s*,\s*#', $match[1]);
				$key = array();
				foreach ($columns as $column) {
					$key[] = str_replace(array('[', '"', '`', ']'), '', $column);
				}
				$keys[$table]['unique'][] = $key;
			}
		}
		
		return $keys;
	}
	
	
	/**
	 * Finds many-to-many relationship for the table specified
	 * 
	 * @param  string $table  The table to find the relationships on
	 * @return void
	 */
	private function findManyToManyRelationships($table)
	{
		if (!$this->isJoiningTable($table)) {
			return;
		}
		
		list ($key1, $key2) = $this->merged_keys[$table]['foreign'];
		
		$temp = array();
		$temp['table']               = $key1['foreign_table'];
		$temp['column']              = $key1['foreign_column'];
		$temp['related_table']       = $key2['foreign_table'];
		$temp['related_column']      = $key2['foreign_column'];
		$temp['join_table']          = $table;
		$temp['join_column']         = $key1['column'];
		$temp['join_related_column'] = $key2['column'];
		$temp['on_update']           = $key1['on_update'];
		$temp['on_delete']           = $key1['on_delete'];
		$this->relationships[$key1['foreign_table']]['many-to-many'][] = $temp;
		
		$temp = array();
		$temp['table']               = $key2['foreign_table'];
		$temp['column']              = $key2['foreign_column'];
		$temp['related_table']       = $key1['foreign_table'];
		$temp['related_column']      = $key1['foreign_column'];
		$temp['join_table']          = $table;
		$temp['join_column']         = $key2['column'];
		$temp['join_related_column'] = $key1['column'];
		$temp['on_update']           = $key2['on_update'];
		$temp['on_delete']           = $key2['on_delete'];
		$this->relationships[$key2['foreign_table']]['many-to-many'][] = $temp;
	}
	
	
	/**
	 * Finds one-to-many relationship for the table specified
	 * 
	 * @param  string $table  The table to find the relationships on
	 * @return void
	 */
	private function findOneToManyRelationships($table)
	{
		foreach ($this->merged_keys[$table]['foreign'] as $key) {
			$type = ($this->checkForSingleColumnUniqueKey($table, $key['column'])) ? 'one-to-one' : 'one-to-many';
			$temp = array();
			$temp['table']          = $key['foreign_table'];
			$temp['column']         = $key['foreign_column'];
			$temp['related_table']  = $table;
			$temp['related_column'] = $key['column'];
			$temp['on_delete']      = $key['on_delete'];
			$temp['on_update']      = $key['on_update'];
			$this->relationships[$key['foreign_table']][$type][] = $temp;
		}
	}
	
	
	/**
	 * Finds one-to-one and many-to-one relationship for the table specified
	 * 
	 * @param  string $table  The table to find the relationships on
	 * @return void
	 */
	private function findStarToOneRelationships($table)
	{
		foreach ($this->merged_keys[$table]['foreign'] as $key) {
			$temp = array();
			$temp['table']          = $table;
			$temp['column']         = $key['column'];
			$temp['related_table']  = $key['foreign_table'];
			$temp['related_column'] = $key['foreign_column'];
			$type = ($this->checkForSingleColumnUniqueKey($table, $key['column'])) ? 'one-to-one' : 'many-to-one';
			if ($type == 'one-to-one') {
				$temp['on_delete'] = $key['on_delete'];
				$temp['on_update'] = $key['on_update'];	
			}
			$this->relationships[$table][$type][] = $temp;
		}
	}
	
	
	/**
	 * Finds the one-to-one, many-to-one, one-to-many and many-to-many relationships in the database
	 * 
	 * @return void
	 */
	private function findRelationships()
	{
		$this->relationships = array();
		$tables = $this->getTables();
		
		foreach ($tables as $table) {
			$this->relationships[$table]['one-to-one']   = array();
			$this->relationships[$table]['many-to-one']  = array();
			$this->relationships[$table]['one-to-many']  = array();
			$this->relationships[$table]['many-to-many'] = array();
		}
		
		// Calculate the relationships
		foreach ($this->merged_keys as $table => $keys) {
			$this->findManyToManyRelationships($table);
			
			//if ($this->isJoiningTable($table)) {
			//	continue;
			//}
			
			$this->findStarToOneRelationships($table);
			$this->findOneToManyRelationships($table);
		}
		
		if ($this->cache) {
			$this->cache->set($this->makeCachePrefix() . 'relationships', $this->relationships);	
		}
	}
	
	
	/**
	 * Returns column information for the table specified
	 * 
	 * If only a table is specified, column info is in the following format:
	 * 
	 * {{{
	 * array(
	 *     (string) {column name} => array(
	 *         'type'           => (string)  {data type},
	 *         'placeholder'    => (string)  {fDatabase::escape() placeholder for this data type},
	 *         'not_null'       => (boolean) {if value can't be null},
	 *         'default'        => (mixed)   {the default value},
	 *         'valid_values'   => (array)   {the valid values for a varchar field},
	 *         'max_length'     => (integer) {the maximum length in a varchar field},
	 *         'min_value'      => (numeric) {the minimum value for an integer/float field},
	 *         'max_value'      => (numeric) {the maximum value for an integer/float field},
	 *         'decimal_places' => (integer) {the number of decimal places for a decimal/numeric/money/smallmoney field},
	 *         'auto_increment' => (boolean) {if the integer primary key column is a serial/autoincrement/auto_increment/indentity column},
	 *         'comment'        => (string)  {the SQL comment/description for the column}
	 *     ), ...
	 * )
	 * }}}
	 * 
	 * If a table and column are specified, column info is in the following format:
	 * 
	 * {{{
	 * array(
	 *     'type'           => (string)  {data type},
	 *     'placeholder'    => (string)  {fDatabase::escape() placeholder for this data type},
	 *     'not_null'       => (boolean) {if value can't be null},
	 *     'default'        => (mixed)   {the default value-may contain special strings CURRENT_TIMESTAMP, CURRENT_TIME or CURRENT_DATE},
	 *     'valid_values'   => (array)   {the valid values for a varchar field},
	 *     'max_length'     => (integer) {the maximum length in a char/varchar field},
	 *     'min_value'      => (fNumber) {the minimum value for an integer/float field},
	 *     'max_value'      => (fNumber) {the maximum value for an integer/float field},
	  *    'decimal_places' => (integer) {the number of decimal places for a decimal/numeric/money/smallmoney field},
	 *     'auto_increment' => (boolean) {if the integer primary key column is a serial/autoincrement/auto_increment/indentity column},
	 *     'comment'        => (string)  {the SQL comment/description for the column}
	 * )
	 * }}}
	 * 
	 * If a table, column and element are specified, returned value is the single element specified.
	 * 
	 * The `'type'` element is homogenized to a value from the following list:
	 * 
	 *  - `'varchar'`
	 *  - `'char'`
	 *  - `'text'`
	 *  - `'integer'`
	 *  - `'float'`
	 *  - `'timestamp'`
	 *  - `'date'`
	 *  - `'time'`
	 *  - `'boolean'`
	 *  - `'blob'`
	 * 
	 * Please note that MySQL reports boolean data types as `tinyint(1)`, so
	 * all `tinyint(1)` columns will be listed as `boolean`. This can be fixed
	 * by calling: 
	 * 
	 * {{{
	 * #!php
	 * $schema->setColumnInfoOverride(
	 *     array(
	 *         'type'        => 'integer',
	 *         'placeholder' => '%i',
	 *         'default'     => {default integer},
	 *         'min_value'   => new fNumber(-128),
	 *         'max_value'   => new fNumber(127)
	 *     ),
	 *     '{table name}',
	 *     '{column name}'
	 * );
	 * }}}
	 * 
	 * The `'comment'` element pulls from the database's column comment facility
	 * with the exception of MSSQL and SQLite.
	 * 
	 * For MSSQL, the comment is pulled from the `MS_Description` extended
	 * property, which can be added via the `Description` field in SQL Server
	 * Management Studio, or via the `sp_addextendedproperty` stored procedure.
	 * 
	 * For SQLite, the comment is extracted from any SQL comment that is placed
	 * at the end of the line on which the column is defined:
	 * 
	 * {{{
	 * #!sql
	 * CREATE TABLE users (
	 *     user_id INTEGER PRIMARY KEY AUTOINCREMENT,
	 *     name VARCHAR(200) NOT NULL -- This is the full name
	 * );
	 * }}}
	 * 
	 * For the SQLite `users` table defined above, the `name` column will have
	 * the comment `This is the full name`.
	 * 
	 * @param  string $table    The table to get the column info for
	 * @param  string $column   The column to get the info for
	 * @param  string $element  The element to return: `'type'`, `'placeholder'`, `'not_null'`, `'default'`, `'valid_values'`, `'max_length'`, `'min_value'`, `'max_value'`, `'decimal_places'`, `'auto_increment'`, `'comment'`
	 * @return mixed  The column info for the table/column/element specified - see method description for format
	 */
	public function getColumnInfo($table, $column=NULL, $element=NULL)
	{
		// Return the saved column info if possible
		if (!$column && isset($this->merged_column_info[$table])) {
			return $this->merged_column_info[$table];
		}
		if ($column && isset($this->merged_column_info[$table][$column])) {
			if ($element !== NULL) {
				if (!isset($this->merged_column_info[$table][$column][$element]) && !array_key_exists($element, $this->merged_column_info[$table][$column])) {
					throw new fProgrammerException(
						'The element specified, %1$s, is invalid. Must be one of: %2$s.',
						$element,
						join(', ', array('type', 'placeholder', 'not_null', 'default', 'valid_values', 'max_length', 'min_value', 'max_value', 'decimal_places', 'auto_increment'))
					);	
				}
				return $this->merged_column_info[$table][$column][$element];
			}
			return $this->merged_column_info[$table][$column];
		}
		
		if (!in_array($table, $this->getTables())) {
			throw new fProgrammerException(
				'The table specified, %s, does not exist in the database',
				$table
			);
		}
		
		$this->fetchColumnInfo($table);
		$this->mergeColumnInfo();
		
		if ($column && !isset($this->merged_column_info[$table][$column])) {
			throw new fProgrammerException(
				'The column specified, %1$s, does not exist in the table %2$s',
				$column,
				$table
			);
		}
		
		if ($column) {
			if ($element) {
				return $this->merged_column_info[$table][$column][$element];
			}
			
			return $this->merged_column_info[$table][$column];
		}
		
		return $this->merged_column_info[$table];
	}
	
	
	/**
	 * Returns the databases on the current server
	 * 
	 * @return array  The databases on the current server
	 */
	public function getDatabases()
	{
		if ($this->databases !== NULL) {
			return $this->databases;
		}
		
		$this->databases = array();
		
		switch ($this->database->getType()) {
			case 'mssql':
				$sql = 'EXECUTE sp_databases';
				break;
			
			case 'mysql':
				$sql = 'SHOW DATABASES';
				break;
				
			case 'oracle':
				$sql = 'SELECT ora_database_name FROM dual';
			
			case 'postgresql':
				$sql = "SELECT
								datname
							FROM
								pg_database
							ORDER BY
								LOWER(datname)";
				break;
								
			case 'db2':
			case 'sqlite':
				$this->databases[] = $this->database->getDatabase();
				return $this->databases;
		}
		
		$result = $this->database->query($sql);
		
		foreach ($result as $row) {
			$keys = array_keys($row);
			$this->databases[] = $row[$keys[0]];
		}
		
		if ($this->cache) {
			$this->cache->set($this->makeCachePrefix() . 'databases', $this->databases);		
		}
		
		return $this->databases;
	}
	
	
	/**
	 * Returns a list of primary key, foreign key and unique key constraints for the table specified
	 * 
	 * The structure of the returned array is:
	 * 
	 * {{{
	 * array(
	 *      'primary' => array(
	 *          {column name}, ...
	 *      ),
	 *      'unique'  => array(
	 *          array(
	 *              {column name}, ...
	 *          ), ...
	 *      ),
	 *      'foreign' => array(
	 *          array(
	 *              'column'         => {column name},
	 *              'foreign_table'  => {foreign table name},
	 *              'foreign_column' => {foreign column name},
	 *              'on_delete'      => {the ON DELETE action: 'no_action', 'restrict', 'cascade', 'set_null', or 'set_default'},
	 *              'on_update'      => {the ON UPDATE action: 'no_action', 'restrict', 'cascade', 'set_null', or 'set_default'}
	 *          ), ...
	 *      )
	 * )
	 * }}}
	 * 
	 * @param  string $table     The table to return the keys for
	 * @param  string $key_type  The type of key to return: `'primary'`, `'foreign'`, `'unique'`
	 * @return array  An array of all keys, or just the type specified - see method description for format
	 */
	public function getKeys($table, $key_type=NULL)
	{
		$valid_key_types = array('primary', 'foreign', 'unique');
		if ($key_type !== NULL && !in_array($key_type, $valid_key_types)) {
			throw new fProgrammerException(
				'The key type specified, %1$s, is invalid. Must be one of: %2$s.',
				$key_type,
				join(', ', $valid_key_types)
			);
		}
		
		// Return the saved column info if possible
		if (!$key_type && isset($this->merged_keys[$table])) {
			return $this->merged_keys[$table];
		}
		
		if ($key_type && isset($this->merged_keys[$table][$key_type])) {
			return $this->merged_keys[$table][$key_type];
		}
		
		if (!in_array($table, $this->getTables())) {
			throw new fProgrammerException(
				'The table specified, %s, does not exist in the database',
				$table
			);
		}
		
		$this->fetchKeys();
		$this->mergeKeys();
		
		if ($key_type) {
			return $this->merged_keys[$table][$key_type];
		}
		
		return $this->merged_keys[$table];
	}
	
	
	/**
	 * Returns a list of one-to-one, many-to-one, one-to-many and many-to-many relationships for the table specified
	 * 
	 * The structure of the returned array is:
	 * 
	 * {{{
	 * array(
	 *     'one-to-one' => array(
	 *         array(
	 *             'table'          => (string) {the name of the table this relationship is for},
	 *             'column'         => (string) {the column in the specified table},
	 *             'related_table'  => (string) {the related table},
	 *             'related_column' => (string) {the related column},
	 *             'on_delete'      => (string) {the ON DELETE action: 'no_action', 'restrict', 'cascade', 'set_null', or 'set_default'},
	 *             'on_update'      => (string) {the ON UPDATE action: 'no_action', 'restrict', 'cascade', 'set_null', or 'set_default'}
	 *         ), ...
	 *     ),
	 *     'many-to-one' => array(
	 *         array(
	 *             'table'          => (string) {the name of the table this relationship is for},
	 *             'column'         => (string) {the column in the specified table},
	 *             'related_table'  => (string) {the related table},
	 *             'related_column' => (string) {the related column}
	 *         ), ...
	 *     ),
	 *     'one-to-many' => array(
	 *         array(
	 *             'table'          => (string) {the name of the table this relationship is for},
	 *             'column'         => (string) {the column in the specified table},
	 *             'related_table'  => (string) {the related table},
	 *             'related_column' => (string) {the related column},
	 *             'on_delete'      => (string) {the ON DELETE action: 'no_action', 'restrict', 'cascade', 'set_null', or 'set_default'},
	 *             'on_update'      => (string) {the ON UPDATE action: 'no_action', 'restrict', 'cascade', 'set_null', or 'set_default'}
	 *         ), ...
	 *     ),
	 *     'many-to-many' => array(
	 *         array(
	 *             'table'               => (string) {the name of the table this relationship is for},
	 *             'column'              => (string) {the column in the specified table},
	 *             'related_table'       => (string) {the related table},
	 *             'related_column'      => (string) {the related column},
	 *             'join_table'          => (string) {the table that joins the specified table to the related table},
	 *             'join_column'         => (string) {the column in the join table that references 'column'},
	 *             'join_related_column' => (string) {the column in the join table that references 'related_column'},
	 *             'on_delete'           => (string) {the ON DELETE action: 'no_action', 'restrict', 'cascade', 'set_null', or 'set_default'},
	 *             'on_update'           => (string) {the ON UPDATE action: 'no_action', 'restrict', 'cascade', 'set_null', or 'set_default'}
	 *         ), ...
	 *     )
	 * )
	 * }}}
	 * 
	 * @param  string $table              The table to return the relationships for
	 * @param  string $relationship_type  The type of relationship to return: `'one-to-one'`, `'many-to-one'`, `'one-to-many'`, `'many-to-many'`
	 * @return array  An array of all relationships, or just the type specified - see method description for format
	 */
	public function getRelationships($table, $relationship_type=NULL)
	{
		$valid_relationship_types = array('one-to-one', 'many-to-one', 'one-to-many', 'many-to-many');
		if ($relationship_type !== NULL && !in_array($relationship_type, $valid_relationship_types)) {
			throw new fProgrammerException(
				'The relationship type specified, %1$s, is invalid. Must be one of: %2$s.',
				$relationship_type,
				join(', ', $valid_relationship_types)
			);
		}
		
		// Return the saved column info if possible
		if (!$relationship_type && isset($this->relationships[$table])) {
			return $this->relationships[$table];
		}
		
		if ($relationship_type && isset($this->relationships[$table][$relationship_type])) {
			return $this->relationships[$table][$relationship_type];
		}
		
		if (!in_array($table, $this->getTables())) {
			throw new fProgrammerException(
				'The table specified, %s, does not exist in the database',
				$table
			);
		}
		
		$this->fetchKeys();
		$this->mergeKeys();
		
		if ($relationship_type) {
			return $this->relationships[$table][$relationship_type];
		}
		
		return $this->relationships[$table];
	}
	
	
	/**
	 * Returns the tables in the current database
	 * 
	 * @return array  The tables in the current database
	 */
	public function getTables()
	{
		if ($this->tables !== NULL) {
			return $this->tables;
		}
		
		switch ($this->database->getType()) {
			case 'db2':
				$sql = "SELECT
								LOWER(RTRIM(TABSCHEMA)) AS \"schema\",
								LOWER(TABNAME) AS \"table\"
							FROM
								SYSCAT.TABLES
							WHERE
								TYPE = 'T' AND
								TABSCHEMA != 'SYSIBM' AND
								DEFINER != 'SYSIBM' AND
								TABSCHEMA != 'SYSTOOLS' AND
								DEFINER != 'SYSTOOLS'
							ORDER BY
								LOWER(TABNAME)";
				break;
				
			case 'mssql':
				$sql = "SELECT
								TABLE_SCHEMA AS \"schema\",
								TABLE_NAME AS \"table\"
							FROM
								INFORMATION_SCHEMA.TABLES
							WHERE
								TABLE_NAME != 'sysdiagrams'
							ORDER BY
								LOWER(TABLE_NAME)";
				break;
			
			case 'mysql':
				if (!$this->version) {
					$this->version = $this->database->query("SELECT version()")->fetchScalar();
					$this->version = substr($this->version, 0, strpos($this->version, '.'));
					if ($this->cache) {
						$this->cache->set($this->makeCachePrefix() . 'version', $this->version);
					}
				}
				if ($this->version <= 4) {
					$sql = 'SHOW TABLES';
				} else {
					$sql = "SHOW FULL TABLES WHERE table_type = 'BASE TABLE'";	
				}
				break;
			
			case 'oracle':
				$sql = "SELECT
								LOWER(OWNER) AS \"SCHEMA\",
								LOWER(TABLE_NAME) AS \"TABLE\"
							FROM
								ALL_TABLES
							WHERE
								OWNER NOT IN (
									'SYS',
									'SYSTEM',
									'OUTLN',
									'ANONYMOUS',
									'AURORA\$ORB\$UNAUTHENTICATED',
									'AWR_STAGE',
									'CSMIG',
									'CTXSYS',
									'DBSNMP',
									'DIP',
									'DMSYS',
									'DSSYS',
									'EXFSYS',
									'FLOWS_020100',
									'FLOWS_FILES',
									'LBACSYS',
									'MDSYS',
									'ORACLE_OCM',
									'ORDPLUGINS',
									'ORDSYS',
									'PERFSTAT',
									'TRACESVR',
									'TSMSYS',
									'XDB'
								) AND
								DROPPED = 'NO' 
							ORDER BY
								TABLE_NAME ASC";
				break;
			
			case 'postgresql':
				$sql = "SELECT
								 schemaname AS \"schema\",
								 tablename as \"table\"
							FROM
								 pg_tables
							WHERE
								 tablename !~ '^(pg|sql)_'
							ORDER BY
								LOWER(tablename)";
				break;
								
			case 'sqlite':
				$sql = "SELECT
								name
							FROM
								sqlite_master
							WHERE
								type = 'table' AND
								name NOT LIKE 'sqlite_%'
							ORDER BY
								name ASC";
				break;
		}
		
		$result = $this->database->query($sql);
		
		$this->tables = array();
		
		// For databases with schemas we only include the schema
		// name if there are conflicting table names
		if (!in_array($this->database->getType(), array('mysql', 'sqlite'))) {
			
			$default_schema_map = array(
				'db2'        => strtolower($this->database->getUsername()),
				'mssql'      => 'dbo',
				'oracle'     => strtolower($this->database->getUsername()),
				'postgresql' => 'public'
			);
			
			$default_schema = $default_schema_map[$this->database->getType()];
			
			foreach ($result as $row) {
				if ($row['schema'] == $default_schema) {
					$this->tables[] = $row['table'];	
				} else {
					$this->tables[] = $row['schema'] . '.' . $row['table'];	
				}
			}
				
		// SQLite and MySQL don't support schemas
		} else {
			foreach ($result as $row) {
				$keys = array_keys($row);
				$this->tables[] = $row[$keys[0]];
			}
		}
		
		sort($this->tables);
		
		if ($this->cache) {
			$this->cache->set($this->makeCachePrefix() . 'tables', $this->tables);
		}
		
		return $this->tables;
	}
		
	
	/**
	 * Determines if a table is a joining table
	 * 
	 * @param  string $table  The table to check
	 * @return boolean  If the table is a joining table
	 */
	private function isJoiningTable($table)
	{
		$primary_key_columns = $this->merged_keys[$table]['primary'];
		
		if (sizeof($primary_key_columns) != 2) {
			return FALSE;	
		}
		
		if (empty($this->merged_column_info[$table])) {
			$this->getColumnInfo($table);	
		}
		if (sizeof($this->merged_column_info[$table]) != 2) {
			return FALSE;	
		}
		
		$foreign_key_columns = array();
		foreach ($this->merged_keys[$table]['foreign'] as $key) {
			$foreign_key_columns[] = $key['column'];
		}
		
		return sizeof($foreign_key_columns) == 2 && !array_diff($foreign_key_columns, $primary_key_columns);
	}
	
	
	/**
	 * Creates a unique cache prefix to help prevent cache conflicts
	 * 
	 * @return string  The cache prefix to use
	 */
	private function makeCachePrefix()
	{
		if (!$this->cache_prefix) {
			$prefix  = 'fSchema::' . $this->database->getType() . '::';
			if ($this->database->getHost()) {
				$prefix .= $this->database->getHost() . '::';
			}
			if ($this->database->getPort()) {
				$prefix .= $this->database->getPort() . '::';
			}
			$prefix .= $this->database->getDatabase() . '::';
			if ($this->database->getUsername()) {
				$prefix .= $this->database->getUsername() . '::';
			}
			$this->cache_prefix = $prefix;
		}
		
		return $this->cache_prefix;
	}
	
	
	/**
	 * Merges the column info with the column info override
	 * 
	 * @return void
	 */
	private function mergeColumnInfo()
	{
		$this->merged_column_info = $this->column_info;
		
		foreach ($this->column_info_override as $table => $columns) {
			// Remove a table if the columns are set to NULL
			if ($columns === NULL) {
				unset($this->merged_column_info[$table]);
				continue;	
			}
			
			if (!isset($this->merged_column_info[$table])) {
				$this->merged_column_info[$table] = array();
			}
			
			foreach ($columns as $column => $info) {
				// Remove a column if it is set to NULL
				if ($info === NULL) {
					unset($this->merged_column_info[$table][$column]);	
					continue;
				}
				
				if (!isset($this->merged_column_info[$table][$column])) {
					$this->merged_column_info[$table][$column] = array();
				}
				
				$this->merged_column_info[$table][$column] = array_merge($this->merged_column_info[$table][$column], $info);
			}
		}
		
		$optional_elements = array(
			'not_null',
			'default',
			'valid_values',
			'max_length',
			'max_value',
			'min_value',
			'decimal_places',
			'auto_increment',
			'comment'
		);
		
		foreach ($this->merged_column_info as $table => $column_array) {
			foreach ($column_array as $column => $info) {
				if (empty($info['type'])) {
					throw new fProgrammerException('The data type for the column %1$s is empty', $column);	
				}
				
				if (empty($this->merged_column_info[$table][$column]['placeholder'])) {
					$this->merged_column_info[$table][$column]['placeholder'] = strtr(
						$info['type'],
						array(
							'blob'      => '%l',
							'boolean'   => '%b',
							'date'      => '%d',
							'float'     => '%f',
							'integer'   => '%i',
							'char'      => '%s',
							'text'      => '%s',
							'varchar'   => '%s',
							'time'      => '%t',
							'timestamp' => '%p'
						)
					);
				}
				
				foreach ($optional_elements as $element) {
					if (!isset($this->merged_column_info[$table][$column][$element])) {
						$this->merged_column_info[$table][$column][$element] = ($element == 'auto_increment') ? FALSE : NULL;
					}
				}
			}
		}
		
		if ($this->cache) {
			$this->cache->set($this->makeCachePrefix() . 'merged_column_info', $this->merged_column_info);	
		}
	}
		
	
	/**
	 * Merges the keys with the keys override
	 * 
	 * @return void
	 */
	private function mergeKeys()
	{
		// Handle the database and override key info
		$this->merged_keys = $this->keys;
		
		foreach ($this->keys_override as $table => $info) {
			if (!isset($this->merged_keys[$table])) {
				$this->merged_keys[$table] = array();
			}
			$this->merged_keys[$table] = array_merge($this->merged_keys[$table], $info);
		}
		
		if ($this->cache) {
			$this->cache->set($this->makeCachePrefix() . 'merged_keys', $this->merged_keys);	
		}
		
		$this->findRelationships();
	}
	
	
	/**
	 * Allows overriding of column info
	 * 
	 * Performs an array merge with the column info detected from the database.
	 * 
	 * To erase a whole table, set the `$column_info` to `NULL`. To erase a
	 * column, set the `$column_info` for that column to `NULL`.
	 * 
	 * If the `$column_info` parameter is not `NULL`, it should be an
	 * associative array containing one or more of the following keys. Please
	 * see ::getColumnInfo() for a description of each.
	 *  - `'type'`
	 *  - `'placeholder'`
	 *  - `'not_null'`
	 *  - `'default'`
	 *  - `'valid_values'`
	 *  - `'max_length'`
	 *  - `'min_value'`
	 *  - `'max_value'`
	 *  - `'decimal_places'`
	 *  - `'auto_increment'`
	 *  - `'comment'`
	 * 
	 * The following keys may be set to `NULL`:
	 *  - `'not_null'`
	 *  - `'default'`
	 *  - `'valid_values'`
	 *  - `'max_length'`
	 *  - `'min_value'`
	 *  - `'max_value'`
	 *  - `'decimal_places'`
	 *  - `'comment'`
	 *  
	 * The key `'auto_increment'` should be a boolean.
	 * 
	 * The `'type'` key should be one of:
	 *  - `'blob'`
	 *  - `'boolean'`
	 *  - `'char'`
	 *  - `'date'`
	 *  - `'float'`
	 *  - `'integer'`
	 *  - `'text'`
	 *  - `'time'`
	 *  - `'timestamp'`
	 *  - `'varchar'`
	 * 
	 * @param  array  $column_info  The modified column info - see method description for format
	 * @param  string $table        The table to override
	 * @param  string $column       The column to override
	 * @return void
	 */
	public function setColumnInfoOverride($column_info, $table, $column=NULL)
	{
		if (!isset($this->column_info_override[$table])) {
			$this->column_info_override[$table] = array();
		}
		
		if (!empty($column)) {
			$this->column_info_override[$table][$column] = $column_info;
		} else {
			$this->column_info_override[$table] = $column_info;
		}
		
		$this->fetchColumnInfo($table);
		$this->mergeColumnInfo();
	}
	
	
	/**
	 * Allows overriding of key info. Replaces existing info, so be sure to provide full key info for type selected or all types.
	 * 
	 * @param  array  $keys      The modified keys - see ::getKeys() for format
	 * @param  string $table     The table to override
	 * @param  string $key_type  The key type to override: `'primary'`, `'foreign'`, `'unique'`
	 * @return void
	 */
	public function setKeysOverride($keys, $table, $key_type=NULL)
	{
		$valid_key_types = array('primary', 'foreign', 'unique');
		if (!in_array($key_type, $valid_key_types)) {
			throw new fProgrammerException(
				'The key type specified, %1$s, is invalid. Must be one of: %2$s.',
				$key_type,
				join(', ', $valid_key_types)
			);
		}
		
		if (!isset($this->keys_override[$table])) {
			$this->keys_override[$table] = array();
		}
		
		if (!empty($key_type)) {
			$this->keys_override[$table][$key_type] = $keys;
		} else {
			$this->keys_override[$table] = $keys;
		}
		
		$this->fetchKeys();
		$this->mergeKeys();
	}
}

/**
 * An exception that allows for easy l10n, printing, tracing and hooking
 * 
 * @copyright  Copyright (c) 2007-2009 Will Bond
 * @author     Will Bond [wb] <will@flourishlib.com>
 * @license    http://flourishlib.com/license
 * 
 * @package    Flourish
 * @link       http://flourishlib.com/fException
 * 
 * @version    1.0.0b8
 * @changes    1.0.0b8  Added a missing line of backtrace to ::formatTrace() [wb, 2009-06-28]
 * @changes    1.0.0b7  Updated ::__construct() to no longer require a message, like the Exception class, and allow for non-integer codes [wb, 2009-06-26]
 * @changes    1.0.0b6  Fixed ::splitMessage() so that the original message is returned if no list items are found, added ::reorderMessage() [wb, 2009-06-02]
 * @changes    1.0.0b5  Added ::splitMessage() to replace fCRUD::removeListItems() and fCRUD::reorderListItems() [wb, 2009-05-08]
 * @changes    1.0.0b4  Added a check to ::__construct() to ensure that the `$code` parameter is numeric [wb, 2009-05-04]
 * @changes    1.0.0b3  Fixed a bug with ::printMessage() messing up some HTML messages [wb, 2009-03-27]
 * @changes    1.0.0b2  ::compose() more robustly handles `$components` passed as an array, ::__construct() now detects stray `%` characters [wb, 2009-02-05]
 * @changes    1.0.0b   The initial implementation [wb, 2007-06-14]
 */
abstract class fException extends Exception
{
	/**
	 * Callbacks for when exceptions are created
	 * 
	 * @var array
	 */
	static private $callbacks = array();
	
	
	/**
	 * Composes text using fText if loaded
	 * 
	 * @param  string  $message    The message to compose
	 * @param  mixed   $component  A string or number to insert into the message
	 * @param  mixed   ...
	 * @return string  The composed and possible translated message
	 */
	static protected function compose($message)
	{
		$components = array_slice(func_get_args(), 1);
		
		// Handles components passed as an array
		if (sizeof($components) == 1 && is_array($components[0])) {
			$components = $components[0];	
		}
		
		// If fText is loaded, use it
		if (class_exists('fText', FALSE)) {
			return call_user_func_array(
				array('fText', 'compose'),
				array($message, $components)
			);
			
		} else {
			return vsprintf($message, $components);
		}
	}
	
	
	/**
	 * Creates a string representation of any variable using predefined strings for booleans, `NULL` and empty strings
	 * 
	 * The string output format of this method is very similar to the output of
	 * [http://php.net/print_r print_r()] except that the following values
	 * are represented as special strings:
	 *   
	 *  - `TRUE`: `'{true}'`
	 *  - `FALSE`: `'{false}'`
	 *  - `NULL`: `'{null}'`
	 *  - `''`: `'{empty_string}'`
	 * 
	 * @param  mixed $data  The value to dump
	 * @return string  The string representation of the value
	 */
	static protected function dump($data)
	{
		if (is_bool($data)) {
			return ($data) ? '{true}' : '{false}';
		
		} elseif (is_null($data)) {
			return '{null}';
		
		} elseif ($data === '') {
			return '{empty_string}';
		
		} elseif (is_array($data) || is_object($data)) {
			
			ob_start();
			var_dump($data);
			$output = ob_get_contents();
			ob_end_clean();
			
			// Make the var dump more like a print_r
			$output = preg_replace('#=>\n(  )+(?=[a-zA-Z]|&)#m', ' => ', $output);
			$output = str_replace('string(0) ""', '{empty_string}', $output);
			$output = preg_replace('#=> (&)?NULL#', '=> \1{null}', $output);
			$output = preg_replace('#=> (&)?bool\((false|true)\)#', '=> \1{\2}', $output);
			$output = preg_replace('#string\(\d+\) "#', '', $output);
			$output = preg_replace('#"(\n(  )*)(?=\[|\})#', '\1', $output);
			$output = preg_replace('#(?:float|int)\((-?\d+(?:.\d+)?)\)#', '\1', $output);
			$output = preg_replace('#((?:  )+)\["(.*?)"\]#', '\1[\2]', $output);
			$output = preg_replace('#(?:&)?array\(\d+\) \{\n((?:  )*)((?:  )(?=\[)|(?=\}))#', "Array\n\\1(\n\\1\\2", $output);
			$output = preg_replace('/object\((\w+)\)#\d+ \(\d+\) {\n((?:  )*)((?:  )(?=\[)|(?=\}))/', "\\1 Object\n\\2(\n\\2\\3", $output);
			$output = preg_replace('#^((?:  )+)}(?=\n|$)#m', "\\1)\n", $output);
			$output = substr($output, 0, -2) . ')';
			
			// Fix indenting issues with the var dump output
			$output_lines = explode("\n", $output);
			$new_output = array();
			$stack = 0;
			foreach ($output_lines as $line) {
				if (preg_match('#^((?:  )*)([^ ])#', $line, $match)) {
					$spaces = strlen($match[1]);
					if ($spaces && $match[2] == '(') {
						$stack += 1;
					}
					$new_output[] = str_pad('', ($spaces)+(4*$stack)) . $line;
					if ($spaces && $match[2] == ')') {
						$stack -= 1;
					}
				} else {
					$new_output[] = str_pad('', ($spaces)+(4*$stack)) . $line;
				}
			}
			
			return join("\n", $new_output);
			
		} else {
			return (string) $data;
		}
	}
	
	
	/**
	 * Adds a callback for when certain types of exceptions are created 
	 * 
	 * The callback will be called when any exception of this class, or any
	 * child class, specified is tossed. A single parameter will be passed
	 * to the callback, which will be the exception object.
	 * 
	 * @param  callback $callback        The callback
	 * @param  string   $exception_type  The type of exception to call the callback for
	 * @return void
	 */
	static public function registerCallback($callback, $exception_type=NULL)
	{
		if ($exception_type === NULL) {
			$exception_type = 'fException';	
		}
		
		if (!isset(self::$callbacks[$exception_type])) {
			self::$callbacks[$exception_type] = array();
		}
		
		if (is_string($callback) && strpos($callback, '::') !== FALSE) {
			$callback = explode('::', $callback);	
		}
		
		self::$callbacks[$exception_type][] = $callback;
	}
	
	
	/**
	 * Compares the message matching strings by longest first so that the longest matches are made first
	 *
	 * @param  string $a  The first string to compare
	 * @param  string $b  The second string to compare
	 * @return integer  `-1` if `$a` is longer than `$b`, `0` if they are equal length, `1` if `$a` is shorter than `$b`
	 */
	static private function sortMatchingArray($a, $b)
	{
		return -1 * strnatcmp(strlen($a), strlen($b));
	}
	
	
	/**
	 * Sets the message for the exception, allowing for string interpolation and internationalization
	 * 
	 * The `$message` can contain any number of formatting placeholders for
	 * string and number interpolation via [http://php.net/sprintf `sprintf()`].
	 * Any `%` signs that do not appear to be part of a valid formatting
	 * placeholder will be automatically escaped with a second `%`.
	 * 
	 * The following aspects of valid `sprintf()` formatting codes are not
	 * accepted since they are redundant and restrict the non-formatting use of
	 * the `%` sign in exception messages:
	 *  - `% 2d`: Using a literal space as a padding character - a space will be used if no padding character is specified
	 *  - `%'.d`: Providing a padding character but no width - no padding will be applied without a width
	 * 
	 * @param  string $message    The message for the exception. This accepts a subset of [http://php.net/sprintf `sprintf()`] strings - see method description for more details.
	 * @param  mixed  $component  A string or number to insert into the message
	 * @param  mixed  ...
	 * @param  mixed  $code       The exception code to set
	 * @return fException
	 */
	public function __construct($message='')
	{
		$args          = array_slice(func_get_args(), 1);
		$required_args = preg_match_all(
			'/
				(?<!%)                       # Ensure this is not an escaped %
				%(                           # The leading %
				  (?:\d+\$)?                 # Position
				  \+?                        # Sign specifier
				  (?:(?:0|\'.)?-?\d+|-?)     # Padding, alignment and width or just alignment
				  (?:\.\d+)?				 # Precision
				  [bcdeufFosxX]              # Type
				)/x',
			$message,
			$matches
		);
		
		// Handle %s that weren't properly escaped
		$formats    = $matches[1];
		$delimeters = ($formats) ? array_fill(0, sizeof($formats), '#') : array();
		$lookahead  = join(
			'|',
			array_map(
				'preg_quote',
				$formats,
				$delimeters 
			)
		);
		$lookahead  = ($lookahead) ? '|' . $lookahead : '';
		$message    = preg_replace('#(?<!%)%(?!%' . $lookahead . ')#', '%%', $message);	
		
		// If we have an extra argument, it is the exception code
		$code = NULL;
		if ($required_args == sizeof($args) - 1) {
			$code = array_pop($args);		
		}
		
		if (sizeof($args) != $required_args) {
			$message = self::compose(
				'%1$d components were passed to the %2$s constructor, while %3$d were specified in the message',
				sizeof($args),
				get_class($this),
				$required_args
			);
			throw new Exception($message);	
		}
		
		$args = array_map(array('fException', 'dump'), $args);
		
		parent::__construct(self::compose($message, $args));
		$this->code = $code;
		
		foreach (self::$callbacks as $class => $callbacks) {
			foreach ($callbacks as $callback) {
				if ($this instanceof $class) {
					call_user_func($callback, $this);
				}
			}
		}		
	}
	
	
	/**
	 * All requests that hit this method should be requests for callbacks
	 * 
	 * @internal
	 * 
	 * @param  string $method  The method to create a callback for
	 * @return callback  The callback for the method requested
	 */
	public function __get($method)
	{
		return array($this, $method);		
	}
	
	
	/**
	 * Gets the backtrace to currently called exception
	 * 
	 * @return string  A nicely formatted backtrace to this exception
	 */
	public function formatTrace()
	{
		$doc_root  = realpath($_SERVER['DOCUMENT_ROOT']);
		$doc_root .= (substr($doc_root, -1) != DIRECTORY_SEPARATOR) ? DIRECTORY_SEPARATOR : '';
		
		$backtrace = explode("\n", $this->getTraceAsString());
		array_unshift($backtrace, $this->file . '(' . $this->line . ')');
		$backtrace = preg_replace('/^#\d+\s+/', '', $backtrace);
		$backtrace = str_replace($doc_root, '{doc_root}' . DIRECTORY_SEPARATOR, $backtrace);
		$backtrace = array_diff($backtrace, array('{main}'));
		$backtrace = array_reverse($backtrace);
		
		return join("\n", $backtrace);
	}
	
	
	/**
	 * Returns the CSS class name for printing information about the exception
	 * 
	 * @return void
	 */
	protected function getCSSClass()
	{
		$string = preg_replace('#^f#', '', get_class($this));
		
		do {
			$old_string = $string;
			$string = preg_replace('/([a-zA-Z])([0-9])/', '\1_\2', $string);
			$string = preg_replace('/([a-z0-9A-Z])([A-Z])/', '\1_\2', $string);
		} while ($old_string != $string);
		
		return strtolower($string);
	}
	
	
	/**
	 * Prepares content for output into HTML
	 * 
	 * @return string  The prepared content
	 */
	protected function prepare($content)
	{
		// See if the message has newline characters but not br tags, extracted from fHTML to reduce dependencies
		static $inline_tags_minus_br = '<a><abbr><acronym><b><big><button><cite><code><del><dfn><em><font><i><img><input><ins><kbd><label><q><s><samp><select><small><span><strike><strong><sub><sup><textarea><tt><u><var>';
		$content_with_newlines = (strip_tags($content, $inline_tags_minus_br)) ? $content : nl2br($content);
		
		// Check to see if we have any block-level html, extracted from fHTML to reduce dependencies
		$inline_tags = $inline_tags_minus_br . '<br>';
		$no_block_html = strip_tags($content, $inline_tags) == $content;
		
		// This code ensures the output is properly encoded for display in (X)HTML, extracted from fHTML to reduce dependencies
		$reg_exp = "/<\s*\/?\s*[\w:]+(?:\s+[\w:]+(?:\s*=\s*(?:\"[^\"]*?\"|'[^']*?'|[^'\">\s]+))?)*\s*\/?\s*>|&(?:#\d+|\w+);|<\!--.*?-->/";
		preg_match_all($reg_exp, $content, $html_matches, PREG_SET_ORDER);
		$text_matches = preg_split($reg_exp, $content_with_newlines);
		
		foreach($text_matches as $key => $value) {
			$value = htmlspecialchars($value, ENT_QUOTES, 'UTF-8');
		}
		
		for ($i = 0; $i < sizeof($html_matches); $i++) {
			$text_matches[$i] .= $html_matches[$i][0];
		}
		
		$content_with_newlines = implode($text_matches);
		
		$output  = ($no_block_html) ? '<p>' : '';
		$output .= $content_with_newlines;
		$output .= ($no_block_html) ? '</p>' : '';
		
		return $output;
	}
	
	
	/**
	 * Prints the message inside of a div with the class being 'exception %THIS_EXCEPTION_CLASS_NAME%'
	 * 
	 * @return void
	 */
	public function printMessage()
	{
		echo '<div class="exception ' . $this->getCSSClass() . '">';
		echo $this->prepare($this->message);
		echo '</div>';
	}
	
	
	/**
	 * Prints the backtrace to currently called exception inside of a pre tag with the class being 'exception %THIS_EXCEPTION_CLASS_NAME% trace'
	 * 
	 * @return void
	 */
	public function printTrace()
	{
		echo '<pre class="exception ' . $this->getCSSClass() . ' trace">';
		echo $this->formatTrace();
		echo '</pre>';
	}
	
	
	/**
	 * Reorders list items in the message based on simple string matching
	 * 
	 * @param  string $match  This should be a string to match to one of the list items - whatever the order this is in the parameter list will be the order of the list item in the adjusted message
	 * @param  string ...
	 * @return fException  The exception object, to allow for method chaining
	 */
	public function reorderMessage($match)
	{
		// If we can't find a list, don't bother continuing
		if (!preg_match('#^(.*<(?:ul|ol)[^>]*?>)(.*?)(</(?:ul|ol)>.*)$#isD', $this->message, $message_parts)) {
			return $this;
		}
		
		$matching_array = func_get_args();
		// This ensures that we match on the longest string first
		uasort($matching_array, array('self', 'sortMatchingArray'));
		
		$beginning     = $message_parts[1];
		$list_contents = $message_parts[2];
		$ending        = $message_parts[3];
		
		preg_match_all('#<li(.*?)</li>#i', $list_contents, $list_items, PREG_SET_ORDER);
		
		$ordered_items = array_fill(0, sizeof($matching_array), array());
		$other_items   = array();
		
		foreach ($list_items as $list_item) {
			foreach ($matching_array as $num => $match_string) {
				if (strpos($list_item[1], $match_string) !== FALSE) {
					$ordered_items[$num][] = $list_item[0];
					continue 2;
				}
			}
			
			$other_items[] = $list_item[0];
		}
		
		$final_list = array();
		foreach ($ordered_items as $ordered_item) {
			$final_list = array_merge($final_list, $ordered_item);
		}
		$final_list = array_merge($final_list, $other_items);
		
		$this->message = $beginning . join("\n", $final_list) . $ending;
		
		return $this;
	}
	
	
	/**
	 * Allows the message to be overwriten
	 * 
	 * @param  string $new_message  The new message for the exception
	 * @return void
	 */
	public function setMessage($new_message)
	{
		$this->message = $new_message;
	}
	
	
	/**
	 * Splits an exception with an HTML list into multiple strings each containing part of the original message
	 * 
	 * This method should be called with two or more parameters of arrays of
	 * string to match. If any of the provided strings are matching in a list
	 * item in the exception message, a new copy of the message will be created
	 * containing just the matching list items.
	 * 
	 * Here is an exception message to be split:
	 * 
	 * {{{
	 * #!html
	 * <p>The following problems were found:</p>
	 * <ul>
	 *     <li>First Name: Please enter a value</li>
	 *     <li>Last Name: Please enter a value</li>
	 *     <li>Email: Please enter a value</li>
	 *     <li>Address: Please enter a value</li>
	 *     <li>City: Please enter a value</li>
	 *     <li>State: Please enter a value</li>
	 *     <li>Zip Code: Please enter a value</li>
	 * </ul>
	 * }}}
	 * 
	 * The following PHP would split the exception into two messages:
	 * 
	 * {{{
	 * #!php
	 * list ($name_exception, $address_exception) = $exception->splitMessage(
	 *     array('First Name', 'Last Name', 'Email'),
	 *     array('Address', 'City', 'State', 'Zip Code')
	 * );
	 * }}}
	 * 
	 * The resulting messages would be:
	 * 
	 * {{{
	 * #!html
	 * <p>The following problems were found:</p>
	 * <ul>
	 *     <li>First Name: Please enter a value</li>
	 *     <li>Last Name: Please enter a value</li>
	 *     <li>Email: Please enter a value</li>
	 * </ul>
	 * }}}
	 * 
	 * and
	 * 
	 * {{{
	 * #!html
	 * <p>The following problems were found:</p>
	 * <ul>
	 *     <li>Address: Please enter a value</li>
	 *     <li>City: Please enter a value</li>
	 *     <li>State: Please enter a value</li>
	 *     <li>Zip Code: Please enter a value</li>
	 * </ul>
	 * }}}
	 * 
	 * If no list items match the strings in a parameter, the result will be
	 * an empty string, allowing for simple display:
	 * 
	 * {{{
	 * #!php
	 * fHTML::show($name_exception, 'error');
	 * }}}
	 * 
	 * An empty string is returned when none of the list items matched the
	 * strings in the parameter. If no list items are found, the first value in
	 * the returned array will be the existing message and all other array
	 * values will be an empty string.
	 * 
	 * @param  array $list_item_matches  An array of strings to filter the list items by, list items will be ordered in the same order as this array
	 * @param  array ...
	 * @return array  This will contain an array of strings corresponding to the parameters passed - see method description for details
	 */
	public function splitMessage($list_item_matches)
	{
		$class = get_class($this);
		
		$matching_arrays = func_get_args();
		
		if (!preg_match('#^(.*<(?:ul|ol)[^>]*?>)(.*?)(</(?:ul|ol)>.*)$#isD', $this->message, $matches)) {
			return array_merge(array($this->message), array_fill(0, sizeof($matching_arrays)-1, ''));
		}
		
		$beginning_html  = $matches[1];
		$list_items_html = $matches[2];
		$ending_html     = $matches[3];
		
		preg_match_all('#<li(.*?)</li>#i', $list_items_html, $list_items, PREG_SET_ORDER);
		
		$output = array();
		
		foreach ($matching_arrays as $matching_array) {
			
			// This ensures that we match on the longest string first
			uasort($matching_array, array('self', 'sortMatchingArray'));
			
			// We may match more than one list item per matching string, so we need a multi-dimensional array to hold them
			$matched_list_items = array_fill(0, sizeof($matching_array), array());
			$found              = FALSE;
			
			foreach ($list_items as $list_item) {
				foreach ($matching_array as $match_num => $matching_string) {
					if (strpos($list_item[1], $matching_string) !== FALSE) {
						$matched_list_items[$match_num][] = $list_item[0];
						$found = TRUE;
						continue 2;
					}
				}
			}
			
			if (!$found) {
				$output[] = '';
				continue;
			}
			
			// This merges all of the multi-dimensional arrays back to one so we can do a simple join
			$merged_list_items = array();
			foreach ($matched_list_items as $match_num => $matched_items) {
				$merged_list_items = array_merge($merged_list_items, $matched_items);
			}
			
			$output[] = $beginning_html . join("\n", $merged_list_items) . $ending_html;
		}
		
		return $output;
	}
}

/**
 * Provides english word inflection, notation conversion, grammar helpers and internationlization support
 * 
 * @copyright  Copyright (c) 2007-2011 Will Bond
 * @author     Will Bond [wb] <will@flourishlib.com>
 * @license    http://flourishlib.com/license
 * 
 * @package    Flourish
 * @link       http://flourishlib.com/fGrammar
 * 
 * @version    1.0.0b14
 * @changes    1.0.0b14  Fixed a bug in singularization that would affect words containing the substring `mice` or `lice` [wb, 2011-02-24]
 * @changes    1.0.0b13  Fixed the pluralization of video [wb, 2010-08-10]
 * @changes    1.0.0b12  Updated ::singularize() and ::pluralize() to be able to handle underscore_CamelCase [wb, 2010-08-06]
 * @changes    1.0.0b11  Fixed custom camelCase to underscore_notation rules [wb, 2010-06-23]
 * @changes    1.0.0b10  Removed `e` flag from preg_replace() calls [wb, 2010-06-08]
 * @changes    1.0.0b9   Fixed a bug with ::camelize() and human-friendly strings [wb, 2010-06-08]
 * @changes    1.0.0b8   Added the ::stem() method [wb, 2010-05-27]
 * @changes    1.0.0b7   Added the `$return_error` parameter to ::pluralize() and ::singularize() [wb, 2010-03-30]
 * @changes    1.0.0b6   Added missing ::compose() method [wb, 2010-03-03]
 * @changes    1.0.0b5   Fixed ::reset() to properly reset the singularization and pluralization rules [wb, 2009-10-28]
 * @changes    1.0.0b4   Added caching for various methods - provided significant performance boost to ORM [wb, 2009-06-15] 
 * @changes    1.0.0b3   Changed replacement values in preg_replace() calls to be properly escaped [wb, 2009-06-11]
 * @changes    1.0.0b2   Fixed a bug where some words would lose capitalization with ::pluralize() and ::singularize() [wb, 2009-01-25]
 * @changes    1.0.0b    The initial implementation [wb, 2007-09-25]
 */
class fGrammar
{
	// The following constants allow for nice looking callbacks to static methods
	const addCamelUnderscoreRule    = 'fGrammar::addCamelUnderscoreRule';
	const addHumanizeRule           = 'fGrammar::addHumanizeRule';
	const addSingularPluralRule     = 'fGrammar::addSingularPluralRule';
	const camelize                  = 'fGrammar::camelize';
	const humanize                  = 'fGrammar::humanize';
	const inflectOnQuantity         = 'fGrammar::inflectOnQuantity';
	const joinArray                 = 'fGrammar::joinArray';
	const pluralize                 = 'fGrammar::pluralize';
	const registerJoinArrayCallback = 'fGrammar::registerJoinArrayCallback';
	const reset                     = 'fGrammar::reset';
	const singularize               = 'fGrammar::singularize';
	const stem                      = 'fGrammar::stem';
	const underscorize              = 'fGrammar::underscorize';
	
	
	/**
	 * Cache for plural <-> singular and underscore <-> camelcase
	 * 
	 * @var array
	 */
	static private $cache = array(
		'camelize'     => array(0 => array(), 1 => array()),
		'humanize'     => array(),
		'pluralize'    => array(),
		'singularize'  => array(),
		'underscorize' => array()
	);
	
	/**
	 * Custom rules for camelizing a string
	 * 
	 * @var array
	 */
	static private $camelize_rules = array();
	
	/**
	 * Custom rules for humanizing a string
	 * 
	 * @var array
	 */
	static private $humanize_rules = array();
	
	/**
	 * The callback to replace ::joinArray()
	 * 
	 * @var callback
	 */
	static private $join_array_callback = NULL;
	
	/**
	 * Rules for plural to singular inflection of nouns
	 * 
	 * @var array
	 */
	static private $plural_to_singular_rules = array(
		'([ml])ice$'                   => '\1ouse',
		'(media|info(rmation)?|news)$' => '\1',
		'(q)uizzes$'                   => '\1uiz',
		'(c)hildren$'                  => '\1hild',
		'(p)eople$'                    => '\1erson',
		'(m)en$'                       => '\1an',
		'((?!sh).)oes$'                => '\1o',
		'((?<!o)[ieu]s|[ieuo]x)es$'    => '\1',
		'([cs]h)es$'                   => '\1',
		'(ss)es$'                      => '\1',
		'([aeo]l)ves$'                 => '\1f',
		'([^d]ea)ves$'                 => '\1f',
		'(ar)ves$'                     => '\1f',
		'([nlw]i)ves$'                 => '\1fe',
		'([aeiou]y)s$'                 => '\1',
		'([^aeiou])ies$'               => '\1y',
		'(la)ses$'                     => '\1s',
		'(.)s$'                        => '\1'
	);
	
	/**
	 * Rules for singular to plural inflection of nouns
	 * 
	 * @var array
	 */
	static private $singular_to_plural_rules = array(
		'([ml])ouse$'                  => '\1ice',
		'(media|info(rmation)?|news)$' => '\1',
		'(phot|log|vide)o$'            => '\1os',
		'^(q)uiz$'                     => '\1uizzes',
		'(c)hild$'                     => '\1hildren',
		'(p)erson$'                    => '\1eople',
		'(m)an$'                       => '\1en',
		'([ieu]s|[ieuo]x)$'            => '\1es',
		'([cs]h)$'                     => '\1es',
		'(ss)$'                        => '\1es',
		'([aeo]l)f$'                   => '\1ves',
		'([^d]ea)f$'                   => '\1ves',
		'(ar)f$'                       => '\1ves',
		'([nlw]i)fe$'                  => '\1ves',
		'([aeiou]y)$'                  => '\1s',
		'([^aeiou])y$'                 => '\1ies',
		'([^o])o$'                     => '\1oes',
		's$'                           => 'ses',
		'(.)$'                         => '\1s'
	);
	
	/**
	 * Custom rules for underscorizing a string
	 * 
	 * @var array
	 */
	static private $underscorize_rules = array();
	
	
	/**
	 * Adds a custom mapping of a non-humanized string to a humanized string for ::humanize()
	 * 
	 * @param  string $non_humanized_string  The non-humanized string
	 * @param  string $humanized_string      The humanized string
	 * @return void
	 */
	static public function addHumanizeRule($non_humanized_string, $humanized_string)
	{
		self::$humanize_rules[$non_humanized_string] = $humanized_string;
		
		self::$cache['humanize'] = array();
	}
	
	
	/**
	 * Adds a custom `camelCase` to `underscore_notation` and `underscore_notation` to `camelCase` rule
	 * 
	 * @param  string $camel_case           The lower `camelCase` version of the string
	 * @param  string $underscore_notation  The `underscore_notation` version of the string
	 * @return void
	 */
	static public function addCamelUnderscoreRule($camel_case, $underscore_notation)
	{
		$camel_case = strtolower($camel_case[0]) . substr($camel_case, 1);
		self::$underscorize_rules[$camel_case] = $underscore_notation;
		self::$camelize_rules[$underscore_notation] = $camel_case;
		
		self::$cache['camelize']     = array(0 => array(), 1 => array());
		self::$cache['underscorize'] = array();
	}
	
	
	/**
	 * Adds a custom singular to plural and plural to singular rule for ::pluralize() and ::singularize()
	 * 
	 * @param  string $singular  The singular version of the noun
	 * @param  string $plural    The plural version of the noun
	 * @return void
	 */
	static public function addSingularPluralRule($singular, $plural)
	{
		self::$singular_to_plural_rules = array_merge(
			array(
				'^(' . preg_quote($singular[0], '#') . ')' . preg_quote(substr($singular, 1), '#') . '$' =>
					'\1' . strtr(substr($plural, 1), array('\\' => '\\\\', '$' => '\\$'))
			),
			self::$singular_to_plural_rules
		);
		self::$plural_to_singular_rules = array_merge(
			array(
				'^(' . preg_quote($plural[0], '#') . ')' . preg_quote(substr($plural, 1), '#') . '$' =>
					'\1' . strtr(substr($singular, 1), array('\\' => '\\\\', '$' => '\\$'))
			),
			self::$plural_to_singular_rules
		);
		
		self::$cache['pluralize']   = array();
		self::$cache['singularize'] = array();
	}
	
	
	/**
	 * Converts an `underscore_notation`, human-friendly or `camelCase` string to `camelCase`
	 * 
	 * @param  string  $string  The string to convert
	 * @param  boolean $upper   If the camel case should be `UpperCamelCase`
	 * @return string  The converted string
	 */
	static public function camelize($string, $upper)
	{
		$upper = (int) $upper;
		if (isset(self::$cache['camelize'][$upper][$string])) {
			return self::$cache['camelize'][$upper][$string];
		}
		
		$original = $string;
		
		// Handle custom rules
		if (isset(self::$camelize_rules[$string])) {
			$string = self::$camelize_rules[$string];
			if ($upper) {
				$string = ucfirst($string);
			}
		
		} else {
			// Make a humanized string like underscore notation
			if (strpos($string, ' ') !== FALSE) {
				$string = strtolower(preg_replace('#\s+#', '_', $string));
			}
			
			// Check to make sure this is not already camel case
			if (strpos($string, '_') === FALSE) {
				if ($upper) {
					$string = ucfirst($string);
				}
				
			// Handle underscore notation
			} else {
				$string[0] = strtolower($string[0]);
				if ($upper) {
					$string = ucfirst($string);
				}
				$string = preg_replace_callback('#_([a-z0-9])#i', array('self', 'camelizeCallback'), $string);		
			}
		}
		
		self::$cache['camelize'][$upper][$original] = $string;
		return $string;
	}
	
	
	/**
	 * A callback used by ::camelize() to handle converting underscore to camelCase
	 * 
	 * @param array $match  The regular expression match
	 * @return string  The value to replace the string with
	 */
	static private function camelizeCallback($match)
	{
		return strtoupper($match[1]);
	}
	
	
	/**
	 * Composes text using fText if loaded
	 * 
	 * @param  string  $message    The message to compose
	 * @param  mixed   $component  A string or number to insert into the message
	 * @param  mixed   ...
	 * @return string  The composed and possible translated message
	 */
	static protected function compose($message)
	{
		$args = array_slice(func_get_args(), 1);
		
		if (class_exists('fText', FALSE)) {
			return call_user_func_array(
				array('fText', 'compose'),
				array($message, $args)
			);
		} else {
			return vsprintf($message, $args);
		}
	}
	
	
	/**
	 * Makes an `underscore_notation`, `camelCase`, or human-friendly string into a human-friendly string
	 * 
	 * @param  string $string  The string to humanize
	 * @return string  The converted string
	 */
	static public function humanize($string)
	{
		if (isset(self::$cache['humanize'][$string])) {
			return self::$cache['humanize'][$string];
		}
		
		$original = $string;
		
		if (isset(self::$humanize_rules[$string])) {
			$string = self::$humanize_rules[$string];	
		
		// If there is no space, it isn't already humanized
		} elseif (strpos($string, ' ') === FALSE) {
			
			// If we don't have an underscore we probably have camelCase
			if (strpos($string, '_') === FALSE) {
				$string = self::underscorize($string);
			}
			
			$string = preg_replace_callback(
				'/(\b(api|css|gif|html|id|jpg|js|mp3|pdf|php|png|sql|swf|url|xhtml|xml)\b|\b\w)/',
				array('self', 'camelizeCallback'),
				str_replace('_', ' ', $string)
			);
		}
		
		self::$cache['humanize'][$original] = $string;
		
		return $string;
	}
	
	
	/**
	 * Returns the singular or plural form of the word or based on the quantity specified
	 * 
	 * @param  mixed   $quantity                     The quantity (integer) or an array of objects to count
	 * @param  string  $singular_form                The string to be returned for when `$quantity = 1`
	 * @param  string  $plural_form                  The string to be returned for when `$quantity != 1`, use `%d` to place the quantity in the string
	 * @param  boolean $use_words_for_single_digits  If the numbers 0 to 9 should be written out as words
	 * @return string
	 */
	static public function inflectOnQuantity($quantity, $singular_form, $plural_form=NULL, $use_words_for_single_digits=FALSE)
	{
		if ($plural_form === NULL) {
			$plural_form = self::pluralize($singular_form);
		}
		
		if (is_array($quantity)) {
			$quantity = sizeof($quantity);
		}
		
		if ($quantity == 1) {
			return $singular_form;
			
		} else {
			$output = $plural_form;
			
			// Handle placement of the quantity into the output
			if (strpos($output, '%d') !== FALSE) {
				
				if ($use_words_for_single_digits && $quantity < 10) {
					static $replacements = array();
					if (!$replacements) {
						$replacements = array(
							0 => self::compose('zero'),
							1 => self::compose('one'),
							2 => self::compose('two'),
							3 => self::compose('three'),
							4 => self::compose('four'),
							5 => self::compose('five'),
							6 => self::compose('six'),
							7 => self::compose('seven'),
							8 => self::compose('eight'),
							9 => self::compose('nine')
						);
					}
					$quantity = $replacements[$quantity];
				}
				
				$output = str_replace('%d', $quantity, $output);
			}
			
			return $output;
		}
	}
	
	
	/**
	 * Returns the passed terms joined together using rule 2 from Strunk & White's 'The Elements of Style'
	 * 
	 * @param  array  $strings  An array of strings to be joined together
	 * @param  string $type     The type of join to perform, `'and'` or `'or'`
	 * @return string  The terms joined together
	 */
	static public function joinArray($strings, $type)
	{
		$valid_types = array('and', 'or');
		if (!in_array($type, $valid_types)) {
			throw new fProgrammerException(
				'The type specified, %1$s, is invalid. Must be one of: %2$s.',
				$type,
				join(', ', $valid_types)
			);
		}
		
		if (self::$join_array_callback) {
			return call_user_func(self::$join_array_callback, $strings, $type);
		}
		
		settype($strings, 'array');
		$strings = array_values($strings);
		
		switch (sizeof($strings)) {
			case 0:
				return '';
				break;
			
			case 1:
				return $strings[0];
				break;
			
			case 2:
				return $strings[0] . ' ' . $type . ' ' . $strings[1];
				break;
				
			default:
				$last_string = array_pop($strings);
				return join(', ', $strings) . ' ' . $type . ' ' . $last_string;
				break;
		}
	}
	
	
	/**
	 * Returns the plural version of a singular noun
	 * 
	 * @param  string  $singular_noun  The singular noun to pluralize
	 * @param  boolean $return_error   If this is `TRUE` and the noun can't be pluralized, `FALSE` will be returned instead
	 * @return string  The pluralized noun
	 */
	static public function pluralize($singular_noun, $return_error=FALSE)
	{
		if (isset(self::$cache['pluralize'][$singular_noun])) {
			return self::$cache['pluralize'][$singular_noun];		
		}
		
		$original    = $singular_noun;
		$plural_noun = NULL;
		
		list ($beginning, $singular_noun) = self::splitLastWord($singular_noun);
		foreach (self::$singular_to_plural_rules as $from => $to) {
			if (preg_match('#' . $from . '#iD', $singular_noun)) {
				$plural_noun = $beginning . preg_replace('#' . $from . '#iD', $to, $singular_noun);
				break;
			}
		}
		
		if (!$plural_noun) {
			if ($return_error) {
				self::$cache['pluralize'][$singular_noun] = FALSE;
				return FALSE;
			}
			throw new fProgrammerException('The noun specified could not be pluralized');
		}
		
		self::$cache['pluralize'][$original] = $plural_noun;
		
		return $plural_noun;
	}
	
	
	/**
	 * Allows replacing the ::joinArray() function with a user defined function
	 * 
	 * This would be most useful for changing ::joinArray() to work with
	 * languages other than English.
	 * 
	 * @param  callback $callback  The function to replace ::joinArray() with - should accept the same parameters and return the same type
	 * @return void
	 */
	static public function registerJoinArrayCallback($callback)
	{
		if (is_string($callback) && strpos($callback, '::') !== FALSE) {
			$callback = explode('::', $callback);	
		}
		self::$join_array_callback = $callback;
	}
	
	
	/**
	 * Resets the configuration of the class
	 * 
	 * @internal
	 * 
	 * @return void
	 */
	static public function reset()
	{
		self::$cache                    = array(
			'camelize'     => array(0 => array(), 1 => array()),
			'humanize'     => array(),
			'pluralize'    => array(),
			'singularize'  => array(),
			'underscorize' => array()
		);
		self::$camelize_rules           = array();
		self::$humanize_rules           = array();
		self::$join_array_callback      = NULL;
		self::$plural_to_singular_rules = array(
			'([ml])ice$'                   => '\1ouse',
			'(media|info(rmation)?|news)$' => '\1',
			'(q)uizzes$'                   => '\1uiz',
			'(c)hildren$'                  => '\1hild',
			'(p)eople$'                    => '\1erson',
			'(m)en$'                       => '\1an',
			'((?!sh).)oes$'                => '\1o',
			'((?<!o)[ieu]s|[ieuo]x)es$'    => '\1',
			'([cs]h)es$'                   => '\1',
			'(ss)es$'                      => '\1',
			'([aeo]l)ves$'                 => '\1f',
			'([^d]ea)ves$'                 => '\1f',
			'(ar)ves$'                     => '\1f',
			'([nlw]i)ves$'                 => '\1fe',
			'([aeiou]y)s$'                 => '\1',
			'([^aeiou])ies$'               => '\1y',
			'(la)ses$'                     => '\1s',
			'(.)s$'                        => '\1'
		);
		self::$singular_to_plural_rules = array(
			'([ml])ouse$'                  => '\1ice',
			'(media|info(rmation)?|news)$' => '\1',
			'(phot|log|vide)o$'            => '\1os',
			'^(q)uiz$'                     => '\1uizzes',
			'(c)hild$'                     => '\1hildren',
			'(p)erson$'                    => '\1eople',
			'(m)an$'                       => '\1en',
			'([ieu]s|[ieuo]x)$'            => '\1es',
			'([cs]h)$'                     => '\1es',
			'(ss)$'                        => '\1es',
			'([aeo]l)f$'                   => '\1ves',
			'([^d]ea)f$'                   => '\1ves',
			'(ar)f$'                       => '\1ves',
			'([nlw]i)fe$'                  => '\1ves',
			'([aeiou]y)$'                  => '\1s',
			'([^aeiou])y$'                 => '\1ies',
			'([^o])o$'                     => '\1oes',
			's$'                           => 'ses',
			'(.)$'                         => '\1s'
		);	
	}
	
	
	/**
	 * Returns the singular version of a plural noun
	 * 
	 * @param  string  $plural_noun   The plural noun to singularize
	 * @param  boolean $return_error  If this is `TRUE` and the noun can't be pluralized, `FALSE` will be returned instead
	 * @return string  The singularized noun
	 */
	static public function singularize($plural_noun, $return_error=FALSE)
	{
		if (isset(self::$cache['singularize'][$plural_noun])) {
			return self::$cache['singularize'][$plural_noun];		
		}
		
		$original      = $plural_noun;
		$singular_noun = NULL;
		
		list ($beginning, $plural_noun) = self::splitLastWord($plural_noun);
		foreach (self::$plural_to_singular_rules as $from => $to) {
			if (preg_match('#' . $from . '#iD', $plural_noun)) {
				$singular_noun = $beginning . preg_replace('#' . $from . '#iD', $to, $plural_noun);
				break;
			}
		}
		
		if (!$singular_noun) {
			if ($return_error) {
				self::$cache['singularize'][$plural_noun] = FALSE;
				return FALSE;
			}
			throw new fProgrammerException('The noun specified could not be singularized');
		}
		
		self::$cache['singularize'][$original] = $singular_noun;
		
		return $singular_noun;
	}
	
	
	/**
	 * Splits the last word off of a `camelCase` or `underscore_notation` string
	 * 
	 * @param  string $string  The string to split the word from
	 * @return array  The first element is the beginning part of the string, the second element is the last word
	 */
	static private function splitLastWord($string)
	{
		// Handle strings with spaces in them
		if (strpos($string, ' ') !== FALSE) {
			return array(substr($string, 0, strrpos($string, ' ')+1), substr($string, strrpos($string, ' ')+1));
		}
		
		// Handle underscore notation
		if ($string == self::underscorize($string)) {
			if (strpos($string, '_') === FALSE) { return array('', $string); }
			return array(substr($string, 0, strrpos($string, '_')+1), substr($string, strrpos($string, '_')+1));
		}
		
		// Handle camel case
		if (preg_match('#(.*)((?<=[a-zA-Z_]|^)(?:[0-9]+|[A-Z][a-z]*)|(?<=[0-9A-Z_]|^)(?:[A-Z][a-z]*))$#D', $string, $match)) {
			return array($match[1], $match[2]);
		}
		
		return array('', $string);
	}
	
	
	/**
	 * Uses the Porter Stemming algorithm to create the stem of a word, which is useful for searching
	 * 
	 * See http://tartarus.org/~martin/PorterStemmer/ for details about the
	 * algorithm.
	 * 
	 * @param string $word  The word to get the stem of
	 * @return string  The stem of the word
	 */
	static public function stem($word)
	{
		$s_v  = '^([^aeiou][^aeiouy]*)?[aeiouy]';
		$mgr0 = $s_v . '[aeiou]*[^aeiou][^aeiouy]*';
		
		$s_v_regex  = '#' . $s_v . '#';
		$mgr0_regex = '#' . $mgr0 . '#';
		$meq1_regex = '#' . $mgr0 . '([aeiouy][aeiou]*)?$#';
		$mgr1_regex = '#' . $mgr0 . '[aeiouy][aeiou]*[^aeiou][^aeiouy]*#';
		
		$word = fUTF8::ascii($word);
		$word = strtolower($word);
		
		if (strlen($word) < 3) {
			return $word;
		}
		
		if ($word[0] == 'y') {
			$word = 'Y' . substr($word, 1);
		}
		
		// Step 1a
		$word = preg_replace('#^(.+?)(?:(ss|i)es|([^s])s)$#', '\1\2\3', $word);
		
		// Step 1b
		if (preg_match('#^(.+?)eed$#', $word, $match)) {
			if (preg_match($mgr0_regex, $match[1])) {
				$word = substr($word, 0, -1);
			}
			
		} elseif (preg_match('#^(.+?)(ed|ing)$#', $word, $match)) {
			if (preg_match($s_v_regex, $match[1])) {
				$word = $match[1];
				if (preg_match('#(at|bl|iz)$#', $word)) {
					$word .= 'e';
				} elseif (preg_match('#([^aeiouylsz])\1$#', $word)) {
					$word = substr($word, 0, -1);
				} elseif (preg_match('#^[^aeiou][^aeiouy]*[aeiouy][^aeiouwxy]$#', $word)) {
					$word .= 'e';
				}
			}
		}
		
		// Step 1c
		if (substr($word, -1) == 'y') {
			$stem = substr($word, 0, -1);
			if (preg_match($s_v_regex, $stem)) {
				$word = $stem . 'i';
			}
		}
		
		// Step 2
		if (preg_match('#^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$#', $word, $match)) {
			if (preg_match($mgr0_regex, $match[1])) {
				$word = $match[1] . strtr(
					$match[2],
					array(
						'ational' => 'ate',  'tional'  => 'tion', 'enci'    => 'ence',
						'anci'    => 'ance', 'izer'    => 'ize',  'bli'     => 'ble',
						'alli'    => 'al',   'entli'   => 'ent',  'eli'     => 'e',
						'ousli'   => 'ous',  'ization' => 'ize',  'ation'   => 'ate',
						'ator'    => 'ate',  'alism'   => 'al',   'iveness' => 'ive',
						'fulness' => 'ful',  'ousness' => 'ous',  'aliti'   => 'al',
						'iviti'   => 'ive',  'biliti'  => 'ble',  'logi'    => 'log'
					)
				);
			}
		}
		
		// Step 3
		if (preg_match('#^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$#', $word, $match)) {
			if (preg_match($mgr0_regex, $match[1])) {
				$word = $match[1] . strtr(
					$match[2],
					array(
						'icate' => 'ic', 'ative' => '', 'alize' => 'al', 'iciti' => 'ic',
						'ical'  => 'ic', 'ful'   => '', 'ness'  => ''
					)
				);
			}
		}
		
		// Step 4
		if (preg_match('#^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize|(?<=[st])ion)$#', $word, $match) && preg_match($mgr1_regex, $match[1])) {
			$word = $match[1];
		}
		
		// Step 5
		if (substr($word, -1) == 'e') {
			$stem = substr($word, 0, -1);
			if (preg_match($mgr1_regex, $stem)) {
				$word = $stem;
			} elseif (preg_match($meq1_regex, $stem) && !preg_match('#^[^aeiou][^aeiouy]*[aeiouy][^aeiouwxy]$#', $stem)) {
				$word = $stem;
			}
		}
		
		if (preg_match('#ll$#', $word) && preg_match($mgr1_regex, $word)) {
			$word = substr($word, 0, -1);
		}
		
		if ($word[0] == 'Y') {
			$word = 'y' . substr($word, 1);
		}
		
		return $word;
	}
	
	
	/**
	 * Converts a `camelCase`, human-friendly or `underscore_notation` string to `underscore_notation`
	 * 
	 * @param  string $string  The string to convert
	 * @return string  The converted string
	 */
	static public function underscorize($string)
	{
		if (isset(self::$cache['underscorize'][$string])) {
			return self::$cache['underscorize'][$string];		
		}
		
		$original = $string;
		$string = strtolower($string[0]) . substr($string, 1);
		
		// Handle custom rules
		if (isset(self::$underscorize_rules[$string])) {
			$string = self::$underscorize_rules[$string];
		
		// If the string is already underscore notation then leave it
		} elseif (strpos($string, '_') !== FALSE && strtolower($string) == $string) {
		
		// Allow humanized string to be passed in
		} elseif (strpos($string, ' ') !== FALSE) {
			$string = strtolower(preg_replace('#\s+#', '_', $string));
		
		} else {
			do {
				$old_string = $string;
				$string = preg_replace('/([a-zA-Z])([0-9])/', '\1_\2', $string);
				$string = preg_replace('/([a-z0-9A-Z])([A-Z])/', '\1_\2', $string);
			} while ($old_string != $string);
			
			$string = strtolower($string);
		}
		
		self::$cache['underscorize'][$original] = $string;
		
		return $string;
	}
	
	
	/**
	 * Forces use as a static class
	 * 
	 * @return fGrammar
	 */
	private function __construct() { }
}

/**
 * Provides large/precise number support
 * 
 * @copyright  Copyright (c) 2008-2011 Will Bond
 * @author     Will Bond [wb] <will@flourishlib.com>
 * @license    http://flourishlib.com/license
 * 
 * @package    Flourish
 * @link       http://flourishlib.com/fNumber
 * 
 * @version    1.0.0b3
 * @changes    1.0.0b3  Added the `$remove_zero_fraction` parameter to ::format() [wb, 2011-02-02]
 * @changes    1.0.0b2  Fixed a bug with parsing decimal numbers in scientific notation [wb, 2010-04-13]
 * @changes    1.0.0b   The initial implementation [wb, 2008-07-21]
 */
class fNumber
{
	// The following constants allow for nice looking callbacks to static methods
	const baseConvert              = 'fNumber::baseConvert';
	const pi                       = 'fNumber::pi';
	const registerFormatCallback   = 'fNumber::registerFormatCallback';
	const registerUnformatCallback = 'fNumber::registerUnformatCallback';
	const reset                    = 'fNumber::reset';
	
	
	/**
	 * A callback to process all values through
	 * 
	 * @var callback
	 */
	static private $format_callback = NULL;
	
	/**
	 * A callback to process all values through
	 * 
	 * @var callback
	 */
	static private $unformat_callback = NULL;
	
	
	/**
	 * Converts any positive integer between any two bases ranging from `2` to `16`
	 * 
	 * @param  fNumber|string $number     The positive integer to convert
	 * @param  integer        $from_base  The base to convert from - must be between `2` and `16`
	 * @param  integer        $to_base    The base to convert to - must be between `2` and `16`
	 * @return string  The number converted to the new base
	 */
	static public function baseConvert($number, $from_base, $to_base)
	{
		if ($number instanceof fNumber && $from_base != 10) {
			throw new fProgrammerException(
				'The from base specified, %s, is not valid for an fNumber object',
				$from_base
			);
		}
		
		if (strlen($number) && $number[0] == '+') {
			$number = substr($number, 1);
		}
		
		if (!ctype_xdigit($number)) {
			throw new fProgrammerException(
				'The number specified, %s, does not appear to be a positive integer. Negative numbers and fractions are not supported due the different encoding schemes that can be used.',
				$number
			);
		}
		
		if (!is_numeric($from_base) || $from_base < 2 || $from_base > 16) {
			throw new fProgrammerException(
				'The from base specified, %1$s, is not valid base between %2$s and %3$s',
				$from_base,
				'2',
				'16'
			);
		}
		
		if (!is_numeric($to_base) || $to_base < 2 || $to_base > 16) {
			throw new fProgrammerException('The to base specified, %1$s, is not valid base between %2$s and %3$s',
				$from_base,
				'2',
				'16'
			);
		}
		
		$base_string = '0123456789ABCDEF';
		$base_map = array(
			'A' => 10, 'B' => 11, 'C' => 12, 'D' => 13, 'E' => 14, 'F' => 15
		);
		
		/* Convert input number to base 10 */
		if ($from_base != 10) {
			$length   = strlen($number);
			$decimal  = new fNumber('0');
			$base_num = new fNumber($from_base);
			
			for($i = 0; $i < $length; $i++) {
				$char  = strtoupper($number[$i]);
				$value = new fNumber((isset($base_map[$char])) ? $base_map[$char] : $char);
				$decimal = $decimal->add($value->mul($base_num->pow($length-($i+1)))->round(0));
			}
		} elseif (!$number instanceof fNumber) {
			$decimal = new fNumber($number);
		} else {
			$decimal = $number;
		}
		
		$output = '';
		
		if ($to_base != 10) {
			do {
				$frac   = $decimal->div($to_base, 3)->__toString();
				$frac   = '0' . substr($frac, strpos($frac, '.'));
				$x      = (int) ($frac * $to_base + 1.5);
				
				$output = $base_string[$x-1] . $output;
				
				$decimal = $decimal->div($to_base, 0);
				
			} while($decimal->gt('0.0'));
		} else {
			$output = $decimal->__toString();
		}
		
		return $output;
	}
	
	
	/**
	 * Compared the two numbers
	 * 
	 * @param  string $number1  The first number to compare
	 * @param  string $number2  The second number to compare
	 * @return integer  Less than `0` if `$number1` is less than `$number2`, `0` if equal, greater than `0` if `$number1` is greater than `$number2`
	 */
	static private function cmp($number1, $number2)
	{
		$number1 = self::fixSign($number1);
		$number2 = self::fixSign($number2);
		
		if ($number1[0] != $number2[0]) {
			return ($number1[0] == '+') ? 1 : -1;
		}
		
		if ($number1[0] == '-') {
			return strnatcmp(substr($number2, 1), substr($number1, 1));
		} else {
			return strnatcmp(substr($number1, 1), substr($number2, 1));
		}
	}
	
	
	/**
	 * Makes sure a number has a sign
	 * 
	 * @param  string $number  The number to check
	 * @return string  The number with a sign
	 */
	static private function fixSign($number)
	{
		$number = (string) $number;
		if (ctype_digit($number[0])) {
			$number = '+' . $number;
		}
		return $number;
	}
	
	
	/**
	 * Checks to see if a number is equal to zero
	 * 
	 * @param  string $number  The number to check, first character should be the sign
	 * @return boolean  If the number is equal to zero
	 */
	static private function isZero($number)
	{
		return trim(substr(str_replace('.', '', $number), 1), '0') == '';
	}
	
	
	/**
	 * Normalizes two numbers to the same number of decimal places
	 * 
	 * @throws fValidationException  When `$number1` or `$number2` is not a valid number
	 * 
	 * @param  fNumber|string $number1  The first number to normalize
	 * @param  fNumber|string $number2  The second number to normalize
	 * @param  integer        $scale    The number of decimal places to normalize to
	 * @return array  The two normalized numbers as strings
	 */
	static private function normalize($number1, $number2, $scale=NULL)
	{
		$number1 = self::parse($number1, 'array');
		$number2 = self::parse($number2, 'array');
		
		if ($scale !== NULL || $number1['fraction'] || $number2['fraction']) {
			
			if ($scale === NULL) {
				$frac_len = max(strlen($number1['fraction']), strlen($number2['fraction']));
			} else {
				$frac_len = $scale;
			}
			
			if ($scale !== NULL && strlen($number1['fraction']) > $scale) {
				$number1['fraction'] = substr($number1['fraction'], 0, $scale);
			} else {
				$number1['fraction'] = str_pad($number1['fraction'], $frac_len, '0', STR_PAD_RIGHT);
			}
			if ($scale !== NULL && strlen($number2['fraction']) > $scale) {
				$number2['fraction'] = substr($number2['fraction'], 0, $scale);
			} else {
				$number2['fraction'] = str_pad($number2['fraction'], $frac_len, '0', STR_PAD_RIGHT);
			}
			
			$number1 = join('.', $number1);
			$number2 = join('.', $number2);
		} else {
			$number1 = $number1['integer'];
			$number2 = $number2['integer'];
		}
		
		$len = max(strlen($number1)-1, strlen($number2)-1);
		
		$number1 = $number1[0] . str_pad(substr($number1, 1), $len, '0', STR_PAD_LEFT);
		$number2 = $number2[0] . str_pad(substr($number2, 1), $len, '0', STR_PAD_LEFT);
		
		return array($number1, $number2);
	}
	
	
	/**
	 * Parses a number to ensure it is valid
	 * 
	 * @throws fValidationException  When `$number` is not a valid number
	 * 
	 * @param  object|string $number   The number to parse
	 * @param  string        $element  The element to return: `'number'`, `'integer'`, `'fraction'`, `'array'`
	 * @return mixed  The requested parsed element
	 */
	static private function parse($number, $element)
	{
		if (is_object($number) && is_callable(array($number, '__toString'))) {
			$number = $number->__toString();
		} else {
			$number = (string) $number;
		}
		$number = trim($number);
		
		if (self::$unformat_callback) {
			$number = call_user_func(self::$unformat_callback, $number);
		} else {
			$number = str_replace(',', '', $number);	
		}
		
		$matched = preg_match('#^([+\-]?)((?:\d*\.)?\d+)(?:e([+\-]?)(\d+))?$#iD', $number, $matches);
		
		if (!$matched) {
			throw new fValidationException(
				'The number specified, %s, is invalid.',
				$number
			);
		}
		
		// Determine the sign
		$sign  = ($matches[1] == '-') ? '-' : '+';
		
		$number = self::stripLeadingZeroes($matches[2]);
		
		$exponent      = (isset($matches[4])) ? $matches[4] : NULL;
		$exponent_sign = (isset($matches[3])) ? $matches[3] : NULL;
		
		// Adjust the number by the exponent
		if ($exponent) {
			
			// A negative exponent means bringing the decimal to the left
			if ($exponent_sign == '-') {
				$decimal_pos = strpos($number, '.');
				
				if ($decimal_pos === FALSE) {
					$fraction = '';
					$integer  = $number;
				} else {
					$fraction = substr($number, strpos($number, '.')+1);
					$integer  = substr($number, 0, strpos($number, '.'));
				}
				
				if (strlen($integer) < $exponent) {
					$before_decimal = '0';
					$after_decimal  = str_pad($integer, $exponent, '0', STR_PAD_LEFT);
				} else {
					$break_point    = strlen($integer)-$exponent;
					$before_decimal = substr($integer, 0, $break_point);
					$after_decimal  = substr($integer, $break_point);
				}
				
				$number = $before_decimal . '.' . $after_decimal . $fraction;
			
			// A positive exponent means extending the number to the right
			} else {
				$number .= str_pad('', $exponent, '0', STR_PAD_RIGHT);
			}
		}
		
		// Strip any leading zeros that may have been added
		$number = self::stripLeadingZeroes($number);
		
		if (self::isZero($sign . $number)) {
			$sign = '+';
		}
		
		$parts = explode('.', $sign . $number);
		
		$output = array();
		$output['integer']  = $parts[0];
		$output['fraction'] = (isset($parts[1])) ? $parts[1] : '';
		
		if ($element == 'integer') {
			return $output['integer'];
		}
		if ($element == 'fraction') {
			return $output['fraction'];
		}
		if ($element == 'array') {
			return $output;
		}
		
		return join('.', $parts);
	}
	
	
	/**
	 * Adds two numbers together
	 * 
	 * @throws fValidationException  When `$number1` or `$number2` is not a valid number
	 * 
	 * @param  string  $number1  The first addend
	 * @param  string  $number2  The second addend
	 * @param  integer $scale    The number of digits after the decimal
	 * @return string  The sum of the two numbers
	 */
	static private function performAdd($number1, $number2, $scale=NULL)
	{
		list($number1, $number2) = self::normalize($number1, $number2);
		
		if (self::isZero($number1)) {
			return self::setScale($number2, $scale);
		} elseif (self::isZero($number2)) {
			return self::setScale($number1, $scale);
		}
		
		// If the two numbers differ in sign, we need to subtract instead
		if ($number1[0] != $number2[0]) {
			if ($number1[0] == '-') {
				return self::performSub($number2, '+' . substr($number1, 1));
			}
			return self::performSub($number1, '+' . substr($number2, 1));
		}
		
		$carry  = 0;
		$output = '';
		for ($i=strlen($number1)-1; $i>0; $i--) {
			if ($number1[$i] == '.') {
				$output = '.' . $output;
				continue;
			}
			$sum = $number1[$i] + $number2[$i] + $carry;
			$carry = (strlen($sum) > 1) ? substr($sum, 0, -1) : 0;
			$output = substr($sum, -1) . $output;
		}
		if ($carry) {
			$output = $carry . $output;
		}
		
		$output = self::setScale($number1[0] . $output, $scale);
		
		return self::stripLeadingZeroes($output);
	}
	
	
	/**
	 * Divides a number by another
	 * 
	 * @throws fValidationException  When `$dividend` or `$divisor` is not a valid number
	 * 
	 * @param  string  $dividend    The number to be divided
	 * @param  string  $divisor     The number to divide by
	 * @param  integer &$remainder  The remainder from the division
	 * @param  integer $scale       The number of digits to return after the decimal
	 * @return string  The quotient
	 */
	static private function performDiv($dividend, $divisor, &$remainder=NULL, $scale=NULL)
	{
		list ($dividend, $divisor) = self::normalize($dividend, $divisor);
		
		$dividend = self::stripLeadingZeroes($dividend);
		$divisor  = self::stripLeadingZeroes($divisor);
								
		if (self::isZero($dividend)) {
			$remainder = '+0';
			return self::setScale('+0', $scale);;
		}
		
		if (self::isZero($divisor)) {
			throw new fValidationException(
				'The divisor specified, %s, is zero, which is an invalid divisor',
				$divisor
			);
		}
		
		$sign = ($dividend[0] == $divisor[0]) ? '+' : '-';
		
		$after_decimal = 0;
		
		if (strpos($dividend, '.') !== FALSE) {
			$dividend = str_replace('.', '', $dividend);
			$divisor  = str_replace('.', '', $divisor);
		}
		
		// Here we make sure we can divide the dividend at least once
		if ($scale !== NULL) {
			for ($i=0; $i < $scale; $i++) {
				$dividend .= '0';
				$after_decimal++;
			}
		}
		
		if (strlen($dividend) < strlen($divisor)) {
			$remainder = $dividend;
			return self::setScale('+0', $scale);
		}
		
		// Perform multiplication using Knuth's algorithm from Art of Computer Science Vol 2
		$u = '+' . substr($dividend, 1);
		$v = '+' . substr($divisor, 1);
		
		$n = strlen($v) - 1;
		$m = (strlen($u) - 1) - $n;
		
		
		// This is for single digit divisors
		if ($n == 1) {
			$n = strlen($u) - 1;
			$w = $sign . str_pad('', $n, '0');
			$r = 0;
			$j = 1;
			while ($j <= $n) {
				$w[$j] = floor((($r*10)+$u[$j])/$v[1]);
				$r = (($r*10)+$u[$j]) % $v[1];
				$j++;
			}
			$quotient  = $w;
			$remainder = '+' . $r;
			
		// This is for multi-digit divisors
		} else {
		
			$quotient = '0' . str_pad('', $m, '0');
			
			// Step D1
			$d = floor(10/($v[1] + 1));
			
			$u = self::performMul($u, $d);
			$v = self::performMul($v, $d);
			
			if (strlen($u) == strlen($dividend)) {
				$u = '0' . substr($u, 1);
			} else {
				$u = substr($u, 1);
			}
			
			// Step D2
			$j = 0;
			
			while ($j <= $m) {
				// Step D3
				$uj1 = (isset($u[$j+1])) ? $u[$j+1] : '0';
					
				if ($u[$j] == $v[1]) {
					$q = 9;
				} else {
					$q = floor((($u[$j]*10)+$uj1)/$v[1]);
				}
				
				$uj2 = (isset($u[$j+2])) ? $u[$j+2] : '0';
				if ($v[2] * $q > (($u[$j]*10)+$uj1-($q*$v[1]))*10 + $uj2) {
					$q -= 1;
					if ($v[2] * $q > (($u[$j]*10)+$uj1-($q*$v[1]))*10 + $uj2) {
						$q -= 1;
					}
				}
				
				// Step D4
				$ujn = self::performSub(substr($u, $j, $n+1), self::performMul($q, $v));
				while (strlen($ujn)-1 < $n+1) {
					$ujn = $ujn[0] . '0' . substr($ujn, 1);
				}
				while (strlen($ujn)-1 > $n+1) {
					$ujn = $ujn[0] . substr($ujn, 2);
				}
				$borrow = FALSE;
				if ($ujn[0] == '-') {
					$ujn = self::performAdd(self::performPow('10', $n+1), $ujn);
					$borrow = TRUE;
				}
				while (strlen($ujn)-1 > $n+1) {
					$ujn = $ujn[0] . substr($ujn, 2);
				}
				
				// Step D5
				if ($borrow) {
					// Step D6
					$q--;
					$ujn = substr(self::performAdd($v, $ujn), 1);
				}
				$u = substr($u, 0, $j) . substr($ujn, 1) . substr($u, $j+$n+1);
				
				$quotient[$j] = $q;
				
				// Step D7
				$j++;
			}
			
			$remainder = self::performDiv(substr($u, 1+$m, $n), $d);
		}
		
		if (strlen($quotient) < $after_decimal) {
			$quotient = str_pad($quotient, $after_decimal+1, '0', STR_PAD_LEFT);
		}
		
		$integer  = substr($quotient, 0, strlen($quotient)-$after_decimal);
		$fraction = substr($quotient, strlen($quotient)-$after_decimal);
		$fraction = (strlen($fraction)) ? '.' . $fraction : '';
		
		$quotient = $integer . $fraction;
		$quotient = self::stripLeadingZeroes($quotient);
		if (ctype_digit($quotient[0])) {
			$quotient = $sign . $quotient;
		}
		
		return $quotient;
	}
	
	
	/**
	 * Multiplies two numbers
	 * 
	 * @param  string  $multiplicand  The number to be multiplied
	 * @param  string  $multiplier    The number of times to multiply the multiplicand
	 * @param  integer $scale         The number of digits after the decimal
	 * @return string  The product
	 */
	static private function performMul($multiplicand, $multiplier, $scale=NULL)
	{
		$multiplicand = (string) $multiplicand;
		$multiplier   = (string) $multiplier;
		
		$multiplicand = self::fixSign($multiplicand);
		$multiplier   = self::fixSign($multiplier);
		
		if (self::isZero($multiplicand) || self::isZero($multiplier)) {
			return self::setScale('+0', $scale);
		}
		
		$after_decimal = 0;
		
		if (strpos($multiplicand, '.') !== FALSE) {
			$after_decimal += strlen($multiplicand) - (strpos($multiplicand, '.') + 1);
			$multiplicand = str_replace('.', '', $multiplicand);
		}
		
		if (strpos($multiplier, '.') !== FALSE) {
			$after_decimal += strlen($multiplier) - (strpos($multiplier, '.') + 1);
			$multiplier = str_replace('.', '', $multiplier);
		}
		
		// Perform multiplication using Knuth's algorithm from Art of Computer Science Vol 2
		$n = strlen($multiplicand) - 1;
		$m = strlen($multiplier) - 1;
		
		$product    = $multiplier . str_pad('', $n, '0');
		$product[0] = ($multiplicand[0] == $multiplier[0]) ? '+' : '-';
		
		$j = $m;
		
		while ($j > 0) {
			if ($multiplier[$j] == '0') {
				$product[$j] = '0';
			}
			
			$i = $n;
			$k = 0;
			
			while ($i > 0) {
				$t = ($multiplicand[$i] * $multiplier[$j]) + $product[$i+$j] + $k;
				$product[$i+$j] = $t % 10;
				$k = (int) $t/10;
				--$i;
			}
			$product[$j] = $k;
			
			--$j;
		}
		
		$integer  = substr($product, 0, strlen($product)-$after_decimal);
		$fraction = substr($product, strlen($product)-$after_decimal);
		$fraction = (strlen($fraction)) ? '.' . $fraction : '';
		
		$product = $integer . $fraction;
		
		$product = self::setScale($product, $scale);
		$product = self::stripLeadingZeroes($product);
		
		return $product;
	}
	
	
	/**
	 * Calculates the integer power of a number
	 * 
	 * @throws fValidationException  When `$number` or `$power` is not a valid number or when `$power` is outside of the normal 32-bit integer range
	 * 
	 * @param  string $number     The number to raise to the power
	 * @param  string $power      The power to raise to, must be between `âˆ’2,147,483,648` and `2,147,483,647`
	 * @return string  The product
	 */
	static private function performPow($number, $power, $scale=NULL)
	{
		$number = self::fixSign($number);
		$power  = self::fixSign($power);
		
		if (self::cmp($power, '-2147483648') < 0 || self::cmp($power, '+2147483647') > 0) {
			throw new fValidationException(
				'The power specified, %1$s, is beyond the range of supported powers. Only powers between %2$s and %3$s are supported.',
				$power,
				'-2147483648',
				'2147483647'
			);
		}
		
		if (self::isZero($power)) {
			return '+1';
		}
		
		$negative_power = $power[0] == '-';
		
		$power = '+' . substr($power, 1);
		
		if ($power%2 == 0) {
			$product = self::performPow(self::performMul($number, $number), $power/2);
		} else {
			$product = self::performMul($number, self::performPow(self::performMul($number, $number), floor($power/2)));
		}
		
		if ($negative_power) {
			$product = self::performDiv('+1', $product, $trash, $scale);
		}
		
		$product = self::setScale($product, $scale);
		
		return $product;
	}
	
	
	/**
	 * Subtracts the second number from the first
	 * 
	 * @throws fValidationException  When `$minuend` or `$subtrahend` is not a valid number
	 * 
	 * @param  string $minuend     The number to subtract from
	 * @param  string $subtrahend  The number to subtract
	 * @return string  The difference
	 */
	static private function performSub($minuend, $subtrahend, $scale=NULL)
	{
		list($minuend, $subtrahend) = self::normalize($minuend, $subtrahend);
		
		if ($subtrahend[0] == '-') {
			// If both are negative we are really subtracting the minuend from the subtrahend
			if ($minuend[0] == '-') {
				return self::performSub('+' . substr($subtrahend, 1), '+' . substr($minuend, 1), $scale);
			}
			// If the minuend is positive we are just doing an addition
			return self::performAdd('+' . substr($subtrahend, 1), '+' . substr($minuend, 1), $scale);
		}
		
		// When the minuend is negative and the subtrahend positive, they are added
		if ($minuend[0] == '-') {
			$sum = self::performAdd('+' . substr($minuend, 1), $subtrahend, $scale);
			return '-' . substr($sum, 1);
		}
		
		// If the subtrahend is bigger than the minuend, we reverse the
		// subtraction and reverse the sign of the minuend
		if (self::cmp($minuend, $subtrahend) < 0) {
			$diff = self::performSub('+' . substr($subtrahend, 1), '+' . substr($minuend, 1), $scale);
			$diff = substr($diff, 1);
			return ($minuend[0] == '+') ? '-' . $diff : '+' . $diff;
		}
		
		$borrow = 0;
		$output = '';
		for ($i=strlen($minuend)-1; $i>0; $i--) {
			if ($minuend[$i] == '.') {
				$output = '.' . $output;
				continue;
			}
			$diff = $minuend[$i] - $subtrahend[$i] - $borrow;
			$borrow = 0;
			while ($diff < 0) {
				$borrow += 1;
				$diff += 10;
			}
			$output = $diff . $output;
		}
		
		$output = self::setScale($minuend[0] . $output, $scale);
		
		return self::stripLeadingZeroes($output);
	}
	
	
	/**
	 * Returns the value for pi with a scale of up to 500
	 * 
	 * @param  integer $scale  The number of places after the decimal to return
	 * @return fNumber  Pi
	 */
	static public function pi($scale)
	{
		static $pi_places = '14159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706798214808651328230664709384460955058223172535940812848111745028410270193852110555964462294895493038196442881097566593344612847564823378678316527120190914564856692346034861045432664821339360726024914127372458700660631558817488152092096282925409171536436789259036001133053054882046652138414695194151160943305727036575959195309218611738193261179310511854807446237996274956735188575272489122793818301194912';
		
		if (is_numeric($scale)) {
			$scale = (int) $scale;
		}
		if (!is_numeric($scale) || $scale < 0 || $scale > 500) {
			throw new fProgrammerException(
				'The scale specified, %1$s, is outside the valid scale for pi (%2$s to %3$s)',
				$scale,
				'0',
				'500'
			);
		}
		
		$fraction = substr($pi_places, 0, $scale);
		$fraction = (strlen($fraction)) ? '.' . $fraction : '';
		
		return new fNumber('3' . $fraction);
	}
	
	
	/**
	 * Allows setting a callback to translate or modify any return values from ::format()
	 * 
	 * The callback should accept two parameters:
	 *  - `$value`: the string value of the number
	 *  - `$remove_zero_fraction`: a boolean indicating if a zero fraction should be removed
	 * 
	 * The callback should return a string, the formatted `$value`.
	 * 
	 * @param  callback $callback  The callback to pass the fNumber value to - see method description for parameters
	 * @return void
	 */
	static public function registerFormatCallback($callback)
	{
		if (is_string($callback) && strpos($callback, '::') !== FALSE) {
			$callback = explode('::', $callback);	
		}
		self::$format_callback = $callback;
	}
	
	
	/**
	 * Allows setting a callback to clean any formatted values so they can be properly parsed - useful for languages where `,` is used as the decimal point
	 * 
	 * @param  callback $callback  The callback to pass formatted strings to. Should accept a formatted string and return a string the is a valid number using `.` as the decimal point.
	 * @return void
	 */
	static public function registerUnformatCallback($callback)
	{
		if (is_string($callback) && strpos($callback, '::') !== FALSE) {
			$callback = explode('::', $callback);	
		}
		self::$unformat_callback = $callback;
	}
	
	
	/**
	 * Resets the configuration of the class
	 * 
	 * @internal
	 * 
	 * @return void
	 */
	static public function reset()
	{
		self::$format_callback   = NULL;
		self::$unformat_callback = NULL;
	}
	
	
	/**
	 * Sets the scale for a number
	 * 
	 * @param  string  $number  The number to set the scale for
	 * @param  integer $scale   The number of digits to have after the decimal
	 * @return string  The scaled number
	 */
	static private function setScale($number, $scale)
	{
		if ($scale === NULL) {
			return $number;
		}
		
		$parts = explode('.', $number);
		$integer  = $parts[0];
		$fraction = (isset($parts[1])) ? $parts[1] : '';
		
		if (strlen($fraction) > $scale) {
			$fraction = substr($fraction, 0, $scale);
		} else {
			$fraction = str_pad($fraction, $scale, '0', STR_PAD_RIGHT);
		}
		
		$fraction = (strlen($fraction)) ? '.' . $fraction : '';
		
		return $integer . $fraction;
	}
	
	
	/**
	 * Strips the leading zeroes off of a number
	 * 
	 * @param  string $number  The number to strip
	 * @return string  The number with leading zeroes stripped
	 */
	static private function stripLeadingZeroes($number)
	{
		$number = (string) $number;
		
		if (ctype_digit($number[0]) || $number[0] == '.') {
			$sign = '';
		} else {
			$sign = $number[0];
			$number = substr($number, 1);
		}
		
		$number = ltrim($number, '0');
		if (strlen($number) == 0 || $number[0] == '.') {
			$number = '0' . $number;
		}
		return $sign . $number;
	}
	
	
	/**
	 * The scale (number of digits after the decimal) of the number
	 * 
	 * @var integer
	 */
	private $scale;
	
	/**
	 * The value of the number
	 * 
	 * @var string
	 */
	private $value;
	
	
	/**
	 * Creates a large/precise number
	 * 
	 * @throws fValidationException  When `$value` is not a valid number
	 * 
	 * @param  string  $value  The value for the number - any valid PHP integer or float format including values with `e` exponents
	 * @param  integer $scale  The number of digits after the decimal place, defaults to number of digits in `$value`
	 * @return fNumber
	 */
	public function __construct($value, $scale=NULL)
	{
		$value = self::parse($value, 'array');
		
		if ($scale !== NULL) {
			if (strlen($value['fraction']) > $scale) {
				$value['fraction'] = substr($value['fraction'], 0, $scale);
			} else {
				$value['fraction'] = str_pad($value['fraction'], $scale, '0', STR_PAD_RIGHT);
			}
		}
		
		$this->value = (strlen($value['fraction'])) ? join('.', $value) : $value['integer'];
		$this->scale = strlen($value['fraction']);
	}
	
	
	/**
	 * All requests that hit this method should be requests for callbacks
	 * 
	 * @internal
	 * 
	 * @param  string $method  The method to create a callback for
	 * @return callback  The callback for the method requested
	 */
	public function __get($method)
	{
		return array($this, $method);		
	}
	
	
	/**
	 * Converts the object to an string
	 * 
	 * @return string
	 */
	public function __toString()
	{
		return ($this->value[0] == '+') ? substr($this->value, 1) : $this->value;
	}
	
	
	/**
	 * Returns the absolute value of this number
	 * 
	 * @param  integer $scale  The number of places after the decimal - overrides the scale for this number
	 * @return fNumber  The absolute number
	 */
	public function abs($scale=NULL)
	{
		$scale = $this->fixScale($scale);
		return new fNumber(substr($this->value, 1), $scale);
	}
	
	
	/**
	 * Adds two numbers together
	 * 
	 * @throws fValidationException  When `$addend` is not a valid number
	 * 
	 * @param  fNumber|string $addend  The addend
	 * @param  integer        $scale   The number of places after the decimal - overrides the scale for this number
	 * @return fNumber  The sum
	 */
	public function add($addend, $scale=NULL)
	{
		$scale = $this->fixScale($scale);
		$addend = self::parse($addend, 'number');
		
		if (function_exists('bcadd')) {
			$sum = bcadd($this->value, $addend, $scale);
		} else {
			$sum = self::performAdd($this->value, $addend, $scale);
		}
		
		return new fNumber($sum, $scale);
	}
	
	
	/**
	 * Rounds the number to the next highest integer
	 * 
	 * @return fNumber  The next highest integer
	 */
	public function ceil()
	{
		if (strpos($this->value, '.') === FALSE) {
			return clone $this;
		}
		
		$fraction = substr($this->value, strpos($this->value, '.')+1);
		$integer  = substr($this->value, 0, strpos($this->value, '.'));
		
		// Negative numbers or numbers with only 0 after the decimal can be truncated
		if (trim($fraction, '0') === '' || $this->value[0] == '-') {
			return new fNumber($integer);
		}
		
		// Positive numbers with a fraction need to be increased
		return new fNumber(self::performAdd($integer, '1'));
	}
	
	
	/**
	 * Divides this number by the one passed
	 * 
	 * @throws fValidationException  When `$divisor` is not a valid number
	 * 
	 * @param  fNumber|string $divisor  The divisor
	 * @param  integer        $scale    The number of places after the decimal - overrides the scale for this number
	 * @return fNumber  The quotient
	 */
	public function div($divisor, $scale=NULL)
	{
		$scale   = $this->fixScale($scale);
		$divisor = self::parse($divisor, 'number');
		
		if (self::isZero($divisor)) {
			throw new fValidationException(
				'The divisor specified, %s, is zero, which is an invalid divisor',
				$divisor
			);
		}
		
		if (function_exists('bcdiv')) {
			$value = bcdiv($this->value, $divisor, $scale);
		} else {
			$value = self::performDiv($this->value, $divisor, $remainder, $scale);
		}
		
		return new fNumber($value, $scale);
	}
	
	
	/**
	 * Indicates if this value is equal to the one passed
	 * 
	 * @throws fValidationException  When `$number` is not a valid number
	 * 
	 * @param  fNumber|string $number  The number to compare to
	 * @param  integer        $scale   The number of decimal places to compare - will use all available if not specified
	 * @return boolean  If this number is equal to the one passed
	 */
	public function eq($number, $scale=NULL)
	{
		if ($scale !== NULL) {
			$scale = (int) $scale;
			if ($scale < 0) {
				$scale = 0;
			}
		}
		list($this_number, $number) = self::normalize($this, $number, $scale);
		
		return (self::cmp($this_number, $number) == 0) ? TRUE : FALSE;
	}
	
	
	/**
	 * Makes sure the scale is an int greater than `-1` - will return the current scale if the one passed is `NULL`
	 * 
	 * @param  integer $scale  The scale to check
	 * @return integer  The number of digits after the decimal place
	 */
	private function fixScale($scale)
	{
		$scale = ($scale !== NULL) ? (int) $scale : (int) $this->scale;
		if ($scale < 0) {
			$scale = 0;
		}
		return $scale;
	}
	
	
	/**
	 * Rounds the number to the next lowest integer
	 * 
	 * @return fNumber  The next lowest integer
	 */
	public function floor()
	{
		if (strpos($this->value, '.') === FALSE) {
			return clone $this;
		}
		
		$fraction = substr($this->value, strpos($this->value, '.')+1);
		$integer  = substr($this->value, 0, strpos($this->value, '.'));
		
		// Positive numbers or numbers with only 0 after the decimal can just be truncated
		if (trim($fraction, '0') === '' || $this->value[0] == '+') {
			return new fNumber($integer);
		}
		
		// Negative values with a fraction need to be brought down
		return new fNumber(self::performSub($integer, '1'));
	}
	
	
	/**
	 * Returns the float remainder of dividing this number by the divisor provided
	 * 
	 * @throws fValidationException  When `$divisor` is not a valid number
	 * 
	 * @param  fNumber|string $divisor  The divisor
	 * @param  integer        $scale    The number of places after the decimal - overrides the scale for this number
	 * @return fNumber  The remainder
	 */
	public function fmod($divisor, $scale=NULL)
	{
		$scale = $this->fixScale($scale);
		
		$div_frac = self::parse($divisor, 'fraction');
		$val_frac = self::parse($this->value, 'fraction');
		
		$actual_scale = max(strlen($div_frac), strlen($val_frac));
		
		self::performDiv($this->value, $divisor, $remainder, 0);
		
		$int_len = (strlen($remainder)-1 < $actual_scale) ? 1 : strlen($remainder)-$actual_scale;
		$int  = substr($remainder, 0, $int_len);
		$int  = (strlen($int)) ? $int : '0';
		
		$frac_start = (strlen($remainder)-1 < $actual_scale) ? 1 : strlen($remainder)-$actual_scale;
		$frac = substr($remainder, $frac_start);
		$frac = (strlen($frac)) ? '.' . $frac : '';
		
		if (strlen($int) == 1) {
			$int .= '0';
		}
		$remainder = $int . $frac;
		$remainder = self::setScale($remainder, $scale);
		
		return new fNumber($remainder);
	}
	
	
	/**
	 * Formats the number to include thousands separators
	 * 
	 * @param  boolean $remove_zero_fraction  If `TRUE` and all digits after the decimal place are `0`, the decimal place and all zeros are removed
	 * @return string  The formatted value
	 */
	public function format($remove_zero_fraction=FALSE)
	{
		if (self::$format_callback !== NULL) {
			return call_user_func(self::$format_callback, $this->value, $remove_zero_fraction);
		}
		
		// We can't use number_format() since it takes a float and we have a
		// string that can not be losslessly converted to a float
		$parts    = explode('.', $this->value);
		
		$integer  = $parts[0];
		$fraction = (!isset($parts[1])) ? '' : $parts[1];
		
		$sign    = ($integer[0] == '-') ? '-' : '';
		$integer = substr($integer, 1);
		
		$int_sections = array();
		for ($i = strlen($integer)-3; $i > 0; $i -= 3) {
			array_unshift($int_sections, substr($integer, $i, 3));
		}
		array_unshift($int_sections, substr($integer, 0, $i+3));
		
		$integer  = join(',', $int_sections);
		$fraction = (strlen($fraction)) ? '.' . $fraction : '';
		
		if ($remove_zero_fraction && rtrim($fraction, '.0') === '') {
			$fraction = '';
		}
		
		return $sign . $integer . $fraction;
	}
	
	
	/**
	 * Returns the scale of this number
	 * 
	 * @return integer  The scale of this number
	 */
	public function getScale()
	{
		return $this->scale;
	}
	
	
	/**
	 * Indicates if this value is greater than the one passed
	 * 
	 * @throws fValidationException  When `$number` is not a valid number
	 * 
	 * @param  fNumber|string $number  The number to compare to
	 * @param  integer        $scale   The number of decimal places to compare - will use all available if not specified
	 * @return boolean  If this number is less than the one passed
	 */
	public function gt($number, $scale=NULL)
	{
		if ($scale !== NULL) {
			$scale = (int) $scale;
			if ($scale < 0) {
				$scale = 0;
			}
		}
		list($this_number, $number) = self::normalize($this, $number, $scale);
		
		return (self::cmp($this_number, $number) > 0) ? TRUE : FALSE;
	}
	
	
	/**
	 * Indicates if this value is greater than or equal to the one passed
	 * 
	 * @throws fValidationException  When `$number` is not a valid number
	 * 
	 * @param  fNumber|string $number  The number to compare to
	 * @param  integer        $scale   The number of decimal places to compare - will use all available if not specified
	 * @return boolean  If this number is greater than or equal to the one passed
	 */
	public function gte($number, $scale=NULL)
	{
		if ($scale !== NULL) {
			$scale = (int) $scale;
			if ($scale < 0) {
				$scale = 0;
			}
		}
		list($this_number, $number) = self::normalize($this, $number, $scale);
		
		return (self::cmp($this_number, $number) > -1) ? TRUE : FALSE;
	}
	
	
	/**
	 * Indicates if this value is less than the one passed
	 * 
	 * @throws fValidationException  When `$number` is not a valid number 
	 * 
	 * @param  fNumber|string $number  The number to compare to
	 * @param  integer        $scale   The number of decimal places to compare - will use all available if not specified
	 * @return boolean  If this number is less than the one passed
	 */
	public function lt($number, $scale=NULL)
	{
		if ($scale !== NULL) {
			$scale = (int) $scale;
			if ($scale < 0) {
				$scale = 0;
			}
		}
		list($this_number, $number) = self::normalize($this, $number, $scale);
		
		return (self::cmp($this_number, $number) < 0) ? TRUE : FALSE;
	}
	
	
	/**
	 * Indicates if this value is less than or equal to the one passed
	 * 
	 * @throws fValidationException  When `$number` is not a valid number 
	 * 
	 * @param  fNumber|string $number  The number to compare to
	 * @param  integer        $scale   The number of decimal places to compare - will use all available if not specified
	 * @return boolean  If this number is less than or equal to the one passed
	 */
	public function lte($number, $scale=NULL)
	{
		if ($scale !== NULL) {
			$scale = (int) $scale;
			if ($scale < 0) {
				$scale = 0;
			}
		}
		list($this_number, $number) = self::normalize($this, $number, $scale);
		
		return (self::cmp($this_number, $number) < 1) ? TRUE : FALSE;
	}
	
	
	/**
	 * Returns the remainder of dividing this number by the divisor provided. All floats are converted to integers.
	 * 
	 * @throws fValidationException  When `$divisor` is not a valid number 
	 * 
	 * @param  fNumber|string $divisor  The divisor - will be converted to an integer if it is a float
	 * @return fNumber  The remainder
	 */
	public function mod($divisor)
	{
		// Modulus only works on the integer part of the number
		$divisor = self::parse($divisor, 'integer');
		$number  = self::parse($this->value, 'integer');
		
		if (function_exists('bcmod')) {
			$remainder = bcmod($number, $divisor);
		} else {
			self::performDiv($number, $divisor, $remainder);
			$remainder = $number[0] . substr($remainder, 1);
		}
		
		return new fNumber($remainder);
	}
	
	
	/**
	 * Multiplies two numbers
	 * 
	 * @throws fValidationException  When `$multiplier` is not a valid number 
	 * 
	 * @param  fNumber|string $multiplier  The multiplier
	 * @param  integer        $scale       The number of places after the decimal - overrides the scale for this number
	 * @return fNumber  The product
	 */
	public function mul($multiplier, $scale=NULL)
	{
		$scale      = $this->fixScale($scale);
		$multiplier = self::parse($multiplier, 'number');
		
		if (function_exists('bcmul')) {
			$value = bcmul($this->value, $multiplier, $scale);
		} else {
			$value = self::performMul($this->value, $multiplier, $scale);
		}
		
		return new fNumber($value, $scale);
	}
	
	
	/**
	 * Negates this number
	 * 
	 * @param  integer $scale  The number of places after the decimal - overrides the scale for this number
	 * @return fNumber  The negated number
	 */
	public function neg($scale=NULL)
	{
		$scale = $this->fixScale($scale);
		$value = substr($this->value, 1);
		$value = ($this->value[0] == '-') ? '+' . $value : '-' . $value;
		return new fNumber($value, $scale);
	}
	
	
	/**
	 * Raise this number to the power specified
	 * 
	 * @throws fValidationException  When `$exponent` is not a valid number 
	 * 
	 * @param  integer $exponent  The power to raise to - all non integer values will be truncated to integers
	 * @param  integer $scale     The number of places after the decimal - overrides the scale for this number
	 * @return fNumber  The product
	 */
	public function pow($exponent, $scale=NULL)
	{
		$scale = $this->fixScale($scale);
		
		if (function_exists('bcpow')) {
			$value = bcpow($this->value, (int) $exponent, $scale);
		} else {
			$value = self::performPow($this->value, (int) $exponent, $scale);
		}
		
		return new fNumber($value, $scale);
	}
	
	
	/**
	 * Gets the remainder of this integer number raised to the integer `$exponent`, divided by the integer `$modulus`
	 * 
	 * This method is faster than doing `$num->pow($exponent)->mod($modulus)`
	 * and is primarily useful for cryptographic functionality.
	 * 
	 * @throws fValidationException  When `$exponent` or `$modulus` is not a valid number 
	 * 
	 * @param  fNumber|string $exponent  The power to raise to - all non integer values will be truncated to integers
	 * @param  fNumber|string $modulus   The value to divide by - all non integer values will be truncated to integers
	 * @return fNumber  The remainder
	 */
	public function powmod($exponent, $modulus)
	{
		$exp = self::parse($exponent, 'array');
		$mod = self::parse($modulus, 'array');
		
		if ($this->value[0] == '-') {
			throw new fProgrammerException(
				'The method %s can only be called for positive number, however this number is negative',
				'powmod()'
			);
		}
		
		if ($exp['integer'][0] == '-') {
			throw new fProgrammerException(
				'The exponent specified, %s, must be a positive integer, however it is negative',
				$exponent
			);
		}
		
		if ($mod['integer'][0] == '-') {
			throw new fProgrammerException(
				'The modulus specified, %s, must be a positive integer, however it is negative',
				$modulus
			);
		}
		
		// All numbers involved in this need to be integers
		$exponent = $exp['integer'];
		$modulus  = $mod['integer'];
		$len      = (strpos($this->value, '.') !== FALSE) ? strpos($this->value, '.') : strlen($this->value);
		$value    = substr($this->value, 0, $len);
		
		if (function_exists('bcpowmod')) {
			$result = bcpowmod($value, $exponent, $modulus, 0);
		
		} else {
			$exponent = self::baseConvert($exponent, 10, 2);
			$result   = '+1';
			
			self::performDiv($value, $modulus, $first_modulus);
			for ($i=0; $i < strlen($exponent); $i++) {
				self::performDiv(self::performMul($result, $result), $modulus, $result);
				if ($exponent[$i] == '1') {
					self::performDiv(self::performMul($result, $first_modulus), $modulus, $result);
				}
			}
		}
		
		return new fNumber($result);
	}
	
	
	/**
	 * Rounds this number to the specified number of digits after the decimal - negative scales round the number by places to the left of the decimal
	 * 
	 * @param  integer $scale  The number of places after (or before if negative) the decimal to round to
	 * @return fNumber  The rounded result
	 */
	public function round($scale)
	{
		$scale = (int) $scale;
		$number = self::setScale($this->value, ($scale < 0) ? 1 : $scale+1);
		
		$length = strlen($number);
		$add    = FALSE;
		
		if ($scale == 0) {
			if ($number[$length-1] >= 5) {
				$add = '1';
			}
			$number = substr($number, 0, -2);
		
		} elseif ($scale > 0) {
			if ($number[$length-1] >= 5) {
				$add = '0.' . str_pad('', $scale-1, '0') . '1';
			}
			$number = substr($number, 0, -1);
		
		} else {
			$number = substr($number, 0, strpos($number, '.'));
			
			if (abs($scale) >= strlen($number)) {
				$number = '0';
			} else {
				if ($number[strlen($number)-abs($scale)] >= 5) {
					$add = '1' . str_pad('', abs($scale), '0');
				}
				$number = substr($number, 0, $scale);
				$number .= str_pad('', abs($scale), '0');
			}
		}
		
		if ($add) {
			$number = self::performAdd($number, $add, $scale);
		}
		
		return new fNumber($number);
	}
	
	
	/**
	 * Returns the sign of the number
	 * 
	 * @return integer  `-1` if negative, `0` if zero, `1` if positive
	 */
	public function sign()
	{
		if (self::isZero($this->value)) {
			return 0;
		}
		return ($this->value[0] == '-') ? -1 : 1;
	}
	
	
	/**
	 * Returns the square root of this number
	 * 
	 * @param  integer $scale  The number of places after the decimal - overrides the scale for this number
	 * @return fNumber  The square root
	 */
	public function sqrt($scale=NULL)
	{
		$scale = $this->fixScale($scale);
		
		if ($this->sign() == -1) {
			throw new fProgrammerException(
				'This number, %s, can not have the square root calculated since it is a negative number',
				$this->value
			);
		}
		
		if (function_exists('bcsqrt')) {
			$value = bcsqrt($this->value, $scale);
			return new fNumber($value, $scale);
		}
		
		// Pure PHP implementation
		$parts = explode('.', $this->value);
		
		$integer  = substr($parts[0], 1);
		$fraction = (isset($parts[1])) ? $parts[1] : '';
		
		if (strlen($integer)%2 == 1) {
			$integer = '0' . $integer;
		}
				
		if (strlen($fraction)%2 == 1) {
			$fraction .= '0';
		}
		
		$after_decimal = strlen($fraction)/2;
		
		$number    = $integer . $fraction;
		$i         = 0;
		$remainder = '0';
		$p         = '0';
		
		$len  = strlen($number);
		$len += (($scale*2) - $after_decimal > 0) ? ($scale*2) - $after_decimal : 0;
		
		while ($i < $len) {
			
			if ($i < strlen($number)) {
				$c = substr($number, $i, 2);
			} else {
				$c = '00';
				$after_decimal++;
			}
			
			if (!self::isZero($remainder)) {
				$c = $remainder . $c;
			}
			
			$x  = -1;
			$p2 = self::performMul($p, '2');
			
			do {
				$x++;
			} while(self::cmp(self::performMul($p2 . $x, $x), $c) <= 0);
			
			$x--;
			$y = self::performMul($p2 . $x, $x);
			$p = ($p) ? $p . $x : $x;
			
			$remainder = self::performSub($c, $y);
			
			$i += 2;
		}
		
		if (strlen($p) <= $after_decimal) {
			$p = $p[0] . str_pad(substr($p, 1), $after_decimal+1, '0', STR_PAD_LEFT);
		}
		
		$integer  = substr($p, 0, strlen($p)-$after_decimal);
		$fraction = substr($p, strlen($p)-$after_decimal);
		$fraction = (strlen($fraction)) ? '.' . $fraction : '';
		
		$p = $integer . $fraction;
		
		$p = self::setScale($p, $scale);
		$p = self::stripLeadingZeroes($p);
		
		return new fNumber($p);
	}
	
	
	/**
	 * Subtracts two numbers
	 * 
	 * @throws fValidationException  When `$subtrahend` is not a valid number 
	 * 
	 * @param  fNumber|string $subtrahend  The subtrahend
	 * @param  integer        $scale       The number of places after the decimal - overrides the scale for this number
	 * @return fNumber  The difference
	 */
	public function sub($subtrahend, $scale=NULL)
	{
		$scale      = $this->fixScale($scale);
		$subtrahend = self::parse($subtrahend, 'number');
		
		if (function_exists('bcadd')) {
			$diff = bcsub($this->value, $subtrahend, $scale);
		} else {
			$diff = self::performSub($this->value, $subtrahend, $scale);
		}
		
		return new fNumber($diff, $scale);
	}
	
	
	/**
	 * Scales (truncates or expands) the number to the specified number of digits after the decimal - negative scales round the number by places to the left of the decimal
	 * 
	 * @param  integer $scale  The number of places after (or before if negative) the decimal
	 * @return fNumber  The square root
	 */
	public function trunc($scale)
	{
		$scale  = (int) $scale;
		$number = $this->value;
		
		if ($scale < 0) {
			$number = substr($number, 0, strpos($number, '.'));
			
			if (abs($scale) >= strlen($number)) {
				$number = '0';
			} else {
				$number = substr($number, 0, $scale);
				$number .= str_pad('', abs($scale), '0');
			}
		}
		
		return new fNumber($number, $scale);
	}
}

/**
 * An exception that should probably not be handled by the display code, fCore::enableExceptionHandler() is recommended
 * 
 * @copyright  Copyright (c) 2007-2008 Will Bond
 * @author     Will Bond [wb] <will@flourishlib.com>
 * @license    http://flourishlib.com/license
 * 
 * @package    Flourish
 * @link       http://flourishlib.com/fUnexpectedException
 * 
 * @version    1.0.0b
 * @changes    1.0.0b  The initial implementation [wb, 2007-06-14]
 */
class fUnexpectedException extends fException
{
	/**
	 * Prints out a generic error message inside of a `div` with the class being `'exception {exception_class_name}'`
	 * 
	 * @return void
	 */
	public function printMessage()
	{
		echo '<div class="exception ' . $this->getCSSClass() . '"><p>';
		echo self::compose(
			'It appears an error has occured â€” we apologize for the inconvenience. The problem may be resolved if you try again.'
		);
		echo '</p></div>';
	}
}

/**
 * An exception that should be handled by the display code
 * 
 * @copyright  Copyright (c) 2007-2008 Will Bond
 * @author     Will Bond [wb] <will@flourishlib.com>
 * @license    http://flourishlib.com/license
 * 
 * @package    Flourish
 * @link       http://flourishlib.com/fExpectedException
 * 
 * @version    1.0.0b
 * @changes    1.0.0b  The initial implementation [wb, 2007-06-14]
 */
class fExpectedException extends fException
{
}

/**
 * An exception caused by programmer error
 * 
 * @copyright  Copyright (c) 2007-2008 Will Bond
 * @author     Will Bond [wb] <will@flourishlib.com>
 * @license    http://flourishlib.com/license
 * 
 * @package    Flourish
 * @link       http://flourishlib.com/fProgrammerException
 * 
 * @version    1.0.0b
 * @changes    1.0.0b  The initial implementation [wb, 2007-06-14]
 */
class fProgrammerException extends fUnexpectedException
{
}

/**
 * An exception caused when trying to get a value from an iterator and there is nothing left
 * 
 * @copyright  Copyright (c) 2007-2008 Will Bond
 * @author     Will Bond [wb] <will@flourishlib.com>
 * @license    http://flourishlib.com/license
 * 
 * @package    Flourish
 * @link       http://flourishlib.com/fNoRemainingException
 * 
 * @version    1.0.0b2
 * @changes    1.0.0b2  Fixed a typo in the documentation [wb, 2010-07-14]
 * @changes    1.0.0b   The initial implementation [wb, 2007-06-14]
 */
class fNoRemainingException extends fExpectedException
{
}

/**
 * An exception when no rows are returned from a SQL query
 * 
 * @copyright  Copyright (c) 2007-2008 Will Bond
 * @author     Will Bond [wb] <will@flourishlib.com>
 * @license    http://flourishlib.com/license
 * 
 * @package    Flourish
 * @link       http://flourishlib.com/fNoRowsException
 * 
 * @version    1.0.0b
 * @changes    1.0.0b  The initial implementation [wb, 2007-06-14]
 */
class fNoRowsException extends fExpectedException
{
}

/**
 * An exception occurred while executing a SQL statement
 * 
 * @copyright  Copyright (c) 2007-2008 Will Bond
 * @author     Will Bond [wb] <will@flourishlib.com>
 * @license    http://flourishlib.com/license
 * 
 * @package    Flourish
 * @link       http://flourishlib.com/fSQLException
 * 
 * @version    1.0.0b
 * @changes    1.0.0b  The initial implementation [wb, 2007-06-14]
 */
class fSQLException extends fUnexpectedException
{
}

/**
 * Copyright (c) 2007-2008 Will Bond <will@flourishlib.com>
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

main();
